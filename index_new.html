<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>draw</title>
    <style>
        body { margin: 0; overflow: hidden }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>
<!--Trajectory viewer-->
<script>

    var CAM_NEAR = -100;
    var CAM_FAR = 100;

    const GUI_FLOORMIN = -2;
    const GUI_FLOORMAX = 2;
    const GUI_FLOORSTEP = 1;
    const GUI_SCALEMIN = 50;
    const GUI_SCALEMAX = 200;
    const GUI_SCALESTEP = 50;

    const INIT_FLOOR = 1;
    const INIT_SCALE = 50;
    const INIT_FILEPATH = 'LUCI-neu-';
    const INIT_EXT = '.png';
    const INIT_LINETYPE = 'Point';

    const TRAJ_COLOR = 0xFF0000;
    const TRAJ_CUT_TIME = 8000; // 8 s in ms
    //const TRAJ_CUT_TIME = 0.08; //s

    const BG_DIR = 'img/';
    const BG_COLOR = 0xFFFFFF;
    const BG_ALPHA = 0;
    const BG_MESH_NAME = 'backgroundMesh-';
    const BG_CORR_Z = -0.4;

    const GRID_D = 5;
    const GRID_CORR_Z = 0.4;

    const POINT_SIZE = 5.0;

    const CSV_REPL_HEADER = 't,x,y,acc,f,did';

    //three.js
    var camera, scene, renderer;
//    var camerahelper;
    var mouse, raycaster;

    //dat.gui
    var gui;

    /*    var cam = {
        C_N: -100,
        C_F: 100,
        cnListener: function() {},
        cfListener: function() {},
        get CAM_NEAR(){

        }
        get CAM_FA

    };*/


    //daten des dargestellten geb√§udes
    var building = {
        w: window.innerWidth,
        h: window.innerHeight,
        ratio: this.w / this.h,
        wListener: function() {},
        hListener:function() {},

        get width(){
            return this.w;
        },
        get height(){
            return this.h;
        },
        set width( val ) {
            this.w = val;
            this.wListener( val ) 
        },
        set height( val ) {
            this.h = val;
            this.hListener( val ) ;
        },
        registerWListener: function( listener ) {
            this.hListener = listener;
        },
        registerHListener: function( listener ) {
            this.wListener = listener;
        },

        f: INIT_FLOOR,
        fListener: function() {},
        get floor(){
            return this.f;
        },
        set floor( val ) {
            if( val != this.f )  {
                this.f = val;
                this.fListener( val ) ;
            }
        },
        registerFListener: function( listener ) {
            this.fListener = listener;
        },

        s: INIT_SCALE,
        sListener: function() {},
        get scale(){
            return this.s;
        },
        get scaleFraction(){
            return (1/this.s ) ;
        },
        set scale( val ) {
            if( val != this.s ) {
                this.s = val;
                this.sListener( val ) ;
            }
        },
        registerSListener: function( listener ) {
            this.sListener = listener;
        },

        filePath: INIT_FILEPATH,
        fileExt: INIT_EXT,
        get path(){
            return this.filePath + this.f + this.fileExt;
        },

        lt: INIT_LINETYPE,
        ltListener: function() {},
        get lineType(){
            return this.lt;
        },
        set lineType( val ) {
            if( val != this.lt )  {
                this.lt = val;
                this.ltListener( val ) ;
            }
        },
        registerLtListener: function( listener ) {
            this.ltListener = listener;
        },

        bgMeshes: {},
        grids: {},
        trajectoryFloorGroups: {}
    };
    building.registerWListener( function( ) {
        this.ratio = this.w / this.h;
        configCamera();
        updateRenderer();
    });
    building.registerHListener( function( ){
        this.ratio = this.w / this.h;
        configCamera();
        updateRenderer();
    });
    building.registerFListener( function( ){
        changeFloors( building.floor, building.path );
    });
    building.registerSListener( function( ){
        changeScale();
    });
    building.registerLtListener( function( ){
        changeLineType();
    });

    var Trajectory = function(){
        this.color = TRAJ_COLOR;
        this.did = '';
        this.floor = 0;
        this.points = [];
        this.line = new THREE.Line();
        this.visible = false;
    };

    init();
    update();

    function init(){
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera( 0, 0, 0, 0, 0, 0, 0 );

        initRenderer();
        configCamera();
        initDatGUI();
        initBackgroundFileInput();
        initDataFileInput();
        addWindowListeners();
    }

    function initRenderer(){
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor( BG_COLOR, BG_ALPHA );
//        renderer.setPixelRatio( window.devicePixelRatio ) ;
        document.body.appendChild( renderer.domElement ) ;
        updateRenderer();
    }
    function updateRenderer(){
        renderer.setSize( window.innerWidth, window.innerHeight ) ;
    }

    function configCamera(){

        var windowRatio = window.innerWidth / window.innerHeight;

        if(( window.innerWidth / window.innerHeight )  < building.ratio ) {
            camera = new THREE.OrthographicCamera(0, building.width,
                 0, -building.width / windowRatio, CAM_NEAR, CAM_FAR);
        } else {
            camera = new THREE.OrthographicCamera(0, building.height * windowRatio,
                0, -building.height, CAM_NEAR, CAM_FAR);
        }
        updateCamera();
    }
    function updateCamera(){

        camera.updateProjectionMatrix();

        /*if( camerahelper ) {
            camerahelper.update();
        }*/
    }

    function initDatGUI(){
        gui = new dat.GUI();
        gui.add( building, 'floor', GUI_FLOORMIN, GUI_FLOORMAX ).step( GUI_FLOORSTEP ).name( 'Floor' );
        gui.add( building, 'scale', GUI_SCALEMIN, GUI_SCALEMAX ).step( GUI_SCALESTEP ).name( 'Scale (1:X)' );
        gui.add( building, 'lineType', ['Line', 'Curve', 'Point']).name( 'Line type' );
        /*var f1 = gui.addFolder( 'Dev tools' );
        f1.add( this, 'CAM_FAR' ).step( 0.5 ).listen();
        f1.add( this, 'CAM_NEAR' ).step( 0.5 ).listen();*/
    }

    function initBackgroundFileInput(){
        var buildingFileInput = document.createElement( 'input' );
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.accept = "image/*";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        document.body.appendChild( buildingFileInput );

        buildingFileInput.addEventListener( 'change', function(){

            var file = buildingFileInput.files[0];
            var fileName = buildingFileInput.files[0].name;
            var fileType = /image.*/;

            if ( file.type.match( fileType ) ){

                building.filePath = fileName.slice( 0, -5 );
                building.fileExt = fileName.slice( -4, fileName.length );

                deleteAll();
                changeFloors( building.floor, building.path );

            } else {
                alert( "File not supported" );
            }
        });

        var buildingFile = {
            loadBuildingFile: function() {
                document.getElementById( "buildingFileInput" ).click();
            }
        };
        gui.add( buildingFile, 'loadBuildingFile' ).name( 'Load building' );
    }
    function initDataFileInput(){
        var dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild( dataFileInput ) ;

        dataFileInput.addEventListener( 'change', function() {

            for( var file = 0; file < dataFileInput.files.length; file++ ){
                var reader = new FileReader();
                reader.onload = function() {
                    var result = this.result;
                    loadNewTrajectories( result );
                };
                reader.readAsText( dataFileInput.files[file] );
            }

            this.value = null; //remove filename from input
        });

        var trajectoryFile = {
            loadDataFile : function() {
                document.getElementById("dataFileInput").click();
            }
        };
        gui.add( trajectoryFile, 'loadDataFile').name('Load trajectories');
    }


    function loadNewBgMesh( buildingName, floor ){

        var buildingPath = BG_DIR + buildingName;
        var backgroundMesh;
        var bgMaterial = new THREE.MeshBasicMaterial();

        var bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            function ( texture ) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //pixel in meter umrechnen
                building.width = texture.image.naturalWidth * building.scaleFraction;
                building.height = texture.image.naturalHeight * building.scaleFraction;

                //create bgPlane
                var backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push( new THREE.Vector3( 0, 0, floor + BG_CORR_Z ));
                backgroundPlane.vertices.push( new THREE.Vector3( 0, -building.height, floor + BG_CORR_Z ));
                backgroundPlane.vertices.push( new THREE.Vector3( building.width, -building.height, floor + BG_CORR_Z ));
                backgroundPlane.vertices.push( new THREE.Vector3( building.width, 0, floor + BG_CORR_Z ));

                backgroundPlane.faces.push( new THREE.Face3( 0,1,3 ));
                backgroundPlane.faces.push( new THREE.Face3( 1,2,3 ));
                //backgroundPlane.computeFaceNormals();

                backgroundPlane.faceVertexUvs[0] = [];
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2( 0,1 ),
                    new THREE.Vector2( 0,0 ),
                    new THREE.Vector2( 1,1 )
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2( 0,0 ),
                    new THREE.Vector2( 1,0 ),
                    new THREE.Vector2( 1,1 )
                ]);
                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );
                backgroundMesh.name = BG_MESH_NAME + building.floor;

                building.bgMeshes[floor] = backgroundMesh;
                scene.add( building.bgMeshes[floor] );

                loadNewGrid( floor );
                initRaycaster(); //testing

            },
            function (){},
            function (){
                console.log( 'BG-loading failed' );
            }
        );
    }
    function loadNewGrid( floor ){

        var coordLines;
        var coordGeometry = new THREE.Geometry();

        //x-axis
        for( var x = 0; x < ( building.height ); x += GRID_D ){
            coordGeometry.vertices.push( new THREE.Vector3( 0, -x, floor + GRID_CORR_Z ));
            coordGeometry.vertices.push( new THREE.Vector3( building.width, -x, floor + GRID_CORR_Z ));
        }
        //y-axis
        for( var y = 0; y < ( building.width ); y += GRID_D ){
            coordGeometry.vertices.push( new THREE.Vector3( y, 0, floor + GRID_CORR_Z ));
            coordGeometry.vertices.push( new THREE.Vector3( y, -building.height, floor + GRID_CORR_Z ));
        }

        var coordMaterial = new THREE.LineBasicMaterial({ color: 0x555555, opacity: 1, linewidth: 1 });
        coordLines = new THREE.LineSegments( coordGeometry, coordMaterial );

        building.grids[floor] = coordLines;
        scene.add( coordLines );
    }
    function loadNewTrajectories( readerResult ){

        var pointList = parseCSV( readerResult );
        pointList = sortPoints( pointList );

        var pointListByDID = groupPointListByDid( pointList );
        var pointListByDIDByFloor = [];
        var pointListByDIDByFloorByTime = [];

        for( var did1 in pointListByDID ){
            if ( pointListByDID.hasOwnProperty( did1 ) ){
                pointListByDIDByFloor[did1] = groupPointListByFloor( pointListByDID[did1]);
            }
        }
        for( var did2 in pointListByDIDByFloor ){

            var tempList = [];

            for ( var floor1 in pointListByDIDByFloor[did2]){
                if ( pointListByDIDByFloor[did2].hasOwnProperty( floor1 ) ) {

                    tempList[floor1] = groupPointListByTime(pointListByDIDByFloor[did2][floor1])
                }
            }
            pointListByDIDByFloorByTime[did2] = tempList;
        }
        for( var did3 in pointListByDIDByFloorByTime ){
            for( var floor2 in pointListByDIDByFloorByTime[did3] ){
                if( pointListByDIDByFloorByTime[did3].hasOwnProperty( floor2 ) ){
                    for ( var pointGroup in pointListByDIDByFloorByTime[did3][floor2] ){
                        if( pointListByDIDByFloorByTime[did3][floor2].hasOwnProperty( pointGroup ) ){
                            var tempTrajectory = new Trajectory();
                            tempTrajectory.did = did3;
                            tempTrajectory.floor = pointListByDIDByFloorByTime[did3][floor2][pointGroup][0].f;
                            tempTrajectory.points = pointListByDIDByFloorByTime[did3][floor2][pointGroup];

                            if ( !building.trajectoryFloorGroups[tempTrajectory.floor] ){
                                building.trajectoryFloorGroups[tempTrajectory.floor] = [];
                            }
                            if ( tempTrajectory.points.length > 1 ){
                                building.trajectoryFloorGroups[tempTrajectory.floor].push( tempTrajectory );
                            }
                        }
                    }
                }
            }
        }

        makeAllTrajectories();
        addAllTrajectories();
    }


    function parseCSV ( csvString ){

        var pointsList = Papa.parse( csvString , {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            comments: '#',
            //step: true,
            beforeFirstChunk: function( chunk ) {
                var rows = chunk.split( /\r\n|\r|\n/ );
                rows[0] = CSV_REPL_HEADER;
                return rows.join("\r\n");
            }
        });
        return pointsList.data; // = array of objects
    }
    /*function corrPoints ( pointList ){
        pointList.forEach(
            function ( point ) {
                point.y = point.y * -1;
            }
        );
        return pointList;
    }*/
    function groupPointListByFloor( pointList ){
        return groupBy(
            pointList,
            function( item )  {
                return [item.f]; //, item.t
            }
        );
    }
    function groupPointListByDid( pointList ){
        return groupBy(
            pointList,
            function( item )  {
                return [item.did]; //, item.t
            }
        );
    }
    function groupPointListByTime( pointList ){

        var pointListByTime = [];

        var tempTime = pointList[0].t;
        var tempTimeArray = [];


        pointList.forEach(function( point ){

            if( tempTime + TRAJ_CUT_TIME < point.t ) {

                pointListByTime.push( tempTimeArray ) ;
                tempTimeArray = [];
                tempTimeArray.push( point );
                tempTime = point.t;

            } else {

                tempTimeArray.push( point );
                tempTime = point.t;

            }
        });
        pointListByTime.push(tempTimeArray);

        /* var pointListByTime = groupBy(
            pointList,
            function( item )  {
                return [item.did]; //, item.t
            }
        );*/
        return pointListByTime;
    }
    function groupBy( array, f ){

        var groups = {};
        array.forEach(
            function( object ) {
                var group = JSON.stringify( f( object ) );
                groups[group] = groups[group] || []; //if groups[group] doesn't exist, [] is assigned
                groups[group].push( object );
            }
        );
        return groups;

        /*return Object.keys( groups ) .map(
            function( group ) {
                return groups[group];
            }
        )*/
    }
    function sortPoints( pointList ){
        pointList.sort(
            firstBy("did")
            .thenBy("f")
            .thenBy("t")
        );

        return pointList;
    }

    function makeAllTrajectories(){
        for( var floor in building.trajectoryFloorGroups ){
            if( building.trajectoryFloorGroups.hasOwnProperty( floor ) ){
                building.trajectoryFloorGroups[floor].forEach( function ( traj ){

                    var tempTrajGeom;
                    if ( building.lineType == 'Line' ){
                        tempTrajGeom = makeLineGeom( traj.points );
                        traj.line = makeLine( tempTrajGeom, traj.color );
                    } else if ( building.lineType == 'Curve' ){
                        tempTrajGeom = makeCurveGeom( traj.points );
                        traj.line = makeLine( tempTrajGeom, traj.color );
                    } else if ( building.lineType == 'Point' ){
                        tempTrajGeom = makePointGeom( traj.points );
                        traj.line = makeDots( tempTrajGeom, traj.color );
                    }

                });
            }
        }
    }
    function makeLine( trajGeom, color ){
        var trajectoryMaterial = new THREE.LineBasicMaterial({ color: color, opacity: 1 });
        return new THREE.Line( trajGeom, trajectoryMaterial );
    }
    function makeDots( trajGeom, color ){
        var trajectoryMaterial = new THREE.PointsMaterial({ color: color, opacity: 1, size: POINT_SIZE, sizeAttenuation: false });
        return new THREE.Points( trajGeom, trajectoryMaterial );
    }

    function makeLineGeom( points ){

        var vertices = [];
        points.forEach(
            function ( point ){
                vertices.push( new THREE.Vector3( point.x, point.y * -1, point.f ));
            }
        );

        var lineGeom = new THREE.Geometry();
        lineGeom.name = points[0].did;
        lineGeom.vertices = vertices;

        return lineGeom;
    }
    function makeCurveGeom( points ){

        var vertices = [];
        points.forEach(
            function( point ){
                vertices.push( new THREE.Vector3( point.x, point.y * -1, point.f ));
            }
        );
        var curve = new THREE.CatmullRomCurve3( vertices );
        var curveGeom = new THREE.Geometry();
        curveGeom.name = points[0].did;
        curveGeom.vertices = curve.getPoints( 50 );

        return curveGeom;
    }
    function makePointGeom( points ){

        var vertices = [];

       /* points.forEach(
            function( point ){
                vertices.push( new THREE.Vector3( point.x, point.y, point.f ));
            }
        );*/

        //subsampling
        vertices = subsamplePoints( points );

        //centroid seed
        var verticesWCentroids = seedCentroids( vertices );

        verticesWCentroids.forEach(
            function( point ){
                vertices.push( new THREE.Vector3( point.x, point.y * -1, point.f ));
            }
        );

        var pointGeom = new THREE.Geometry();
        pointGeom.name = points[0].did;
        pointGeom.vertices = vertices;

        return pointGeom;
    }

    function subsamplePoints( points ){

        var vertices = [];

        //R = Radius for subsampling, r = radius remaining for next segment, i = iterator, p0 = first point of traj,
        //pA and pB are start and end of segment to be subsampled, D = dist between pA and pB, d = remaining distance
        //p = subsampled point, vh = ratio of _________ (?),

        var R = 3;
        var r = R;

        var i = 0;

        var p0 = { x: points[i].x, y: points[i].y, f: points[i].f, t: points[i].t, did: points[i].did  };
        vertices.push( p0 );

        for( i; i < points.length - 2; i++ ){
            if( points.hasOwnProperty( i ) ){

                var pA = points[i];
                var pB = points[i + 1];

                var D = spatialDistance( pA, pB );
                var d = D;

                while( d > r ){
                    var vh = ( r + ( D - d ) ) / D;
                    // t not interpolated!!
                    var p = { x: ( 1 - vh ) * pA.x + vh * pB.x, y: ( 1 - vh ) * pA.y + vh * pB.y, f: pA.f, t: pA.t, did: pA.did };

                    vertices.push( p );

                    d -= r;
                    r = R;
                }
                r -= d;
            }
        }
        //√ºber raum interpolieren -- k√∂nnte mit curve.getSpacedPoints gemacht werden (?)
        /*for( var v = 0 ; var vector in vertices ){

         var parts =

         }
         var line = new THREE.LineSegments()*/

        return vertices;
    }
    function spatialDistance( p1, p2 ){
        return Math.sqrt( (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) );
    }

    var maxRadius = 10;
    var C = [];

    function seedCentroids( points ){

        var P = points;

        var G = {
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0,
            grid: []
        }; //grid

        for( var i in P ){

            var p = P[i];

            if( G.xMin > p.x ) G.xMin = p.x;
            if( G.xMax < p.x ) G.xMax = p.x;
            if( G.yMin > p.y ) G.yMin = p.y;
            if( G.yMax < p.y ) G.yMax = p.y;
        }

        //build grid

        /*for( var x = xMin; x <= xMax; x += maxRadius ){

            var u = { x1: x, y1: yMin, x2: x, y2: yMax };
            G.push( u );
        }
        for( var y = yMin; y <= yMax; y += maxRadius ){

            var v = { x1: xMin, y1: y, x2: xMax, y: y };
            G.push( v );
        }*/

        for( var x = G.xMin; x <= G.xMax; x += maxRadius ){

            var gX = [];

            for( var y = G.yMin; y <= G.yMax; y += maxRadius ) {

                var gY = [];
                gX.push( gY );
            }
            G.grid.push( gX );
        }
        //

        var R = []; //results

        for( var j in P ){

            putInProperGroup( P[j], R, G );
        }
        redistributePoints( P, R, G );

        return P; //change to R later
    }
    function putInProperGroup( p, R, G ){
        var c = getClosestCentroid( p, G );
        var gr = {
            centroid: {},
            members: []
        };

        if( c == null ){

            gr.centroid = {
                    x: p.x,
                    y: p.y,
                    g: gr
                };
            R.push( gr );
        } else {
            gr = c.g; // g is group with centroid c // indices? centroid array? -------------------------------
            gr.members.push( p );
            var gc = getGridPosition( c, G );

            var index = G.grid[gc.i][gc.j].indexOf( c );
            G.grid[gc.i][gc.j].splice( index, 1 );

            gr.centroid = getCentroid( gr.members );
            gr.centroid.g = gr;
        }
        gc = getGridPosition( gr.centroid, G );
        G.grid[gc.i][gc.j].push( gr.centroid );
    }
    function getClosestCentroid( p, G ){
        var gc = getGridPosition( p, G );
        var C = [];
        for( var k = Math.max( gc.i - 1, 1 ); k < Math.min( gc.i + 1, G.grid.length ); k++ ){
            for( var m = Math.max( gc.j - 1, 1 ); m < Math.min( gc.j + 1, G.grid[gc.i].length ); m++ ){
                for( var c in G.grid[k][m] ){
                    if( G.grid[k][m].hasOwnProperty( c ) ) {
                        if ( spatialDistance( p, G.grid[k][m][c] ) <= maxRadius ) {
                            C.push( G.grid[k][m][c] );
                        }
                    }
                }
            }
        }
        if( C.length == 0 ){
            return null;
        } else if( C.length == 1){
            return C[0];
        } else {
            var ck = C[0];

            for( var l in C ){
                if( spatialDistance( C[l], p ) <= spatialDistance( ck, p )){
                    ck = C[l];
                }
            }
            return ck;
        }
    }
    function getGridPosition( p, G ){
        var gc = {
            i: Math.floor( ( p.x - G.xMin ) / maxRadius ),
            j: Math.floor( ( p.y - G.yMin ) / maxRadius )
        };
        return gc;
    }
    function redistributePoints( P, R, G ){
        for( var r in R ){
            R[r].members = [];
        }
        for( var p in P ){
            var c = getClosestCentroid( P[p], G );
            if( c != null ){ // FEHLER! WARUM KANN c NULL SEIN? -> Kein centroid in reichweite
                var gr = c.g; //---------------------------------------------------
                gr.members.push( P[p] );
            }
        }
    }
    function getCentroid( points ){

        var c = {
            x: 0,
            y: 0,
            g: {}
        };
        var sumX = 0;
        var sumY = 0;
        var numPoints = points.length;

        for( var p in points ){
            sumX += points[p].x;
            sumY += points[p].y;
        }

        if( numPoints > 0 ) {
            c.x = sumX / numPoints;
            c.y = sumY / numPoints;
            return c;
        } else {
            return null;
        }
    }


    function addAllTrajectories() {
        for( var floor in building.trajectoryFloorGroups ){
            if( building.trajectoryFloorGroups.hasOwnProperty( floor ) ){
                building.trajectoryFloorGroups[floor].forEach(function (traj) {
                    scene.add(traj.line);
                });
            }
        }
    }


    function removeAllBgMeshes(){
        for( var bgMesh in building.bgMeshes ){
            if( building.bgMeshes.hasOwnProperty( bgMesh ) ){
                scene.remove(building.bgMeshes[bgMesh]);
            }
        }
    }
    function deleteAllBgMeshes(){
        removeAllBgMeshes();
        building.bgMeshes = {};
    }

    function removeAllGrids(){
        for( var grid in building.grids ){
            if( building.grids.hasOwnProperty( grid ) ){
                scene.remove( building.grids[grid] );
            }
        }
    }
    function deleteAllGrids(){
        removeAllGrids();
        building.grids = {};
    }

    function removeAllTrajectories(){
        for( var floor in building.trajectoryFloorGroups ){
            if( building.trajectoryFloorGroups.hasOwnProperty( floor ) ){
                for ( var traj in building.trajectoryFloorGroups[floor] ){
                    if( building.trajectoryFloorGroups[floor].hasOwnProperty( traj ) ){
                        scene.remove( building.trajectoryFloorGroups[floor][traj].line );
                    }
                }
            }
        }
    }
    function deleteAllTrajectories(){
        removeAllTrajectories();
        building.trajectoryFloorGroups = {};
    }

    /* function removeAll(){
        removeAllBgMeshes();
        removeAllGrids();
        removeAllTrajectories();
    }*/
    function deleteAll(){
        deleteAllBgMeshes();
        deleteAllGrids();
        deleteAllTrajectories();
    }

    function changeFloors( floor, path ){
        console.log( floor );
        CAM_NEAR = ( floor + GRID_CORR_Z ) * -1 ;

        if( building.bgMeshes[floor] instanceof THREE.Mesh ){
            configCamera();
        } else {
            loadNewBgMesh( path, floor ); //also invokes loadGrid()
        }
    }
    function changeScale(){
        deleteAllBgMeshes();
        deleteAllGrids();
        loadNewBgMesh( building.path, building.floor ); //also invokes loadNewGrid();
        addAllTrajectories();
    }
    function changeLineType(){
        removeAllTrajectories();
        makeAllTrajectories();
        addAllTrajectories();
    }
    /*   function initRaycaster() {
    raycaster = new THREE.Raycaster();
    raycaster.near = -500;
    raycaster.far = 1000;
    mouse = new THREE.Vector2();

    window.addEventListener('click', onMouseClick, false ) ;
}

function onMouseClick( event ){
    mouse.x = ( event.clientX / window.innerWidth )  * 2 - 1;
    mouse.y = -( event.clientY / window.innerHeight )  * 2 + 1;

    raycaster.setFromCamera( mouse, camera );

    var bg = scene.getObjectByName('backgroundMesh');

    // calculate objects intersecting the picking ray
    var intersects = raycaster.intersectObject( bg, true ) ;

    for ( var i = 0; i < intersects.length; i++ ) {
        console.log('x:' + intersects[0].point.x + ' ' +
                    'y:' + intersects[0].point.y + ' ' +
                    'z:' + intersects[0].point.z ) ;
    }
}
*/

    function addWindowListeners() {
        window.addEventListener('resize', onWindowResize, false ) ;
    }
    function onWindowResize () {
        configCamera();
        updateRenderer();
    }

    function initRaycaster() {
        raycaster = new THREE.Raycaster();
        raycaster.near = CAM_NEAR;
        raycaster.far = CAM_FAR;
        mouse = new THREE.Vector2();

        window.addEventListener('click', onMouseClick, false ) ;
    }
    function onMouseClick( event ){
        mouse.x = ( event.clientX / window.innerWidth )  * 2 - 1;
        mouse.y = -( event.clientY / window.innerHeight )  * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        var bg = scene.getObjectByName( BG_MESH_NAME + building.floor );

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObject( bg, true ) ;

        for ( var i = 0; i < intersects.length; i++ ) {
            console.log('x:' + intersects[0].point.x + ' ' +
                'y:' + intersects[0].point.y + ' ' +
                'z:' + intersects[0].point.z ) ;
        }
    }

    function update() {
        requestAnimationFrame( update ) ;
        renderer.render( scene, camera ) ;
    }

</script>

<!--Trajectory clustering / edge bundling-->
<script>






</script>

</body>
</html>