<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>draw</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>

<!--<input id="myInput" type="file" style="visibility:hidden" />-->


<script src="js/three.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>
<script>
    //FLAG
    var INITIALIZED = false;
    var IMG_LOADED = false;

    const CAM_NEAR = -500;
    const CAM_FAR = 1000;
    const BG_Z = 0;
    const COORD_Z = 1;
    const TRAJ_Z = 2;

    /*var buildingWidth = {
        widthValue: 1,
        widthListener: function(w){},

        set value(w){
            this.widthValue = w;
            this.widthListener(w)
        },
        get value(){
            return this.widthValue;
        },
        registerWidthListener: function(listener){
            this.widthListener = listener;
        }
    };

    var buildingHeight = {
        heightValue: 1,
        heightListener: function(w){},

        set value(w){
            this.heightValue = w;
            this.heightListener(w)
        },
        get value(){
            return this.heightValue;
        },
        registerHeightListener: function(listener){
            this.heightListener = listener;
        }
    };

    buildingWidth.registerWidthListener( function(w) {
        updateCamera();
        updateRenderer();
    });
    buildingHeight.registerHeightListener( function(w) {
        updateCamera();
        updateRenderer();
    });*/

    //three.js
    var camera, scene, renderer;
    var camerahelper;
    var mouse, raycaster;

    var coordLines;
    var trajectoryFloorGroups = {};

    //dat.gui
    var gui;

    //daten des dargestellten gebäudes
    var building = {
        w: window.innerWidth,
        h: window.innerHeight,
        ratio: this.w / this.h,
        wListener: function(w){},
        hListener:function(h){},

        get width(){
            return this.w;
        },
        get height(){
            return this.h;
        },
        set width(val){
            this.w = val;
            this.wListener(val)
        },
        set height(val){
            this.h = val;
            this.hListener(val);
        },
        registerWListener: function(listener){
            this.hListener = listener;
        },
        registerHListener: function(listener){
            this.wListener = listener;
        },

        f: 0,
        fListener: function(f){},
        get floor(){
            return this.f;
        },
        set floor(val){
            if(val != this.f) {
                this.f = val;
                this.fListener(val);
            }
        },
        registerFListener: function(listener){
            this.fListener = listener;
        },

        s: 100,
        sListener: function(f){},
        get scale(){
            return this.s;
        },
        get scaleFraction(){
            return (1/this.s);
        },
        set scale(val){
            if(val != this.s){
                this.s = val;
                this.sListener(val);
            }
        },
        registerSListener: function(listener){
            this.sListener = listener;
        },

        filePath: 'indoors-office-',
        fileExt: '.png',
        get path(){
            return this.filePath + this.f + this.fileExt;
        }
    };
    building.registerWListener( function(val){
        this.ratio = this.w / this.h;
        updateCamera();
        updateRenderer();
    });
    building.registerHListener( function(val){
        this.ratio = this.w / this.h;
        updateCamera();
        updateRenderer();
    });
    building.registerFListener( function(val){
        changeFloors();
    });
    building.registerSListener( function(val){
        changeScale();
    });

    var Trajectory = function(){
        this.color = 0xff0000;
        this.did = '';
        this.floor = 0;
        this.points = [];
        this.type = 'Line';
        this.typeController;
        this.line;
        this.visible = false;
    };

    scene = new THREE.Scene();
    camera = new THREE.OrthographicCamera(0,0,0,0,0,0,0);

    initRenderer();
    configCamera();
    //initRaycaster();

    initDatGUI();

    initBackgroundFileInput();
    initDataFileInput();

    addWindowListeners();

    update();

    function initRenderer(){
        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setClearColor(0xffffff, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        updateRenderer();
    }
    function updateRenderer(){
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function configCamera(){

        var windowRatio = window.innerWidth / window.innerHeight;

        /*if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(buildingWidth / -2, buildingWidth / 2,
                (buildingWidth / 2) / ratio, (buildingWidth / -2) / ratio, 0, 1000);
        } else {
            camera = new THREE.OrthographicCamera((buildingHeight / -2) * ratio, (buildingHeight / 2) * ratio,
                (buildingHeight / 2), (buildingHeight / -2), 0, 1000);
        }*/

        if((window.innerWidth / window.innerHeight) < building.ratio){
            camera = new THREE.OrthographicCamera(0, building.width,
                 0, -building.width / windowRatio, CAM_NEAR, CAM_FAR);
        } else {
            camera = new THREE.OrthographicCamera(0, building.height * windowRatio,
                0, -building.height, CAM_NEAR, CAM_FAR);
        }

        camera.updateProjectionMatrix();
    }
    function updateCamera(){

        var windowRatio = window.innerWidth / window.innerHeight;

        /*if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(buildingWidth / -2, buildingWidth / 2,
                (buildingWidth / 2) / ratio, (buildingWidth / -2) / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera((buildingHeight / -2) * ratio, (buildingHeight / 2) * ratio,
                (buildingHeight / 2), (buildingHeight / -2), -500, 1000);
        }*/

        if((window.innerWidth / window.innerHeight) < building.ratio){
            camera = new THREE.OrthographicCamera(0, building.width,
                0, -building.width / windowRatio, CAM_NEAR, CAM_FAR);
        } else {
            camera = new THREE.OrthographicCamera(0, building.height * windowRatio,
                0, -building.height, CAM_NEAR, CAM_FAR);
        }

        camera.updateProjectionMatrix();

        /*if(camerahelper != null){
            camerahelper.update();
        }*/
    }

    function initDatGUI(){
        gui = new dat.GUI();
        gui.add(building, 'floor',-3,3).step(1).name('Floor');
        gui.add(building, 'scale',100,400).step(100).name('Scale (1/X)');
    }

    function initBackgroundFileInput(){
        var buildingFileInput = document.createElement('input');
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        buildingFileInput.style.top = "0px";
        buildingFileInput.style.width = "0px";
        buildingFileInput.style.height = "0px";
        document.body.appendChild(buildingFileInput);

        buildingFileInput.addEventListener( 'change', function( e ) {

            var file = buildingFileInput.files[0];
            var fileName = buildingFileInput.files[0].name;
            var fileType = /image.*/;

            if (file.type.match(fileType)) {

                building.filePath = fileName.slice(0,-5);
                building.fileExt = fileName.slice(-4,fileName.length);
                loadBgImg(building.path);
                trajectoryFloorGroups = {};

            } else {
                alert("File not supported");
            }
        });

        var buildingFile = {
            loadBuildingFile: function() {
                document.getElementById("buildingFileInput").click();
            }
        };
        gui.add(buildingFile, 'loadBuildingFile').name('Load Building file');
    }
    function initDataFileInput(){
        var dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        dataFileInput.style.top = "0px";
        dataFileInput.style.width = "0px";
        dataFileInput.style.height = "0px";
        document.body.appendChild(dataFileInput);

        dataFileInput.addEventListener( 'change', function( e ) {

            var file = dataFileInput.files[0];
            var fileType = /text.*/;

            if (file.type.match(fileType)) {
                var reader = new FileReader();
                reader.onload = function ( e ) {
                    //alert(reader.result);
                    loadTrajectories(reader.result);
                };
                reader.readAsText(file);
            } else {
                alert("File not supported");
            }
            this.value = null; //remove filename from input
        });

        var trajectoryFile = {
            loadDataFile : function() {
                document.getElementById("dataFileInput").click();
            }
        };
        gui.add(trajectoryFile, 'loadDataFile').name('Load Trajectory file');
    }

    function loadBgImg( buildingName ){

        var buildingPath = 'img/' + buildingName;

        scene.remove(scene.getObjectByName('backgroundMesh'));

        //DISPOSING OF REMOVED MESH OBJECTS
       /* var hi = scene.getObjectByName('backgroundMesh');
        if(scene.getObjectByName('backgroundMesh') instanceof THREE.Mesh){
            deleteObject(scene.getObjectByName('backgroundMesh'));
        }*/
        //----------------------------------

        removeAllTrajectories();

        var backgroundMesh;

        var bgMaterial = new THREE.MeshBasicMaterial();

        var bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            function ( texture ) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //pixel in meter umrechnen
                building.width = texture.image.naturalWidth * building.scaleFraction;
                building.height = texture.image.naturalHeight * building.scaleFraction;

                //create bgPlane
                var backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push(new THREE.Vector3(0, 0, BG_Z));
                backgroundPlane.vertices.push(new THREE.Vector3(0, -building.height, BG_Z));
                backgroundPlane.vertices.push(new THREE.Vector3(building.width, -building.height, BG_Z));
                backgroundPlane.vertices.push(new THREE.Vector3(building.width, 0, BG_Z));

                backgroundPlane.faces.push(new THREE.Face3(0,1,3));
                backgroundPlane.faces.push(new THREE.Face3(1,2,3));
                //backgroundPlane.computeFaceNormals();

                backgroundPlane.faceVertexUvs[0] = [];

                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0,1),
                    new THREE.Vector2(0,0),
                    new THREE.Vector2(1,1)
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0,0),
                    new THREE.Vector2(1,0),
                    new THREE.Vector2(1,1)
                ]);

                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );
                backgroundMesh.name = 'backgroundMesh';
                scene.add(backgroundMesh);

                loadGrid();
            },
            function () {},
            function () {
                console.log('BG-loading failed');
            }
        );
    }
    function loadGrid(){

        scene.remove(coordLines);

        var coordGeometry = new THREE.Geometry();

        //x-axis
        for (i = 0; i < (building.height); i++) {
            coordGeometry.vertices.push(new THREE.Vector3(0, -i, COORD_Z));
            coordGeometry.vertices.push(new THREE.Vector3(building.width, -i, COORD_Z));
        }
        //y-axis
        for (i = 0; i < (building.width); i++) {
            coordGeometry.vertices.push(new THREE.Vector3(i, 0, COORD_Z));
            coordGeometry.vertices.push(new THREE.Vector3(i, -building.height, COORD_Z));
        }

        var coordMaterial = new THREE.LineBasicMaterial({color: 0x555555, opacity: 1, linewidth: 1});
        coordLines = new THREE.LineSegments(coordGeometry, coordMaterial);

        /*  updateCamera();
         updateRenderer();*/

        scene.add(coordLines);
    }

    //SHOULD remove mesh objects, geoms, mats and textures
    function deleteObject(sceneObject){

        scene.remove(sceneObject);

        sceneObject.geometry.dispose();
        sceneObject.material.map.dispose();
        sceneObject.material.dispose();
    }

//

    function loadTrajectories ( readerResult ) {

        /*var pointList = importCSV(readerResult);
        var corredPointList = corrPoints(pointList);
        var corredPointListByFloor = groupPointsByFloor(corredPointList);*/

        var corredPointListByFloor = groupPointsByFloor(corrPoints(importCSV(readerResult)));
        var corredPointListByFloorByDid = {};

        for (var key in corredPointListByFloor) {
            if (corredPointListByFloor.hasOwnProperty(key)) {
                corredPointListByFloorByDid[key] = groupPointListByDid(corredPointListByFloor[key]);
            }
        }

        for (var floor in corredPointListByFloorByDid) {
            if (corredPointListByFloorByDid.hasOwnProperty(floor)) {
                var trajectoryFloorGroup = [];

                for (var pointGroup in corredPointListByFloorByDid[floor]) {
                    if (corredPointListByFloorByDid[floor].hasOwnProperty(pointGroup)) {
                        var tempTrajectory = new Trajectory();
                        tempTrajectory.did = pointGroup;
                        tempTrajectory.floor = corredPointListByFloorByDid[floor][pointGroup][0].f;
                        tempTrajectory.points = corredPointListByFloorByDid[floor][pointGroup];
                        trajectoryFloorGroup.push(tempTrajectory);
                    }
                }
                trajectoryFloorGroups[tempTrajectory.floor] = trajectoryFloorGroup;
            }
        }

        for(var f in trajectoryFloorGroups) {
            trajectoryFloorGroups[f].forEach(function (trajectory) {

                drawTrajectory(makeTrajectory(trajectory));
            });
        }
    }

    function changeFloors() {
        console.log(building.floor);
        loadBgImg(building.path);
        drawAllTrajectories();
    }
    function changeScale(){
        console.log(building.s);
        loadBgImg(building.path);
        drawAllTrajectories();
    }

    function importCSV ( csvString ) {

        var pointsList = Papa.parse(csvString , {
            header: true,
            dynamicTyping: true
        });
        //console.log(results);

        /*var pointList = [];
         results.data.forEach(function ( o ){
         pointList.push( o );
         })*/

        //not implemented yet

        /*var pointList = [
         {x: 0, y: 500, t: 0, f: 1, id: "10"},
         {x: 10, y: 490, t: 10, f: 1, id: "10"},
         {x: 20, y: 500, t: 20, f: 1, id: "10"},
         {x: 30, y: 470, t: 30, f: 1, id: "10"},
         {x: 40, y: 460, t: 40, f: 1, id: "20"},
         {x: 50, y: 450, t: 50, f: 1, id: "20"},
         {x: 60, y: 440, t: 60, f: 1, id: "30"},
         {x: 70, y: 430, t: 70, f: 1, id: "30"},
         {x: 80, y: 420, t: 80, f: 1, id: "30"},
         {x: 90, y: 410, t: 90, f: 1, id: "30"},
         {x: 100, y: 400, t: 100, f: 1, id: "40"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "40"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"}
         ];*/

        return pointsList.data; // = array of objects
    }

    function corrPoints( pointList ){
        pointList.forEach(
            function ( point ) {
                //point.x = point.x; //scale;
                point.y = point.y * -1; //scale;
            }
        );
        return pointList;
    }

    function groupPointsByFloor( pointList ){
        var pointListByFloor = groupBy(
            pointList,
            function(item) {
                return [item.f]; //, item.t
            }
        );
        return pointListByFloor;
    }

    function groupPointListByDid ( pointList ) {

        var pointListByID = groupBy(
            pointList,
            function(item) {
                return [item.did]; //, item.t
            }
        );
        return pointListByID;
    }

    function groupBy( array , f ) {

        var groups = {};
        array.forEach(
            function( object ) {
                var group = JSON.stringify( f( object ) );
                groups[group] = groups[group] || [];
                groups[group].push( object );
            }
        );
        return groups;

        /*return Object.keys(groups).map(
            function( group ) {
                return groups[group];
            }
        )*/
    }

    function makeLineGeom ( points ){

        var vertices = [];
        points.forEach(
            function ( point ){
                vertices.push( new THREE.Vector3(point.x, point.y, TRAJ_Z));
            }
        );

        var lineGeom = new THREE.Geometry();
        lineGeom.name = points[0].did;
        lineGeom.vertices = vertices;

        return lineGeom;
    }

    function makeCurveGeom ( points ){

        var vertices = [];
        points.forEach(
            function ( point ){
                vertices.push( new THREE.Vector3(point.x, point.y, TRAJ_Z));
            }
        );
        var curve = new THREE.CatmullRomCurve3( vertices );
        var curveGeom = new THREE.Geometry();
        curveGeom.name = points[0].did;
        curveGeom.vertices = curve.getPoints( 50 );

        return curveGeom;
    }

    function makeTrajectory(traj){
        var tempTraj;

        if(traj.type == 'Line'){
            tempTraj = makeLineGeom(traj.points);
        } else if (traj.type == 'Curve'){
            tempTraj = makeCurveGeom(traj.points);
        }

        var trajectoryMaterial = new THREE.LineBasicMaterial( { color: traj.color, opacity: 1 } );
        traj.line = new THREE.Line(tempTraj, trajectoryMaterial);

        return traj;
    }

    function drawAllTrajectories(){
        for(var floor in trajectoryFloorGroups) {
            trajectoryFloorGroups[floor].forEach(function (traj) {

                drawTrajectory(traj);
            });
        }
    }
    function drawTrajectory(traj){

        if(traj.floor == building.f){

            traj.typeController = gui.add(traj, 'type', ['Line', 'Curve']).name(traj.did);

            traj.typeController.onChange(function () {
                removeTrajectory(traj);
                drawTrajectory(makeTrajectory(traj));
            });

            scene.add(traj.line);
            traj.visible = true;
        }
        // da könnte man die farbe / den dateinamen / etc. verwenden ---
    }

    function removeAllTrajectories(){
        for(var floor in trajectoryFloorGroups){
            trajectoryFloorGroups[floor].forEach( function (traj) {

                removeTrajectory(traj);
            });
        }
    }
    function removeTrajectory(traj) {
        if(traj.visible) {
            scene.remove(traj.line);
            gui.remove(traj.typeController);
            traj.visible = false;
        }
    }

    //erweitern um zwischen einzelnen trajectoryGroups nach der Zeit zu unterscheiden
    //filter DIDs with only one point -- not working, groups is an object, not list
    /*var filteredGroups = [];
     groups.forEach(function ( group ) {
     if (group.size > 1) {
     filteredGroups.push(group);
     }
     });*/
    //

    function initRaycaster(){
        raycaster = new THREE.Raycaster();
        raycaster.near = -500;
        raycaster.far = 1000;
        mouse = new THREE.Vector2();

        window.addEventListener('click', onMouseClick, false);
    }

    function onMouseClick( event ){
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        var bg = scene.getObjectByName('backgroundMesh');

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObject(bg, true);

        for ( var i = 0; i < intersects.length; i++ ) {
            console.log('x:' + intersects[0].point.x + ' ' +
                        'y:' + intersects[0].point.y + ' ' +
                        'z:' + intersects[0].point.z);
        }
    }

    function addWindowListeners(){
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize (){
        configCamera();
        updateRenderer();
    }

    function update (){

        /*if((!INITIALIZED) && IMG_LOADED){
            initialize();
        }*/

        requestAnimationFrame(update);

        renderer.render(scene, camera);
    }

</script>
</body>
</html>