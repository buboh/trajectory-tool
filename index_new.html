<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>draw</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>

<!--<input id="myInput" type="file" style="visibility:hidden" />-->


<script src="js/three.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script>
    //FLAG
    var INITIALIZED = false;
    var IMG_LOADED = false;

    //Set scene size
    var WINDOW_WIDTH = window.innerWidth;
    var WINDOW_HEIGHT = window.innerHeight;

    // 1 Meter in Realität ist <10> Pixel auf einem Bild
    //meter/pixel
    var scale = 1/100;

    //traj-ebene
    var TRAJ_Z = 0;

    //in metern  // WINDOW_ nur zum Testen
    var buildingWidth;
    var buildingHeight;
    var buildingRatio = WINDOW_WIDTH / WINDOW_HEIGHT;

    //Background image
    var backgroundMesh;



    //three.js
    var camera, scene, renderer;
    var camerahelper;

    //loadedPoints
    //var pointListById;

    var Trajectory = function(){
        this.color = 0xff0000;
        this.did = '';
        this.points = [];
        this.type = 'Line';
        this.typeController;

        this.line;
    };

    //dat.gui
    var gui;

    var trajectoryGroups = [];

    scene = new THREE.Scene();
    camera = new THREE.OrthographicCamera(0,0,0,0,0,0,0);

    initRenderer();

    initBgImg();

    initDatGUI();

    fileIn();

    update();


    function initialize(){

        initCamera();

        initGrid();

        //help
        //camerahelper = new THREE.CameraHelper( camera );
        //scene.add(camerahelper);

        addWindowListeners();

        INITIALIZED = true;
    }

    function initBgImg(){
        var bgMaterial = new THREE.MeshBasicMaterial();

        var bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            'img/indoors-office.png',
            function ( texture ) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                var bgImgWidth = texture.image.naturalWidth;
                var bgImgHeight = texture.image.naturalHeight;

                buildingWidth = bgImgWidth * scale;
                buildingHeight = bgImgHeight * scale;
                buildingRatio = buildingWidth / buildingHeight;

                IMG_LOADED = true;

                //create bgPlane
                var backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push(new THREE.Vector3(0, 0, -2));
                backgroundPlane.vertices.push(new THREE.Vector3(0, -buildingHeight, -2));
                backgroundPlane.vertices.push(new THREE.Vector3(buildingWidth, -buildingHeight, -2));
                backgroundPlane.vertices.push(new THREE.Vector3(buildingWidth, 0, -2));

                backgroundPlane.faces.push(new THREE.Face3(0,1,3));
                backgroundPlane.faces.push(new THREE.Face3(1,2,3));
                backgroundPlane.computeFaceNormals();

                backgroundPlane.faceVertexUvs[0] = [];

                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0,1),
                    new THREE.Vector2(0,0),
                    new THREE.Vector2(1,1)
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0,0),
                    new THREE.Vector2(1,0),
                    new THREE.Vector2(1,1)
                ]);

                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    //new THREE.PlaneGeometry(WINDOW_WIDTH, WINDOW_WIDTH / buildingRatio),

                    backgroundPlane,
                    bgMaterial

                );

                //backgroundMesh.translateY((WINDOW_HEIGHT/2) - );
                scene.add(backgroundMesh);
            },
            function () {},
            function () {
                console.log('bg-loading failed');
            }
        );
     }

    function initGrid(){

        var coordGeometry = new THREE.Geometry();

        //x-axis
        for (i = 0; i < (buildingHeight); i++) {
            coordGeometry.vertices.push(new THREE.Vector3(0, -i, -1));
            coordGeometry.vertices.push(new THREE.Vector3(buildingWidth, -i, -1));
        }
        //y-axis
        for (i = 0; i < (buildingWidth); i++) {
            coordGeometry.vertices.push(new THREE.Vector3(i, 0, -1));
            coordGeometry.vertices.push(new THREE.Vector3(i, -buildingHeight, -1));
        }

        var coordMaterial = new THREE.LineBasicMaterial({color: 0x555555, opacity: 1, linewidth: 1});
        var coordLines = new THREE.LineSegments(coordGeometry, coordMaterial);

        scene.add(coordLines);
    }

    function initCamera(){

        var ratio = WINDOW_WIDTH / WINDOW_HEIGHT;

        if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(buildingWidth / -2, buildingWidth / 2,
                (buildingWidth / 2) / ratio, (buildingWidth / -2) / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera((buildingHeight / -2) * ratio, (buildingHeight / 2) * ratio,
                (buildingHeight / 2), (buildingHeight / -2), -500, 1000);
        }

        if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(0, buildingWidth,
                 0, -buildingWidth / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera(0, buildingHeight * ratio,
                0, -buildingHeight, -500, 1000);
        }

        camera.updateProjectionMatrix();

    }
    function updateCamera(){

        var ratio = WINDOW_WIDTH / WINDOW_HEIGHT;

        if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(buildingWidth / -2, buildingWidth / 2,
                (buildingWidth / 2) / ratio, (buildingWidth / -2) / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera((buildingHeight / -2) * ratio, (buildingHeight / 2) * ratio,
                (buildingHeight / 2), (buildingHeight / -2), -500, 1000);
        }

        if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(0, buildingWidth,
                0, -buildingWidth / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera(0, buildingHeight * ratio,
                0, -buildingHeight, -500, 1000);
        }

        camera.updateProjectionMatrix();

        /*if(camerahelper != null){
            camerahelper.update();
        }*/
    }

    function initRenderer(){
        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setClearColor(0xffffff, 0);
        renderer.setPixelRatio(window.devicePixelRatio);

        /*if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            renderer.setSize(WINDOW_WIDTH, WINDOW_WIDTH * buildingRatio);
        } else {
            renderer.setSize(WINDOW_HEIGHT / buildingRatio, WINDOW_HEIGHT);
        }*/

        renderer.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
        document.body.appendChild(renderer.domElement);
    }
    function updateRenderer(){

        /*if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            renderer.setSize(WINDOW_WIDTH, WINDOW_WIDTH * buildingRatio);
        } else {
            renderer.setSize(WINDOW_HEIGHT / buildingRatio, WINDOW_HEIGHT);
        }*/

        renderer.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

    }

    function initDatGUI(){
        gui = new dat.GUI();
        //gui.add(coordSys, )
        //remove all trajectoryGroups
        //change line type on the fly
    }

    function fileIn(){
        var fileInput = document.createElement( 'input' );
        fileInput.id = "fileInput";
        fileInput.type = "file";
        fileInput.style.position = "absolute";
        fileInput.style.visibility = "hidden";
        fileInput.style.top = "0px";
        fileInput.style.width = "0px";
        fileInput.style.height = "0px";
        document.body.appendChild(fileInput);

        fileInput.addEventListener( 'change', function( e ) {

            var file = fileInput.files[0];
            var textType = /text.*/;

            if (file.type.match(textType)) {
                var reader = new FileReader();
                reader.onload = function ( e ) {
                    //alert(reader.result);
                    loadTrajectories(reader.result);
                };
                reader.readAsText(file);
            } else {
                alert("File not supported");
            }
        });

        var trajectoryFile = {
            loadFile : function() {
                document.getElementById("fileInput").click();
            }
        };
        gui.add(trajectoryFile, 'loadFile').name('Load Trajectory file');
    }

    //traj
    function loadTrajectories ( readerResult ){

        var traj = new Trajectory();
        trajectoryGroups.push(traj);

        var pointList = importCSV(readerResult);
        var corredPointsList = corrPoints(pointList);
        var groupedPoints = groupPointList(corredPointsList); //object containing arrays of points
        var trajectoryGroup = [];

        //Punkte nach DID in eigene Trajectories speichern
        for(var key in groupedPoints){
            var trajectory = new Trajectory();
            trajectory.did = key;
            trajectory.points = groupedPoints[key];
            trajectoryGroup.push(trajectory);
        }

        trajectoryGroups.push(trajectoryGroup);

        //traj.pointListById = groupPointList(corredPointsList);
        trajectoryGroup.forEach(function(traj){
            drawTrajectory(traj);

            traj.typeController = gui.add(traj, 'type', ['Line', 'Curve']).name(traj.did);

            traj.typeController.onChange( function(){
                scene.remove(traj.line);
                drawTrajectory(traj);
            });
        });
    }

    function importCSV ( csvString ) {

        var pointsList = Papa.parse(csvString , {
            header: true,
            dynamicTyping: true
        });
        //console.log(results);

        /*var pointList = [];
         results.data.forEach(function ( o ){
         pointList.push( o );
         })*/

        //not implemented yet

        /*var pointList = [
         {x: 0, y: 500, t: 0, f: 1, id: "10"},
         {x: 10, y: 490, t: 10, f: 1, id: "10"},
         {x: 20, y: 500, t: 20, f: 1, id: "10"},
         {x: 30, y: 470, t: 30, f: 1, id: "10"},
         {x: 40, y: 460, t: 40, f: 1, id: "20"},
         {x: 50, y: 450, t: 50, f: 1, id: "20"},
         {x: 60, y: 440, t: 60, f: 1, id: "30"},
         {x: 70, y: 430, t: 70, f: 1, id: "30"},
         {x: 80, y: 420, t: 80, f: 1, id: "30"},
         {x: 90, y: 410, t: 90, f: 1, id: "30"},
         {x: 100, y: 400, t: 100, f: 1, id: "40"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "40"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
         {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"}
         ];*/

        return pointsList.data; // = array of objects
    }

    function corrPoints( pointsList ){
        pointsList.forEach(
            function ( point ) {
                point.x = point.x * scale;
                point.y = point.y * -scale;
            }
        );
        return pointsList;
    }

    function groupPointList ( pointList ) {

        var pointListByID = groupBy(
            pointList,
            function(item) {
                return [item.did]; //, item.t
            }
        );
        return pointListByID;
    }

    function groupBy( array , f ) {

        var groups = {};
        array.forEach(
            function( object ) {
                var group = JSON.stringify( f( object ) );
                groups[group] = groups[group] || [];
                groups[group].push( object );
            }
        );
        return groups;

        /*return Object.keys(groups).map(
            function( group ) {
                return groups[group];
            }
        )*/
    }

    function makeTrajectoryLines ( points ){

        var vertices = [];
        points.forEach(
            function ( point ){
                vertices.push( new THREE.Vector3(point.x, point.y, TRAJ_Z));
            }
        );

        var trajGeom = new THREE.Geometry();
        trajGeom.name = points[0].did;
        trajGeom.vertices = vertices;

        return trajGeom;
    }

    function makeTrajectoryCurves ( points ){

        var vertices = [];
        points.forEach(
            function ( point ){
                vertices.push( new THREE.Vector3(point.x, point.y, TRAJ_Z));
            }
        );
        var curve = new THREE.CatmullRomCurve3( vertices );
        var trajGeom = new THREE.Geometry();
        trajGeom.name = points[0].did;
        trajGeom.vertices = curve.getPoints( 50 );

        return trajGeom;
    }

    function drawTrajectory(traj){

        if(traj.type == 'Line'){
            var tempTraj = makeTrajectoryLines(traj.points);
        } else if (traj.type == 'Curve'){
            var tempTraj = makeTrajectoryCurves(traj.points);
        }

        var trajectoryMaterial = new THREE.LineBasicMaterial( { color: traj.color, opacity: 1 } );
        traj.line = new THREE.Line(tempTraj, trajectoryMaterial);

        scene.add(traj.line);


       /* traj.typeController = gui.add(traj, 'type', ['Line', 'Curve']).name(traj.did);

        traj.typeController.onChange( function(){
            scene.remove(traj.line);
            traj.line = null;
            drawTrajectory(traj);
        });*/

        // da könnte man die farbe / den dateinamen / etc. verwenden ---
    }

    //erweitern um zwischen einzelnen trajectoryGroups nach der Zeit zu unterscheiden
    //filter DIDs with only one point -- not working, groups is an object, not list
    /*var filteredGroups = [];
     groups.forEach(function ( group ) {
     if (group.size > 1) {
     filteredGroups.push(group);
     }
     });*/
    //

    function addWindowListeners(){
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize () {
        WINDOW_HEIGHT = window.innerHeight;
        WINDOW_WIDTH = window.innerWidth;

        updateCamera();
        updateRenderer();
    }

    function update () {

        if((!INITIALIZED) && IMG_LOADED){
            initialize();
        }

        requestAnimationFrame(update);

        renderer.render(scene, camera);
    }

</script>
</body>
</html>