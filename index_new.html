<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>draw</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>

<!--<input id="myInput" type="file" style="visibility:hidden" />-->


<script src="js/three.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>
<script>

//    var CAM_NEAR = 1000;
//    var CAM_FAR = -1000;
//    const BG_Z = -100;
//    const COORD_Z = -100;
//    const TRAJ_Z = 2;

    var CAM_NEAR = -100;
    var CAM_FAR = 100;
    const BG_Z = 100;
    var COORD_Z = 100;
    const TRAJ_Z = 2;

    const CUT_TIME = 0.08;

    /*var buildingWidth = {
        widthValue: 1,
        widthListener: function( w ) {},

        set value( w ) {
            this.widthValue = w;
            this.widthListener( w ) 
        },
        get value(){
            return this.widthValue;
        },
        registerWidthListener: function( listener ) {
            this.widthListener = listener;
        }
    };

    var buildingHeight = {
        heightValue: 1,
        heightListener: function( w ) {},

        set value( w ) {
            this.heightValue = w;
            this.heightListener( w ) 
        },
        get value(){
            return this.heightValue;
        },
        registerHeightListener: function( listener ) {
            this.heightListener = listener;
        }
    };

    buildingWidth.registerWidthListener( function( w )  {
        updateCamera();
        updateRenderer();
    });
    buildingHeight.registerHeightListener( function( w )  {
        updateCamera();
        updateRenderer();
    });*/

    //three.js
    var camera, scene, renderer;
    var camerahelper;
    var mouse, raycaster;

    var coordPlane, coordLines;
    var trajectoryFloorGroups = {};

    //dat.gui
    var gui;

    //daten des dargestellten geb√§udes
    var building = {
        w: window.innerWidth,
        h: window.innerHeight,
        ratio: this.w / this.h,
        wListener: function( w ) {},
        hListener:function( h ) {},

        get width(){
            return this.w;
        },
        get height(){
            return this.h;
        },
        set width( val ) {
            this.w = val;
            this.wListener( val ) 
        },
        set height( val ) {
            this.h = val;
            this.hListener( val ) ;
        },
        registerWListener: function( listener ) {
            this.hListener = listener;
        },
        registerHListener: function( listener ) {
            this.wListener = listener;
        },

        f: 0,
        fListener: function( f ) {},
        get floor(){
            return this.f;
        },
        set floor( val ) {
            if( val != this.f )  {
                this.f = val;
                this.fListener( val ) ;
            }
        },
        registerFListener: function( listener ) {
            this.fListener = listener;
        },

        s: 100,
        sListener: function( f ) {},
        get scale(){
            return this.s;
        },
        get scaleFraction(){
            return (1/this.s ) ;
        },
        set scale( val ) {
            if( val != this.s ) {
                this.s = val;
                this.sListener( val ) ;
            }
        },
        registerSListener: function( listener ) {
            this.sListener = listener;
        },

        filePath: 'indoors-office-',
        fileExt: '.png',
        get path(){
            return this.filePath + this.f + this.fileExt;
        },

        lt: 'Line',
        ltListener: function( f ) {},
        get lineType(){
            return this.lt;
        },
        set lineType( val ) {
            if( val != this.lt )  {
                this.lt = val;
                this.ltListener( val ) ;
            }
        },
        registerLtListener: function( listener ) {
            this.ltListener = listener;
        },

        backgroundMeshes: []
    };
    building.registerWListener( function( val ) {
        this.ratio = this.w / this.h;
        configCamera();
        updateRenderer();
    });
    building.registerHListener( function( val ){
        this.ratio = this.w / this.h;
        configCamera();
        updateRenderer();
    });
    building.registerFListener( function( val ){
        changeFloors();
    });
    building.registerSListener( function( val ){
        changeScale();
    });
    building.registerLtListener( function( val ){
        changeLineType();
    });

    var Trajectory = function(){
        this.color = 0xff0000;
        this.did = '';
        this.floor = 0;
        this.points = [];
        this.line;
        this.visible = false;
    };

    scene = new THREE.Scene();
    camera = new THREE.OrthographicCamera( 0,0,0,0,0,0,0 );

    initRenderer();
    configCamera();
    //initRaycaster();
//    camerahelper = new THREE.CameraHelper(camera);
//    scene.add(camerahelper);

    initDatGUI();

    initBackgroundFileInput();
    initDataFileInput();

    addWindowListeners();

    //loadGrid();

    update();

    function initRenderer(){
        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setClearColor(0xffffff, 0);
        renderer.setPixelRatio( window.devicePixelRatio ) ;
        document.body.appendChild( renderer.domElement ) ;
        updateRenderer();
    }
    function updateRenderer(){
        renderer.setSize( window.innerWidth, window.innerHeight ) ;
    }

    function configCamera(){

        var windowRatio = window.innerWidth / window.innerHeight;

        if(( window.innerWidth / window.innerHeight )  < building.ratio ) {
            camera = new THREE.OrthographicCamera(0, building.width,
                 0, -building.width / windowRatio, CAM_NEAR, CAM_FAR);
        } else {
            camera = new THREE.OrthographicCamera(0, building.height * windowRatio,
                0, -building.height, CAM_NEAR, CAM_FAR);
        }
        updateCamera();
    }
    function updateCamera(){

        camera.updateProjectionMatrix();

        /*if( camerahelper ) {
            camerahelper.update();
        }*/
    }

    function initDatGUI(){
        gui = new dat.GUI();
        gui.add( building, 'floor', -3, 3 ).step( 1 ).name( 'Floor' );
        gui.add( building, 'scale', 100, 400 ).step( 100 ).name( 'Scale (1/X)' );
        gui.add( building, 'lineType', ['Line', 'Curve']).name( 'Line type' );
        gui.add( this, 'CAM_FAR' ).step( 0.5 ).listen();
        gui.add( this, 'CAM_NEAR' ).step( 0.5 ).listen();
    }

    function initBackgroundFileInput(){
        var buildingFileInput = document.createElement('input');
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        buildingFileInput.style.top = "0px";
        buildingFileInput.style.width = "0px";
        buildingFileInput.style.height = "0px";
        document.body.appendChild( buildingFileInput );

        buildingFileInput.addEventListener( 'change', function( e ){

            var file = buildingFileInput.files[0];
            var fileName = buildingFileInput.files[0].name;
            var fileType = /image.*/;

            if ( file.type.match( fileType ) ){

                building.filePath = fileName.slice( 0, -5 );
                building.fileExt = fileName.slice( -4, fileName.length );

                //delete trajectories & bg
                //removeAllTrajectories();
                removeAllBgMeshes();
                removeAllFromScene();
                //loadBgImage( building.path );
                changeFloors();

            } else {
                alert( "File not supported" );
            }
        });

        var buildingFile = {
            loadBuildingFile: function() {
                document.getElementById( "buildingFileInput" ).click();
            }
        };
        gui.add( buildingFile, 'loadBuildingFile' ).name( 'Load Building file' );
    }
    function initDataFileInput(){
        var dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        dataFileInput.style.top = "0px";
        dataFileInput.style.width = "0px";
        dataFileInput.style.height = "0px";
        document.body.appendChild( dataFileInput ) ;

        dataFileInput.addEventListener( 'change', function( e ) {

            var file = dataFileInput.files[0];
            var fileType = /text.*/;

            if ( file.type.match( fileType ) ) {
                var reader = new FileReader();
                reader.onload = function ( e ) {
                    //alert( reader.result ) ;
                    loadTrajectories( reader.result ) ;
                };
                reader.readAsText( file ) ;
            } else {
                alert("File not supported");
            }
            this.value = null; //remove filename from input
        });

        var trajectoryFile = {
            loadDataFile : function() {
                document.getElementById("dataFileInput").click();
            }
        };
        gui.add( trajectoryFile, 'loadDataFile').name('Load Trajectory file');
    }

    function loadBgImage( buildingName ){

        var buildingPath = 'img/' + buildingName;

        //scene.remove( scene.getObjectByName('backgroundMesh'));

        //DISPOSING OF REMOVED MESH OBJECTS
       /* var hi = scene.getObjectByName('backgroundMesh');
        if( scene.getObjectByName('backgroundMesh') instanceof THREE.Mesh ) {
            deleteObject( scene.getObjectByName('backgroundMesh'));
        }*/
        //----------------------------------

        var backgroundMesh;

        var bgMaterial = new THREE.MeshBasicMaterial();

        var bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            function ( texture ) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //pixel in meter umrechnen
                building.width = texture.image.naturalWidth * building.scaleFraction;
                building.height = texture.image.naturalHeight * building.scaleFraction;

                //create bgPlane
                var backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push( new THREE.Vector3( 0, 0, building.floor - 0.5 ));
                backgroundPlane.vertices.push( new THREE.Vector3( 0, -building.height, building.floor - 0.5 ));
                backgroundPlane.vertices.push( new THREE.Vector3( building.width, -building.height, building.floor - 0.5 ));
                backgroundPlane.vertices.push( new THREE.Vector3( building.width, 0, building.floor - 0.5 ));

                backgroundPlane.faces.push( new THREE.Face3( 0,1,3 ));
                backgroundPlane.faces.push( new THREE.Face3( 1,2,3 ));
                //backgroundPlane.computeFaceNormals();

                backgroundPlane.faceVertexUvs[0] = [];

                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2( 0,1 ),
                    new THREE.Vector2( 0,0 ),
                    new THREE.Vector2( 1,1 )
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2( 0,0 ),
                    new THREE.Vector2( 1,0 ),
                    new THREE.Vector2( 1,1 )
                ]);

                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );
                backgroundMesh.name = 'backgroundMesh-' + building.floor;

                building.backgroundMeshes[building.floor] = backgroundMesh;

                scene.add( building.backgroundMeshes[building.floor] );

                loadGrid();
            },
            function (){},
            function (){
                console.log( 'BG-loading failed' );
            }
        );
    }

    function removeAllBgMeshes(){
        for( var bgMesh in building.backgroundMeshes ){
            removeBgMesh( building.backgroundMeshes[bgMesh] );
        }
        building.backgroundMeshes = {};
    }
    function removeBgMesh( bgMesh ){
        scene.remove( bgMesh );
    }
    function removeAllFromScene(){
        scene.children.forEach( function( obj ){

            scene.remove( obj );
        });
        building.backgroundMeshes = {};
    }

    function loadGrid(){

        scene.remove( coordLines ) ;

        var coordGeometry = new THREE.Geometry();

        //x-axis
        for( i = 0; i < ( building.height ); i++){
            coordGeometry.vertices.push( new THREE.Vector3( 0, -i, COORD_Z ));
            coordGeometry.vertices.push( new THREE.Vector3( building.width, -i, COORD_Z ));
        }
        //y-axis
        for( i = 0; i < ( building.width ); i++){
            coordGeometry.vertices.push( new THREE.Vector3( i, 0, COORD_Z));
            coordGeometry.vertices.push( new THREE.Vector3( i, -building.height, COORD_Z ));
        }

        var coordMaterial = new THREE.LineBasicMaterial({ color: 0x555555, opacity: 1, linewidth: 1 });
        coordLines = new THREE.LineSegments( coordGeometry, coordMaterial );

        scene.add( coordLines );
    }

    //SHOULD remove mesh objects, geoms, mats and textures
    function deleteObject( sceneObject ) {

        scene.remove( sceneObject ) ;

        sceneObject.geometry.dispose();
        sceneObject.material.map.dispose();
        sceneObject.material.dispose();
    }

//

    function sortPoints( pointList ) {

        pointList.sort(
            firstBy("did")
            .thenBy("f")
            .thenBy("t")
        );

        return pointList;
    }

    function loadTrajectories ( readerResult ) {

        var pointList = parseCSV( readerResult ) ;
        /*var corredPointList = corrPoints( pointList ) ;
        var corredPointListByFloor = groupPointListByFloor( corredPointList ) ;*/

        pointList = sortPoints( pointList ) ;

        var corredPointListByDID = groupPointListByDid( corrPoints( pointList ) );
        var corredPointListByDIDByFloor = [];

        for ( var did in corredPointListByDID){
            if ( corredPointListByDID.hasOwnProperty( did ) ){
                corredPointListByDIDByFloor[did] = groupPointListByFloor( corredPointListByDID[did]);
            }
        }

        var corredPointListByDIDByFloorByTime = [];

        for ( var did in corredPointListByDIDByFloor ) {

            var tempList = [];

            for ( var floor in corredPointListByDIDByFloor[did]){
                if ( corredPointListByDIDByFloor[did].hasOwnProperty( floor ) ) {

                    tempList[floor] = groupPointListByTime(corredPointListByDIDByFloor[did][floor])
                }
            }
            corredPointListByDIDByFloorByTime[did] = tempList;
        }

        for( var did in corredPointListByDIDByFloorByTime ) {
            for( var floor in corredPointListByDIDByFloorByTime[did] ){
                for( var pointGroup in corredPointListByDIDByFloorByTime[did][floor]){

                    var tempTrajectory = new Trajectory();
                    tempTrajectory.did = did;
                    tempTrajectory.floor = corredPointListByDIDByFloorByTime[did][floor][pointGroup][0].f;
                    tempTrajectory.points = corredPointListByDIDByFloorByTime[did][floor][pointGroup];

                    if( !trajectoryFloorGroups[tempTrajectory.floor] ) {
                        trajectoryFloorGroups[tempTrajectory.floor] = [];
                    }
                    if( tempTrajectory.points.length > 1) {
                        trajectoryFloorGroups[tempTrajectory.floor].push(tempTrajectory);
                    }
                }
            }
        }

        /*for ( var floor in corredPointListByDIDByFloor ) {
            if ( corredPointListByDIDByFloor.hasOwnProperty( floor ) ){
                var trajectoryFloorGroup = [];

                for ( var pointGroup in corredPointListByDIDByFloor[floor]){
                    if ( corredPointListByDIDByFloor[floor].hasOwnProperty( pointGroup ) ){
                        var tempTrajectory = new Trajectory();
                        tempTrajectory.did = pointGroup;
                        tempTrajectory.floor = corredPointListByDIDByFloor[floor][pointGroup][0].f;
                        tempTrajectory.points = corredPointListByDIDByFloor[floor][pointGroup];
                        trajectoryFloorGroup.push( tempTrajectory ) ;
                    }
                }
                trajectoryFloorGroups[tempTrajectory.floor] = trajectoryFloorGroup;
            }
        }*/

        makeAllTrajectories();
        drawAllTrajectories();
    }

    function changeFloors(){
        console.log( building.floor );
        CAM_NEAR = (building.floor) * -1 ;
        COORD_Z = building.floor;

        if( building.backgroundMeshes[building.floor] != THREE.Mesh ){
            loadGrid();
            loadBgImage( building.path );
            drawAllTrajectories();
        } else {
            configCamera();
        }
    }
    function changeScale(){
        console.log( building.scale );
        removeBgMesh();
        loadBgImage( building.path );
        drawAllTrajectories();
    }
    function changeLineType(){
        console.log( building.lineType );
        removeAllTrajectories();
        makeAllTrajectories();
        drawAllTrajectories();
    }

    function parseCSV ( csvString ) {

        var pointsList = Papa.parse( csvString , {
            header: true,
            dynamicTyping: true
        });
        return pointsList.data; // = array of objects
    }

    function corrPoints ( pointList ) {
        pointList.forEach(
            function ( point ) {
                point.y = point.y * -1;
            }
        );
        return pointList;
    }

    function groupPointListByFloor( pointList )  {
        var pointListByFloor = groupBy(
            pointList,
            function( item )  {
                return [item.f]; //, item.t
            }
        );
        return pointListByFloor;
    }

    function groupPointListByDid( pointList )  {
        var pointListByDID = groupBy(
            pointList,
            function( item )  {
                return [item.did]; //, item.t
            }
        );
        return pointListByDID;
    }

    function groupPointListByTime( pointList )  {

        var pointListByTime = [];

        var tempTime = pointList[0].t;
        var tempTimeArray = [];


        pointList.forEach(function( point ){

            if( tempTime + CUT_TIME < point.t ) {

                pointListByTime.push( tempTimeArray ) ;
                tempTimeArray = [];
                tempTimeArray.push( point );
                tempTime = point.t;

            } else {

                tempTimeArray.push( point );
                tempTime = point.t;

            }
        });
        pointListByTime.push(tempTimeArray);

        /* var pointListByTime = groupBy(
            pointList,
            function( item )  {
                return [item.did]; //, item.t
            }
        );*/
        return pointListByTime;
    }

    function groupBy( array , f ) {

        var groups = {};
        array.forEach(
            function( object ) {
                var group = JSON.stringify( f( object ) );
                groups[group] = groups[group] || []; //if groups[group] doesn't exist, [] is assigned
                groups[group].push( object );
            }
        );
        return groups;

        /*return Object.keys( groups ) .map(
            function( group ) {
                return groups[group];
            }
        )*/
    }

    function makeAllTrajectories(){
        for( var floor in trajectoryFloorGroups )  {
            trajectoryFloorGroups[floor].forEach( function ( traj )  {

                makeTrajectory( traj ) ;
            });
        }
    }
    function makeTrajectory( traj )  {
        var tempTraj;

        if( building.lineType == 'Line' ){
            tempTraj = makeLineGeom( traj.points ) ;
        } else if ( building.lineType == 'Curve' ){
            tempTraj = makeCurveGeom( traj.points ) ;
        }

        var trajectoryMaterial = new THREE.LineBasicMaterial( { color: traj.color, opacity: 1 } );
        traj.line = new THREE.Line( tempTraj, trajectoryMaterial ) ;
    }
    function makeLineGeom( points ) {

        var vertices = [];
        points.forEach(
            function ( point ) {
                vertices.push( new THREE.Vector3( point.x, point.y, point.f ));
            }
        );

        var lineGeom = new THREE.Geometry();
        lineGeom.name = points[0].did;
        lineGeom.vertices = vertices;

        return lineGeom;
    }
    function makeCurveGeom( points ) {

        var vertices = [];
        points.forEach(
            function( point ) {
                vertices.push( new THREE.Vector3( point.x, point.y, point.f ));
            }
        );
        var curve = new THREE.CatmullRomCurve3( vertices );
        var curveGeom = new THREE.Geometry();
        curveGeom.name = points[0].did;
        curveGeom.vertices = curve.getPoints( 50 );

        return curveGeom;
    }

    function drawAllTrajectories() {
        for( var floor in trajectoryFloorGroups )  {
            trajectoryFloorGroups[floor].forEach( function ( traj ){

                drawTrajectory( traj ) ;
            });
        }
    }
    function drawTrajectory( traj )  {

        scene.add( traj.line );

        /*if( traj.floor == building.floor ){
            scene.add( traj.line ) ;
            traj.visible = true;
        }*/
    }

    function removeAllTrajectories() {
        for( var floor in trajectoryFloorGroups )  {
            trajectoryFloorGroups[floor].forEach( function( traj )  {

                removeTrajectory( traj ) ;
            });
        }
    }
    function removeTrajectory( traj )  {

        scene.remove( traj.line );

        /*if( traj.visible )  {
            scene.remove( traj.line ) ;
            traj.visible = false;
        }*/
    }

    function initRaycaster() {
        raycaster = new THREE.Raycaster();
        raycaster.near = -500;
        raycaster.far = 1000;
        mouse = new THREE.Vector2();

        window.addEventListener('click', onMouseClick, false ) ;
    }

    function onMouseClick( event ) {
        mouse.x = ( event.clientX / window.innerWidth )  * 2 - 1;
        mouse.y = -( event.clientY / window.innerHeight )  * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        var bg = scene.getObjectByName('backgroundMesh');

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObject( bg, true ) ;

        for ( var i = 0; i < intersects.length; i++ ) {
            console.log('x:' + intersects[0].point.x + ' ' +
                        'y:' + intersects[0].point.y + ' ' +
                        'z:' + intersects[0].point.z ) ;
        }
    }

    function addWindowListeners() {
        window.addEventListener('resize', onWindowResize, false ) ;
    }

    function onWindowResize () {
        configCamera();
        updateRenderer();
    }

    function update() {

        //configCamera();
        //console.log(camera.far);
        requestAnimationFrame( update ) ;

        renderer.render( scene, camera ) ;
    }

</script>
</body>
</html>