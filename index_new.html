<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>draw</title>
    <style>
        body { margin: 0; overflow: hidden }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>
<script>

    var CAM_NEAR = -100;
    var CAM_FAR = 100;

    const GUI_FLOORMIN = -3;
    const GUI_FLOORMAX = 3;
    const GUI_FLOORSTEP = 1;
    const GUI_SCALEMIN = 50;
    const GUI_SCALEMAX = 200;
    const GUI_SCALESTEP = 50;

    const INIT_FLOOR = 0;
    const INIT_SCALE = 50;
    const INIT_FILEPATH = 'LUCI-neu-';
    const INIT_EXT = '.png';
    const INIT_LINETYPE = 'Line';

    const TRAJ_COLOR = 0xFF0000;
    const TRAJ_CUT_TIME = 8000; // 8 s in ms
    //const TRAJ_CUT_TIME = 0.08; //s

    const BG_DIR = 'img/';
    const BG_COLOR = 0xFFFFFF;
    const BG_ALPHA = 0;
    const BG_MESH_NAME = 'backgroundMesh-';
    const BG_CORR_Z = -0.4;

    const GRID_D = 5;
    const GRID_CORR_Z = 0.4;

    const CSV_REPL_HEADER = 't,x,y,acc,f,did';

    //three.js
    var camera, scene, renderer;
//    var camerahelper;
    var mouse, raycaster;

    //dat.gui
    var gui;

    /*    var cam = {
        C_N: -100,
        C_F: 100,
        cnListener: function() {},
        cfListener: function() {},
        get CAM_NEAR(){

        }
        get CAM_FA

    };*/


    //daten des dargestellten geb√§udes
    var building = {
        w: window.innerWidth,
        h: window.innerHeight,
        ratio: this.w / this.h,
        wListener: function() {},
        hListener:function() {},

        get width(){
            return this.w;
        },
        get height(){
            return this.h;
        },
        set width( val ) {
            this.w = val;
            this.wListener( val ) 
        },
        set height( val ) {
            this.h = val;
            this.hListener( val ) ;
        },
        registerWListener: function( listener ) {
            this.hListener = listener;
        },
        registerHListener: function( listener ) {
            this.wListener = listener;
        },

        f: INIT_FLOOR,
        fListener: function() {},
        get floor(){
            return this.f;
        },
        set floor( val ) {
            if( val != this.f )  {
                this.f = val;
                this.fListener( val ) ;
            }
        },
        registerFListener: function( listener ) {
            this.fListener = listener;
        },

        s: INIT_SCALE,
        sListener: function() {},
        get scale(){
            return this.s;
        },
        get scaleFraction(){
            return (1/this.s ) ;
        },
        set scale( val ) {
            if( val != this.s ) {
                this.s = val;
                this.sListener( val ) ;
            }
        },
        registerSListener: function( listener ) {
            this.sListener = listener;
        },

        filePath: INIT_FILEPATH,
        fileExt: INIT_EXT,
        get path(){
            return this.filePath + this.f + this.fileExt;
        },

        lt: INIT_LINETYPE,
        ltListener: function() {},
        get lineType(){
            return this.lt;
        },
        set lineType( val ) {
            if( val != this.lt )  {
                this.lt = val;
                this.ltListener( val ) ;
            }
        },
        registerLtListener: function( listener ) {
            this.ltListener = listener;
        },

        bgMeshes: {},
        grids: {},
        trajectoryFloorGroups: {}
    };
    building.registerWListener( function( ) {
        this.ratio = this.w / this.h;
        configCamera();
        updateRenderer();
    });
    building.registerHListener( function( ){
        this.ratio = this.w / this.h;
        configCamera();
        updateRenderer();
    });
    building.registerFListener( function( ){
        changeFloors( building.floor, building.path );
    });
    building.registerSListener( function( ){
        changeScale();
    });
    building.registerLtListener( function( ){
        changeLineType();
    });

    var Trajectory = function(){
        this.color = TRAJ_COLOR;
        this.did = '';
        this.floor = 0;
        this.points = [];
        this.line = new THREE.Line();
        this.visible = false;
    };

    init();
    update();

    function init(){
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera( 0, 0, 0, 0, 0, 0, 0 );

        initRenderer();
        configCamera();
        initDatGUI();
        initBackgroundFileInput();
        initDataFileInput();
        addWindowListeners();
    }

    function initRenderer(){
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor( BG_COLOR, BG_ALPHA );
//        renderer.setPixelRatio( window.devicePixelRatio ) ;
        document.body.appendChild( renderer.domElement ) ;
        updateRenderer();
    }
    function updateRenderer(){
        renderer.setSize( window.innerWidth, window.innerHeight ) ;
    }

    function configCamera(){

        var windowRatio = window.innerWidth / window.innerHeight;

        if(( window.innerWidth / window.innerHeight )  < building.ratio ) {
            camera = new THREE.OrthographicCamera(0, building.width,
                 0, -building.width / windowRatio, CAM_NEAR, CAM_FAR);
        } else {
            camera = new THREE.OrthographicCamera(0, building.height * windowRatio,
                0, -building.height, CAM_NEAR, CAM_FAR);
        }
        updateCamera();
    }
    function updateCamera(){

        camera.updateProjectionMatrix();

        /*if( camerahelper ) {
            camerahelper.update();
        }*/
    }

    function initDatGUI(){
        gui = new dat.GUI();
        gui.add( building, 'floor', GUI_FLOORMIN, GUI_FLOORMAX ).step( GUI_FLOORSTEP ).name( 'Floor' );
        gui.add( building, 'scale', GUI_SCALEMIN, GUI_SCALEMAX ).step( GUI_SCALESTEP ).name( 'Scale (1/X)' );
        gui.add( building, 'lineType', ['Line', 'Curve']).name( 'Line type' );
        /*var f1 = gui.addFolder( 'Dev tools' );
        f1.add( this, 'CAM_FAR' ).step( 0.5 ).listen();
        f1.add( this, 'CAM_NEAR' ).step( 0.5 ).listen();*/
    }

    function initBackgroundFileInput(){
        var buildingFileInput = document.createElement( 'input' );
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.accept = "image/*";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        document.body.appendChild( buildingFileInput );

        buildingFileInput.addEventListener( 'change', function(){

            var file = buildingFileInput.files[0];
            var fileName = buildingFileInput.files[0].name;
            var fileType = /image.*/;

            if ( file.type.match( fileType ) ){

                building.filePath = fileName.slice( 0, -5 );
                building.fileExt = fileName.slice( -4, fileName.length );

                deleteAll();
                changeFloors( building.floor, building.path );

            } else {
                alert( "File not supported" );
            }
        });

        var buildingFile = {
            loadBuildingFile: function() {
                document.getElementById( "buildingFileInput" ).click();
            }
        };
        gui.add( buildingFile, 'loadBuildingFile' ).name( 'Load Building file' );
    }
    function initDataFileInput(){
        var dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild( dataFileInput ) ;

        dataFileInput.addEventListener( 'change', function() {

            for( var file = 0; file < dataFileInput.files.length; file++ ){
                var reader = new FileReader();
                reader.onload = function() {
                    var result = this.result;
                    loadNewTrajectories( result );
                };
                reader.readAsText( dataFileInput.files[file] );
            }

            //var fileType = /text.*/;
            //if ( file.type.match( fileType ) ){

            /*} else {
                alert("File not supported");
            }*/

            this.value = null; //remove filename from input
        });

        var trajectoryFile = {
            loadDataFile : function() {
                document.getElementById("dataFileInput").click();
            }
        };
        gui.add( trajectoryFile, 'loadDataFile').name('Load Trajectory file');
    }


    function loadNewBgMesh( buildingName, floor ){

        var buildingPath = BG_DIR + buildingName;
        var backgroundMesh;
        var bgMaterial = new THREE.MeshBasicMaterial();

        var bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            function ( texture ) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //pixel in meter umrechnen
                building.width = texture.image.naturalWidth * building.scaleFraction;
                building.height = texture.image.naturalHeight * building.scaleFraction;

                //create bgPlane
                var backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push( new THREE.Vector3( 0, 0, floor + BG_CORR_Z ));
                backgroundPlane.vertices.push( new THREE.Vector3( 0, -building.height, floor + BG_CORR_Z ));
                backgroundPlane.vertices.push( new THREE.Vector3( building.width, -building.height, floor + BG_CORR_Z ));
                backgroundPlane.vertices.push( new THREE.Vector3( building.width, 0, floor + BG_CORR_Z ));

                backgroundPlane.faces.push( new THREE.Face3( 0,1,3 ));
                backgroundPlane.faces.push( new THREE.Face3( 1,2,3 ));
                //backgroundPlane.computeFaceNormals();

                backgroundPlane.faceVertexUvs[0] = [];
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2( 0,1 ),
                    new THREE.Vector2( 0,0 ),
                    new THREE.Vector2( 1,1 )
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2( 0,0 ),
                    new THREE.Vector2( 1,0 ),
                    new THREE.Vector2( 1,1 )
                ]);
                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );
                backgroundMesh.name = BG_MESH_NAME + building.floor;

                building.bgMeshes[floor] = backgroundMesh;
                scene.add( building.bgMeshes[floor] );

                loadNewGrid( floor );
                initRaycaster(); //testing

            },
            function (){},
            function (){
                console.log( 'BG-loading failed' );
            }
        );
    }
    function loadNewGrid( floor ){

        var coordLines;
        var coordGeometry = new THREE.Geometry();

        //x-axis
        for( var x = 0; x < ( building.height ); x += GRID_D ){
            coordGeometry.vertices.push( new THREE.Vector3( 0, -x, floor + GRID_CORR_Z ));
            coordGeometry.vertices.push( new THREE.Vector3( building.width, -x, floor + GRID_CORR_Z ));
        }
        //y-axis
        for( var y = 0; y < ( building.width ); y += GRID_D ){
            coordGeometry.vertices.push( new THREE.Vector3( y, 0, floor + GRID_CORR_Z ));
            coordGeometry.vertices.push( new THREE.Vector3( y, -building.height, floor + GRID_CORR_Z ));
        }

        var coordMaterial = new THREE.LineBasicMaterial({ color: 0x555555, opacity: 1, linewidth: 1 });
        coordLines = new THREE.LineSegments( coordGeometry, coordMaterial );

        building.grids[floor] = coordLines;
        scene.add( coordLines );
    }
    function loadNewTrajectories( readerResult ){

        var pointList = parseCSV( readerResult );
        pointList = sortPoints( pointList );

        var corredPointListByDID = groupPointListByDid( corrPoints( pointList ) );
        var corredPointListByDIDByFloor = [];
        var corredPointListByDIDByFloorByTime = [];

        for( var did1 in corredPointListByDID ){
            if ( corredPointListByDID.hasOwnProperty( did1 ) ){
                corredPointListByDIDByFloor[did1] = groupPointListByFloor( corredPointListByDID[did1]);
            }
        }
        for( var did2 in corredPointListByDIDByFloor ){

            var tempList = [];

            for ( var floor1 in corredPointListByDIDByFloor[did2]){
                if ( corredPointListByDIDByFloor[did2].hasOwnProperty( floor1 ) ) {

                    tempList[floor1] = groupPointListByTime(corredPointListByDIDByFloor[did2][floor1])
                }
            }
            corredPointListByDIDByFloorByTime[did2] = tempList;
        }
        for( var did3 in corredPointListByDIDByFloorByTime ){
            for( var floor2 in corredPointListByDIDByFloorByTime[did3] ){
                if( corredPointListByDIDByFloorByTime[did3].hasOwnProperty( floor2 ) ){
                    for ( var pointGroup in corredPointListByDIDByFloorByTime[did3][floor2] ){
                        if( corredPointListByDIDByFloorByTime[did3][floor2].hasOwnProperty( pointGroup ) ){
                            var tempTrajectory = new Trajectory();
                            tempTrajectory.did = did3;
                            tempTrajectory.floor = corredPointListByDIDByFloorByTime[did3][floor2][pointGroup][0].f;
                            tempTrajectory.points = corredPointListByDIDByFloorByTime[did3][floor2][pointGroup];

                            if ( !building.trajectoryFloorGroups[tempTrajectory.floor] ){
                                building.trajectoryFloorGroups[tempTrajectory.floor] = [];
                            }
                            if ( tempTrajectory.points.length > 1 ){
                                building.trajectoryFloorGroups[tempTrajectory.floor].push( tempTrajectory );
                            }
                        }
                    }
                }
            }
        }

        makeAllTrajectories();
        addAllTrajectories();
    }


    function parseCSV ( csvString ){

        var pointsList = Papa.parse( csvString , {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            comments: '#',
            //step: true,
            beforeFirstChunk: function( chunk ) {
                var rows = chunk.split( /\r\n|\r|\n/ );
                rows[0] = CSV_REPL_HEADER;
                return rows.join("\r\n");
            }
        });
        return pointsList.data; // = array of objects
    }
    function corrPoints ( pointList ){
        pointList.forEach(
            function ( point ) {
                point.y = point.y * -1;
            }
        );
        return pointList;
    }
    function groupPointListByFloor( pointList ){
        return groupBy(
            pointList,
            function( item )  {
                return [item.f]; //, item.t
            }
        );
    }
    function groupPointListByDid( pointList ){
        return groupBy(
            pointList,
            function( item )  {
                return [item.did]; //, item.t
            }
        );
    }
    function groupPointListByTime( pointList ){

        var pointListByTime = [];

        var tempTime = pointList[0].t;
        var tempTimeArray = [];


        pointList.forEach(function( point ){

            if( tempTime + TRAJ_CUT_TIME < point.t ) {

                pointListByTime.push( tempTimeArray ) ;
                tempTimeArray = [];
                tempTimeArray.push( point );
                tempTime = point.t;

            } else {

                tempTimeArray.push( point );
                tempTime = point.t;

            }
        });
        pointListByTime.push(tempTimeArray);

        /* var pointListByTime = groupBy(
            pointList,
            function( item )  {
                return [item.did]; //, item.t
            }
        );*/
        return pointListByTime;
    }
    function groupBy( array, f ){

        var groups = {};
        array.forEach(
            function( object ) {
                var group = JSON.stringify( f( object ) );
                groups[group] = groups[group] || []; //if groups[group] doesn't exist, [] is assigned
                groups[group].push( object );
            }
        );
        return groups;

        /*return Object.keys( groups ) .map(
            function( group ) {
                return groups[group];
            }
        )*/
    }
    function sortPoints( pointList ){
        pointList.sort(
            firstBy("did")
            .thenBy("f")
            .thenBy("t")
        );

        return pointList;
    }

    function makeAllTrajectories(){
        for( var floor in building.trajectoryFloorGroups ){
            if( building.trajectoryFloorGroups.hasOwnProperty( floor ) ){
                building.trajectoryFloorGroups[floor].forEach( function ( traj ){

                    var tempTraj;
                    if ( building.lineType == 'Line' ){
                        tempTraj = makeLineGeom( traj.points );
                    } else if ( building.lineType == 'Curve' ){
                        tempTraj = makeCurveGeom( traj.points );
                    }
                    var trajectoryMaterial = new THREE.LineBasicMaterial({ color: traj.color, opacity: 1 });
                    traj.line = new THREE.Line( tempTraj, trajectoryMaterial );
                });
            }
        }
    }
    function makeLineGeom( points ) {

        var vertices = [];
        points.forEach(
            function ( point ) {
                vertices.push( new THREE.Vector3( point.x, point.y, point.f ));
            }
        );

        var lineGeom = new THREE.Geometry();
        lineGeom.name = points[0].did;
        lineGeom.vertices = vertices;

        return lineGeom;
    }
    function makeCurveGeom( points ) {

        var vertices = [];
        points.forEach(
            function( point ) {
                vertices.push( new THREE.Vector3( point.x, point.y, point.f ));
            }
        );
        var curve = new THREE.CatmullRomCurve3( vertices );
        var curveGeom = new THREE.Geometry();
        curveGeom.name = points[0].did;
        curveGeom.vertices = curve.getPoints( 50 );

        return curveGeom;
    }

    function addAllTrajectories() {
        for( var floor in building.trajectoryFloorGroups ){
            if( building.trajectoryFloorGroups.hasOwnProperty( floor ) ){
                building.trajectoryFloorGroups[floor].forEach(function (traj) {
                    scene.add(traj.line);
                });
            }
        }
    }


    function removeAllBgMeshes(){
        for( var bgMesh in building.bgMeshes ){
            if( building.bgMeshes.hasOwnProperty( bgMesh ) ){
                scene.remove(building.bgMeshes[bgMesh]);
            }
        }
    }
    function deleteAllBgMeshes(){
        removeAllBgMeshes();
        building.bgMeshes = {};
    }

    function removeAllGrids(){
        for( var grid in building.grids ){
            if( building.grids.hasOwnProperty( grid ) ){
                scene.remove( building.grids[grid] );
            }
        }
    }
    function deleteAllGrids(){
        removeAllGrids();
        building.grids = {};
    }

    function removeAllTrajectories(){
        for( var floor in building.trajectoryFloorGroups ){
            if( building.trajectoryFloorGroups.hasOwnProperty( floor ) ){
                for ( var traj in building.trajectoryFloorGroups[floor] ){
                    if( building.trajectoryFloorGroups[floor].hasOwnProperty( traj ) ){
                        scene.remove( building.trajectoryFloorGroups[floor][traj].line );
                    }
                }
            }
        }
    }
    function deleteAllTrajectories(){
        removeAllTrajectories();
        building.trajectoryFloorGroups = {};
    }

    function removeAll(){
        removeAllBgMeshes();
        removeAllGrids();
        removeAllTrajectories();
    }
    function deleteAll(){
        deleteAllBgMeshes();
        deleteAllGrids();
        deleteAllTrajectories();
    }

    function changeFloors( floor, path ){
        console.log( floor );
        CAM_NEAR = ( floor + GRID_CORR_Z ) * -1 ;

        if( building.bgMeshes[floor] instanceof THREE.Mesh ){
            configCamera();
        } else {
            loadNewBgMesh( path, floor ); //also invokes loadGrid()
        }
    }
    function changeScale(){
        deleteAllBgMeshes();
        deleteAllGrids();
        loadNewBgMesh( building.path, building.floor ); //also invokes loadNewGrid();
        addAllTrajectories();
    }
    function changeLineType(){
        removeAllTrajectories();
        makeAllTrajectories();
        addAllTrajectories();
    }
    /*   function initRaycaster() {
    raycaster = new THREE.Raycaster();
    raycaster.near = -500;
    raycaster.far = 1000;
    mouse = new THREE.Vector2();

    window.addEventListener('click', onMouseClick, false ) ;
}

function onMouseClick( event ){
    mouse.x = ( event.clientX / window.innerWidth )  * 2 - 1;
    mouse.y = -( event.clientY / window.innerHeight )  * 2 + 1;

    raycaster.setFromCamera( mouse, camera );

    var bg = scene.getObjectByName('backgroundMesh');

    // calculate objects intersecting the picking ray
    var intersects = raycaster.intersectObject( bg, true ) ;

    for ( var i = 0; i < intersects.length; i++ ) {
        console.log('x:' + intersects[0].point.x + ' ' +
                    'y:' + intersects[0].point.y + ' ' +
                    'z:' + intersects[0].point.z ) ;
    }
}
*/

    function addWindowListeners() {
        window.addEventListener('resize', onWindowResize, false ) ;
    }
    function onWindowResize () {
        configCamera();
        updateRenderer();
    }

    function initRaycaster() {
        raycaster = new THREE.Raycaster();
        raycaster.near = CAM_NEAR;
        raycaster.far = CAM_FAR;
        mouse = new THREE.Vector2();

        window.addEventListener('click', onMouseClick, false ) ;
    }
    function onMouseClick( event ){
        mouse.x = ( event.clientX / window.innerWidth )  * 2 - 1;
        mouse.y = -( event.clientY / window.innerHeight )  * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        var bg = scene.getObjectByName( BG_MESH_NAME + building.floor );

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObject( bg, true ) ;

        for ( var i = 0; i < intersects.length; i++ ) {
            console.log('x:' + intersects[0].point.x + ' ' +
                'y:' + intersects[0].point.y + ' ' +
                'z:' + intersects[0].point.z ) ;
        }
    }

    function update() {
        requestAnimationFrame( update ) ;
        renderer.render( scene, camera ) ;
    }

</script>
</body>
</html>