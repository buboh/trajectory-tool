<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>draw</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>
<script src="js/three.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script>
    //FLAG
    var INITIALIZED = false;
    var IMG_LOADED = false;

    //Set scene size
    var WINDOW_WIDTH = window.innerWidth;
    var WINDOW_HEIGHT = window.innerHeight;

    // 1 Meter in Realit√§t ist <10> Pixel auf einem Bild
    //meter/pixel
    var scale = 1/100;

    //in metern  // WINDOW_ nur zum Testen
    var buildingWidth;
    var buildingHeight;
    var buildingRatio = WINDOW_WIDTH / WINDOW_HEIGHT;

    //Background image
    var backgroundMesh;

/*    //CoordSys meters
    var FRAME_COORDSYS = 0;
    var V_LEFT_CORR;
    var V_TOP_CORR;
    var V_RIGHT_CORR;
    var V_BOTTOM_CORR;

    function updateCorrValues(){
        V_LEFT_CORR = - (buildingWidth / 2);
        V_TOP_CORR = (buildingHeight / 2);
        V_RIGHT_CORR = (buildingWidth / 2);
        V_BOTTOM_CORR = - (buildingHeight / 2);
    }*/

    //three.js
    var camera, scene, renderer;
    var camerahelper;

    //dat.gui
    var gui;


    scene = new THREE.Scene();

    initBgImg();

    initRenderer();

    update();


    function initialize(){

        initCamera();

        initGrid();

        initDatGUI();

        //help
        //camerahelper = new THREE.CameraHelper( camera );
        //scene.add(camerahelper);

        addWindowListeners();

        INITIALIZED = true;
    }

    function initBgImg(){
        var bgMaterial = new THREE.MeshBasicMaterial();

        var bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            'img/indoors-office.png',
            function ( texture ) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                var bgImgWidth = texture.image.naturalWidth;
                var bgImgHeight = texture.image.naturalHeight;

                buildingWidth = bgImgWidth * scale;
                buildingHeight = bgImgHeight * scale;
                buildingRatio = buildingWidth / buildingHeight;

                //updateCorrValues();

                IMG_LOADED = true;

                //create bgPlane
                var backgroundPlane = new THREE.Geometry();

               /* backgroundPlane.vertices.push(new THREE.Vector3(buildingWidth / -2, buildingHeight / 2, 0.5));
                backgroundPlane.vertices.push(new THREE.Vector3(buildingWidth / -2, buildingHeight / -2, 0.5));
                backgroundPlane.vertices.push(new THREE.Vector3(buildingWidth / 2, buildingHeight / -2, 0.5));
                backgroundPlane.vertices.push(new THREE.Vector3(buildingWidth / 2, buildingHeight / 2, 0.5));*/

                backgroundPlane.vertices.push(new THREE.Vector3(0, 0, 0.5));
                backgroundPlane.vertices.push(new THREE.Vector3(0, -buildingHeight, 0.5));
                backgroundPlane.vertices.push(new THREE.Vector3(buildingWidth, -buildingHeight, 0.5));
                backgroundPlane.vertices.push(new THREE.Vector3(buildingWidth, 0, 0.5));

                backgroundPlane.faces.push(new THREE.Face3(0,1,3));
                backgroundPlane.faces.push(new THREE.Face3(1,2,3));
                backgroundPlane.computeFaceNormals();

                backgroundPlane.faceVertexUvs[0] = [];

                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0,1),
                    new THREE.Vector2(0,0),
                    new THREE.Vector2(1,1)
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0,0),
                    new THREE.Vector2(1,0),
                    new THREE.Vector2(1,1)
                ]);

                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    //new THREE.PlaneGeometry(WINDOW_WIDTH, WINDOW_WIDTH / buildingRatio),

                    backgroundPlane,
                    bgMaterial

                );

                //backgroundMesh.translateY((WINDOW_HEIGHT/2) - );
                scene.add(backgroundMesh);
            },
            function () {},
            function () {
                console.log('bg-loading failed');
            }
        );
     }

    function initGrid(){

        var coordGeometry = new THREE.Geometry();

        //x-axis
        for (i = 0; i < (buildingHeight); i++) {
            coordGeometry.vertices.push(new THREE.Vector3(0, -i, 1));
            coordGeometry.vertices.push(new THREE.Vector3(buildingWidth, -i, 1));
        }
        //y-axis
        for (i = 0; i < (buildingWidth); i++) {
            coordGeometry.vertices.push(new THREE.Vector3(i, 0, 1));
            coordGeometry.vertices.push(new THREE.Vector3(i, -buildingHeight, 1));
        }

        var coordMaterial = new THREE.LineBasicMaterial({color: 0x555555, opacity: 1, linewidth: 1});
        var coordLines = new THREE.LineSegments(coordGeometry, coordMaterial);

        scene.add(coordLines);
    }

    function initCamera(){

        var ratio = WINDOW_WIDTH / WINDOW_HEIGHT;

        if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(buildingWidth / -2, buildingWidth / 2,
                (buildingWidth / 2) / ratio, (buildingWidth / -2) / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera((buildingHeight / -2) * ratio, (buildingHeight / 2) * ratio,
                (buildingHeight / 2), (buildingHeight / -2), -500, 1000);
        }

        if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(0, buildingWidth,
                 0, -buildingWidth / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera(0, buildingHeight * ratio,
                0, -buildingHeight, -500, 1000);
        }

/*        camera = new THREE.OrthographicCamera(buildingWidth / -2, buildingWidth / 2,
            (buildingWidth / 2) / ratio, (buildingWidth / -2) / ratio, -500, 1000);*/

        camera.updateProjectionMatrix();

    }
    function updateCamera(){

        var ratio = WINDOW_WIDTH / WINDOW_HEIGHT;

        if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(buildingWidth / -2, buildingWidth / 2,
                (buildingWidth / 2) / ratio, (buildingWidth / -2) / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera((buildingHeight / -2) * ratio, (buildingHeight / 2) * ratio,
                (buildingHeight / 2), (buildingHeight / -2), -500, 1000);
        }

        if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            camera = new THREE.OrthographicCamera(0, buildingWidth,
                0, -buildingWidth / ratio, -500, 1000);
        } else {
            camera = new THREE.OrthographicCamera(0, buildingHeight * ratio,
                0, -buildingHeight, -500, 1000);
        }

/*        camera = new THREE.OrthographicCamera(buildingWidth / -2, buildingWidth / 2,
            (buildingWidth / 2) / ratio, (buildingWidth / -2) / ratio, -500, 1000);*/

        camera.updateProjectionMatrix();

        if(camerahelper != null){
            camerahelper.update();
        }


    }

    function initRenderer(){
        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setClearColor(0xffffff, 0);
        renderer.setPixelRatio(window.devicePixelRatio);

        /*if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            renderer.setSize(WINDOW_WIDTH, WINDOW_WIDTH * buildingRatio);
        } else {
            renderer.setSize(WINDOW_HEIGHT / buildingRatio, WINDOW_HEIGHT);
        }*/

        renderer.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

        document.body.appendChild(renderer.domElement);
    }
    function updateRenderer(){

        /*if((WINDOW_WIDTH / WINDOW_HEIGHT) < buildingRatio){
            renderer.setSize(WINDOW_WIDTH, WINDOW_WIDTH * buildingRatio);
        } else {
            renderer.setSize(WINDOW_HEIGHT / buildingRatio, WINDOW_HEIGHT);
        }*/

        renderer.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

    }

    function initDatGUI(){
        gui = new dat.GUI();
        //gui.add(coordSys, )
    }
    function addWindowListeners(){
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize () {
        WINDOW_HEIGHT = window.innerHeight;
        WINDOW_WIDTH = window.innerWidth;

        updateCamera();
        updateRenderer();
    }

    function update () {

        if((!INITIALIZED) && IMG_LOADED){
            initialize();
        }

        requestAnimationFrame(update);
        renderer.render(scene, camera);
    }

</script>



</body>
</html>