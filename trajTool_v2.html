<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TrajTool</title>
    <style>
        body { margin: 0; overflow: hidden }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/chroma.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>

<!--Trajectory viewer-->
<script>

    //'use strict';

//--CONSTANTS-&-VARIABLES-----------------------------------------------------------------------------------------------

    let camera, scene, renderer;
    let mouse, raycaster, INTERSECTED;
    let gui;
    let buildingFileClicker, trajectoryFileClicker;

    const threePar = {
        cam: {
            corrNear: -0.1,
            corrFar: 0.1,
            corrZ: 100,
            positionZ: 100,
        },
        rend: {
            aa: true,
            alpha: true,
            color: 0xffffff,
            alphaVal: 0,
        },
        rayc: {
            linePrec: 1,
        },
    };
    const guiPar = {
        bgLoader: {
            path: {
                init: 'white-',
            },
            ext: {
                init: '.png',
            },
            name: 'Load building',
        },
        scale: {
            min: 45,
            max: 100,
            step: 1,
            init: 49,
            name: 'Scale (1:X)',
        },
        floor: {
            min: -2,
            max: 2,
            step: 1,
            init: 1,
            name: 'Floor',
        },
        dataLoader: {
            name: 'Load trajectories',
        },
        lineType: {
            init: 'Point',
            choices: [
                'Point', 'Line', 'Clusters', 'Graph', 'Better', 'EvenBetter'
            ],
            name: 'Line type',
        },
        cMaxRad: {
            min: 5,
            max: 50,
            step: 5,
            init: 20,
            name: 'Radius',
        },
        redist: {
            min: 0,
            max: 50,
            step: 1,
            init: 50,
            name: 'Redist count',
            change: true,
        },
    }; //ToDo: building path changed-----------------------------------------------------------------
    const par = {
        bg: {
            dir: 'img/',
            corrZ: -0.1,
        },
        gd: {
            delta: 5,
            corrZ: 0.1,
            line: {
                color: 0x555555,
                opacity: 1,
            }
        },
        pt: {
            color: 0xff0000,
            opacity: 1,
            dot: {
                size: 3.5,
            },
        },
        tj: {
            color: 0xff0000,
            opacity: 1,
            clickColor: 0x000000,
            cutTime: 20000,
            dot: {
                size: 3.5,
            },
            deviationFactor: 0.25, //should be changed depending on number of trajectories on connection
        },
        ln: {
            color: 0x000000,
            opacity: 0.4,
            transparency: true,
        },
        ct: {
            color: 0xffffff,
            opacity: 1,
            corrColor: 0x555555,
            colorScaleType: 'RdYlBu',
            colorDarkenFactor: 0,
            dot: {
                size: 10,
            },
        },
        csv: {
            header: 't,x,y,acc,f,did',
            removeCount: 5,
        },
        subsaRadius: 3,

        //tj = trajectory; pt = point; ct = centroid; bg = background; gd = grid
    };

    const bd = {
        w: window.innerWidth, //building width
        wListener: function() {},
        get width() {
            return this.w;
        },
        set width(val) {
            this.w = val;
            this.wListener(val)
        },
        registerWListener: function(listener) {
            this.hListener = listener;
        },

        h: window.innerHeight, //building height
        hListener: function() {},
        get height() {
            return this.h;
        },
        set height(val) {
            this.h = val;
            this.hListener(val);
        },
        registerHListener: function(listener) {
            this.wListener = listener;
        },

        get ratio() {
            return this.w / this.h;
        },

        f: guiPar.floor.init, //building floor
        fListener: function() {},
        get floor() {
            return this.f;
        },
        set floor(val) {
            if (val !== this.f) {
                this.f = val;
                this.fListener();
            }
        },
        registerFListener: function(listener) {
            this.fListener = listener;
        },

        s: guiPar.scale.init, //building scale
        sListener: function() {},
        get scale() {
            return this.s;
        },
        get scaleFraction() {
            return ( 1 / this.s );
        },
        set scale(val) {
            if (val !== this.s) {
                this.s = val;
                this.sListener(val);
            }
        },
        registerSListener: function(listener) {
            this.sListener = listener;
        },

        filePath: guiPar.bgLoader.path.init,
        fileExt: guiPar.bgLoader.ext.init,
        get path() {
            return this.filePath + this.f + this.fileExt;
        },

        lt: guiPar.lineType.init, //trajectory linetype
        ltListener: function() {},
        get lineType() {
            return this.lt;
        },
        set lineType(val) {
            //if (val !== this.lt) {
                this.lt = val;
                this.ltListener(val);
            //}
        },
        registerLtListener: function(listener) {
            this.ltListener = listener;
        },

        mR: guiPar.cMaxRad.init, //cluster maxRadius
        mRListener: function() {},
        get maxRadius() {
            return this.mR;
        },
        set maxRadius(val) {
            if (val !== this.mR) {
                this.mR = val;
                this.mRListener(val);
            }
        },
        registerMRListener: function(listener) {
            this.mRListener = listener;
        },

        redi: guiPar.redist.init,
        rediListener: function() {},
        get redist() {
            return this.redi;
        },
        set redist(val) {
            if(val !== this.redi) {
                this.redi = val;
                this.rediListener(val);
            }
        },
        registerRediListener: function(listener) {
            this.rediListener = listener;
        },
    };
    bd.registerWListener(function() {
        updateCamera();
        updateRenderer();
    });
    bd.registerHListener(function() {
        updateCamera();
        updateRenderer();
    });
    bd.registerFListener(function() {
        changeFloors();
    });
    bd.registerSListener(function() {
        changeScale();
    });
    bd.registerLtListener(function() {
        changeLineType();
    });
    bd.registerMRListener(function() {
        changeClusterRadius();
    });
    bd.registerRediListener(function() {
        deleteClusterTrajectories();
        bd.lineType = 'Clusters';
    });

    const data = {
        grds: {},

        pnts: [],
        trjs: {
            raw: [],
            subsa: [],
            better: [],
            evenbetter: []
        },
        clts: {
            clusters: [],
            centroids: [],
            circles: [],
            members: [],
            errors: [], //temp
        },
        grph: {
            edges: []
        },
    };
    const draw = {
        bgMs: {},
        grds: {},

        pnts: [],
        trjs: {
            raw: [],
            subsa: [],
            better: [],
            evenbetter: []
        },
        clts: {
            centroids: [],
            circles: [],
            members: [],
            errors: [], //temp
        },
        grph: {
            edges: []
        }
    };

    class Point {
        constructor(p) {
            this.color = par.pt.color;
            this.did = p.did;
            this.x = p.x;
            this.y = p.y;
            this.f = p.f;
            this.t = p.t;
            this.c = null;
            this.cl = null;
            this.pP = null;
            this.nP = null;
            data.pnts.push(this);
        }
        get centroid() { return this.c; }
        set centroid(cent) {
            this.c = cent;
//            if(this.g && (cent !== this.g.c)) {
//                this.g = null;
//            }
        }
        get cluster() { return this.cl; }
        set cluster(clus) {
            this.cl = clus;
            this.c = clus.c;
        }
        get prevPoint() { return this.pP }
        set prevPoint(pt) {
            this.pP = pt;
            if(pt) pt.nP = this;
        }
        get nextPoint() { return this.nP }
        set nextPoint(pt) {
            this.nP = pt;
            if(pt) pt.pP = this;
        }
    }
    class Centroid extends Point {
        constructor(c) {
            super(c);
            this.prevCents = new Set(); // ev. Map mit Cent als key und anzahl als val?
            this.nextCents = new Set();
            this.cl = c.cl;
            this.color = Math.random() * 0xffffff;
        }
        get cluster() { return this.cl }
        set cluster(clus) {
            this.cl = clus;
        }
    }
    class Cluster {
        constructor() {
            this.c = {};
            this.m = [];
            //data.clts.push(this);
        }
        get centroid() { return this.c }
        set centroid(cent) {
            this.c = cent;
            this.c.cluster = this;
            this.m.forEach(function(pt) {
               pt.centroid = cent;
            });
        }
        get members() { return this.m }
        set members(memb) {
            this.m = memb;
            if(this.c) {
                this.m.forEach(function(pt) {
                   pt.centroid = this.c;
                });
            }
        }
        addMember(pt) {
            pt.cluster = this;
            this.m.push(pt);
        }
        removeMember(pt) {
            pt.cluster = null;
            //implement this.m.remove(pt);
        }
        updateCentroid() {

            let sumX = 0;
            let sumY = 0;
            const points = this.members;
            const numPoints = this.members.length;

            for (let p in points) {
                if(points.hasOwnProperty(p)){
                    sumX += points[p].x;
                    sumY += points[p].y;
                }
            }

            if (numPoints > 0) {
                const tempCent = this.centroid;
                tempCent.x = sumX / numPoints;
                tempCent.y = sumY / numPoints;
                this.centroid = tempCent;
            } else {
                //ToDo: implement: delete cluster --------------------------------------
                this.centroid = null;
            }
        }
    }
    class Trajectory {
        constructor(points) {
            this.points = points;
            this.centroids = [];
            this.anchors = [];
            this.color = Math.random() * 0xffffff; //par.tj.color;
            this.deviation = 0;
        }
    }

//--START---------------------------------------------------------------------------------------------------------------

    init();
    initRaycaster(); //broken for now
    update();

//--INITALIZATION-------------------------------------------------------------------------------------------------------
//  ToDo: Review init function (camera?)

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(0, 0, 0, 0, 0, 0, 0);
        initRenderer();
        initCamera();
        initBackgroundFileInput();
        initDataFileInput();
        initDatGUI();
        initWindowResizeListeners();
    }

    function initRenderer() {
        renderer = new THREE.WebGLRenderer({antialias: threePar.rend.aa, alpha: threePar.rend.alpha});
        renderer.setClearColor(threePar.rend.color, threePar.rend.alphaVal);//        renderer.setPixelRatio( window.devicePixelRatio ) ;
        document.body.appendChild(renderer.domElement);
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function initCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera = new THREE.OrthographicCamera(0, bd.width,
                0, -bd.width / windowRatio, 0, 200);
        } else {
            camera = new THREE.OrthographicCamera(0, bd.height * windowRatio,
                0, -bd.height, 0, 200);
        } //Temp code inside

        camera.position.z = 100;
        camera.lookAt(new THREE.Vector3(0,0,0));
        camera.updateProjectionMatrix();
    } //three.js
    function initRaycaster() {
        raycaster = new THREE.Raycaster();
        raycaster.near = 0; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
        raycaster.far = 200; //Math.round((bd.floor + par.bg.corrZ + threePar.cam.corrFar) * 100) / 100;
        raycaster.linePrecision = threePar.rayc.linePrec;
        mouse = new THREE.Vector2();
        window.addEventListener('click', onMouseClick, false);

        // when the mouse moves, call the given function
        //window.addEventListener( 'mousemove', onMouseClick, false );
    } //three.js

    function updateRenderer() {
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function updateCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera.right = bd.width;
            camera.bottom = -bd.width / windowRatio;
            camera.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
            camera.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.bg.corrZ + threePar.cam.corrFar) * 100) / 100;
        } else {
            camera.right = bd.height * windowRatio;
            camera.bottom = -bd.height;
            camera.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
            camera.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100;
        }
        camera.updateProjectionMatrix();
//        if( camerahelper ) {
//            camerahelper.update();
//        }
    } //three.js
    function updateRaycaster() {
        //if(bd.scaleFraction) raycaster.linePrecision = threePar.rayc.linePrec * bd.scale;
        //raycaster.linePrecision = 0;
        raycaster.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100;
        raycaster.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100;
    }

    function update() {
        //hoverDetector();
        requestAnimationFrame(update);
        renderer.render(scene, camera);
    } //three.js

    function hoverDetector() {

        raycaster.setFromCamera(mouse, camera);

        // create an array containing all objects in the scene with which the ray intersects
        let intersects = raycaster.intersectObjects(scene.children) ;

        // INTERSECTED = the object in the scene currently closest to the camera
        //		and intersected by the Ray projected from the mouse position

        // if there is one (or more) intersections
        if (intersects.length > 0) {

            const obj = intersects[0].object;
            // if the closest object intersected is not the currently stored intersection object
            if ((obj !== INTERSECTED) && (obj.type === 'Line')) {
                // restore previous intersection object (if it exists) to its original color
                if (INTERSECTED) {
                    INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    INTERSECTED.material.needsUpdate = true;
                }
                // store reference to closest object as current intersection object
                INTERSECTED = intersects[0].object;
                // store color of closest object (for later restoration)
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                // set a new color for closest object
                INTERSECTED.material.color.setHex( 0x00ff00 );
                INTERSECTED.material.needsUpdate = true;
            }
        } else {// there are no intersections
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED) {
                INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED.material.needsUpdate = true;
            }

            // remove previous intersection object reference
            // by setting current intersection object to "nothing"
            INTERSECTED = null;
        }
    }


    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // create an array containing all objects in the scene with which the ray intersects
        let intersects = raycaster.intersectObjects(scene.children) ;

        // INTERSECTED = the object in the scene currently closest to the camera
        //		and intersected by the Ray projected from the mouse position

        // if there is one (or more) intersections
        if (intersects.length > 0) {

            let obj;
            let tempGeom = null;

            for(let o = 0; o < intersects.length; o++) {

                const tempObj = intersects[o].object;

                if((!(intersects[o].distance.isNaN)) &&
                    (tempObj.geometry !== tempGeom) &&
                    ((Math.trunc(intersects[o].point.z * 100) / 100) === bd.floor))
                    outer_if:{

                    tempGeom = tempObj.geometry;

                    if((tempObj.type === 'Line') ||
                        ((tempObj.type === 'LineSegments') && (tempObj !== draw.grds[bd.floor]))) {
                        obj = tempObj;
                        break outer_if;
                    } else if(tempObj.type === 'Points') {
                        obj = tempObj;
                        break outer_if;
                    }



                }
            }

//      intersects[0].object.material.color.setHex(0x00ff00);
//      intersects[0].object.material.needsUpdate = true;

        // if the closest object intersected is not the currently stored intersection object
            if (obj !== INTERSECTED) {
                // restore previous intersection object (if it exists) to its original color
                if (INTERSECTED) {
                    INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    INTERSECTED.material.needsUpdate = true;
                }
                // store reference to closest object as current intersection object
                INTERSECTED = obj;
                // store color of closest object (for later restoration)
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                // set a new color for closest object
                INTERSECTED.material.color.setHex( 0x00ff00 );
                INTERSECTED.material.needsUpdate = true;
            }
        } else {// there are no intersections
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED) {
                INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED.material.needsUpdate = true;
            }
            // remove previous intersection object reference
            // by setting current intersection object to "nothing"
            INTERSECTED = null;
        }
    }
    //temp code inside
    function onDocumentMouseMove(event){
        // the following line would stop any other event handler from firing
        // (such as the mouse's TrackballControls)
        // event.preventDefault();

        // update the mouse variable
//        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
//        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    function initWindowResizeListeners() {
        window.addEventListener('resize', onWindowResize, false);
    }
    function onWindowResize() {
        updateRenderer();
        updateCamera();
    }

    function initBackgroundFileInput() {
        const buildingFileInput = document.createElement('input');
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.accept = "image/*";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        document.body.appendChild(buildingFileInput);

        buildingFileInput.addEventListener('change', function () {
            const file = buildingFileInput.files[0];
            const fileName = buildingFileInput.files[0].name;
            const fileType = /image.*/;

            if(file.type.match(fileType)) {
                bd.filePath = fileName.slice(0, -5);
                bd.fileExt = fileName.slice(-4, fileName.length);
                deleteAll();
                changeFloors();
            } else {
                alert("File not supported");
            }
        });
        buildingFileClicker = {
            loadBuildingFile: function () {
                document.getElementById("buildingFileInput").click();
            }
        };
    }
    function initDataFileInput() {
        const dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild(dataFileInput);

        dataFileInput.addEventListener('change', function () {
            const fileCount = dataFileInput.files.length;
            const result = [];
            for(let file = 0; file < fileCount; file++) {
                const reader = new FileReader();
                reader.onload = function () {
                    result.push(this.result);
                    if (result.length === fileCount) {
                        loadNewTrajectories(result);
                        makeAllTrajectories();
                        addAllTrajectories();
                    }
                };
                reader.readAsText(dataFileInput.files[file]);
            }
            this.value = null; //remove filename from input
        });
        trajectoryFileClicker = {
            loadDataFile: function () {
                document.getElementById("dataFileInput").click();
            }
        };
    }

    function initDatGUI() {
        gui = new dat.GUI();
        const fLoad = gui.addFolder('Load things');
        fLoad.add(buildingFileClicker, 'loadBuildingFile').name(guiPar.bgLoader.name);
        fLoad.add(trajectoryFileClicker, 'loadDataFile').name(guiPar.dataLoader.name);
        fLoad.open();
        const fDelete = gui.addFolder('Delete things');
        fDelete.add(this, 'deleteAll').name('Delete all');
        fDelete.add(this, 'deleteAllTrajectories').name('Delete trajectories');
        const fBdSettings = gui.addFolder('Building settings');
        fBdSettings.add(bd, 'scale', guiPar.scale.min, guiPar.scale.max).step(guiPar.scale.step).name(guiPar.scale.name);
        const fDataSettings = gui.addFolder('Data settings');
        fDataSettings.add(bd, 'maxRadius', guiPar.cMaxRad.min, guiPar.cMaxRad.max).step(guiPar.cMaxRad.step).name(guiPar.cMaxRad.name);
        fDataSettings.add(bd, 'redist', guiPar.redist.min, guiPar.redist.max).step(guiPar.redist.step).name(guiPar.redist.name);
        const fViewSettings = gui.addFolder('View settings');
        fViewSettings.add(this, 'hideAllGrids').name('Hide grid');
        fViewSettings.add(bd, 'floor', guiPar.floor.min, guiPar.floor.max).step(guiPar.floor.step).name(guiPar.floor.name);
        fViewSettings.add(bd, 'lineType', guiPar.lineType.choices).name(guiPar.lineType.name);
        fViewSettings.open();

    } //dat.gui

//--LOAD-BASICS---------------------------------------------------------------------------------------------------------

    function loadNewBgMesh(buildingName, floor) {
        const buildingPath = par.bg.dir + buildingName;
        let backgroundMesh;
        let bgMaterial = new THREE.MeshBasicMaterial();

        const bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            function (texture) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //translate pixels into meters -- ATTENTION! BG-imgs have to have same size!
                bd.width = texture.image.naturalWidth * bd.scaleFraction;
                bd.height = texture.image.naturalHeight * bd.scaleFraction;

                //create bgPlane
                const backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push(new THREE.Vector3(0, 0, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(0, -bd.height, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, -bd.height, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, 0, floor + par.bg.corrZ));

                backgroundPlane.faces.push(new THREE.Face3(0, 1, 3));
                backgroundPlane.faces.push(new THREE.Face3(1, 2, 3));//backgroundPlane.computeFaceNormals();
                backgroundPlane.faceVertexUvs[0] = [];
                backgroundPlane.faceVertexUvs[0].push([new THREE.Vector2(0, 1),
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );

                draw.bgMs[floor] = backgroundMesh;
                scene.add(draw.bgMs[floor]);

                genGrid(floor);
                drawGrid(floor);
            },
            function () {
            },
            function () {
                console.log('BG-loading failed');
            }
        );
    } //three.js
    function genGrid(floor) {

        let coordLines = [];

        for (let i = 0; i < ( bd.height ); i += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: 0,
                    y: i,
                    f: floor,
                },
                p1: {
                    x: bd.width,
                    y: i,
                    f: floor,
                }
            });
        }
        for (let j = 0; j < ( bd.width ); j += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: j,
                    y: 0,
                    f: floor,
                },
                p1: {
                    x: j,
                    y: bd.height,
                    f: floor,
                }
            });
        }
        data.grds[floor] = coordLines;
    }
    function drawGrid(floor) {

        const coordGeometry = new THREE.Geometry();
        data.grds[floor].forEach(function(line) {
            coordGeometry.vertices.push(new THREE.Vector3(line.p0.x, -line.p0.y, line.p0.f + par.gd.corrZ));
            coordGeometry.vertices.push(new THREE.Vector3(line.p1.x, -line.p1.y, line.p1.f + par.gd.corrZ));
        });

        const coordMaterial = new THREE.LineBasicMaterial({
            color: par.gd.line.color,
            opacity: par.gd.line.color,
        });

        draw.grds[floor] = new THREE.LineSegments(coordGeometry, coordMaterial);
        scene.add(draw.grds[floor]);
    } //three.js -- disabled

//--LOAD-TRAJECTORIES---------------------------------------------------------------------------------------------------
//  ToDo: Implement function for removing first and last locations of recording

    function loadNewTrajectories(readerResult) {

        let pointList = [];

    //--create-Point-Objects--------------------------------------------------------------------------------------------
        readerResult.forEach(function(file){
            const tempList = parseCSV(file);

            tempList.splice(0, par.csv.removeCount);
            tempList.splice(-par.csv.removeCount);

            tempList.forEach(function (point) {
                const p = new Point(point);
                pointList.push(p);
            });
        });

    //--sort-Points-----------------------------------------------------------------------------------------------------
        pointList = sortPoints(pointList);

        const pointListByDID = groupPointListByDid(pointList);
        const pointListByDIDByTime = [];

        for (let did1 in pointListByDID) {
            if(pointListByDID.hasOwnProperty(did1)){
                pointListByDIDByTime[did1] = groupPointListByTime(pointListByDID[did1]);
            }
        }

    //--create-Trajectories---------------------------------------------------------------------------------------------
        for(let did2 in pointListByDIDByTime) {
            for(let pointGroup in pointListByDIDByTime[did2]) {
                if (pointListByDIDByTime[did2].hasOwnProperty(pointGroup)) {

                    const tempTrajectory = new Trajectory(pointListByDIDByTime[did2][pointGroup]);

                    if(tempTrajectory.points.length > 1) {

                        let tempPrevPoint = tempTrajectory.points[0];
                        tempPrevPoint.prevPoint = null;

                        for(let p = 0; p < tempTrajectory.points.length; p++){
                            tempPrevPoint.nextPoint = tempTrajectory.points[p];
                            tempTrajectory.points[p].prevPoint = tempPrevPoint;
                            tempPrevPoint = tempTrajectory.points[p];
                        }
                        data.trjs.raw.push(tempTrajectory);
                    }
                }
            }
        }
    }

    function parseCSV(csvString) {
        const parseResult = Papa.parse(csvString, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            comments: '#',
            //step: true,
            beforeFirstChunk: function (chunk) {
                const rows = chunk.split(/\r\n|\r|\n/);
                rows[0] = par.csv.header;
                return rows.join("\r\n");
            }
        });
        return parseResult.data;
    }
    function sortPoints(pointList) {
    pointList.sort(
        firstBy("did")
            .thenBy("t")
    );
    return pointList;
}
    function groupPointListByDid(pointList) {
        return groupBy(pointList, function (item) {
                return [item.did]; //, item.t
            }
        );
    }
    function groupPointListByTime(pointList) {

        const pointListByTime = [];

        let tempTime = pointList[0].t;
        let tempTimeArray = [];

        pointList.forEach(function(point) {
            if (tempTime + par.tj.cutTime < point.t) {
                pointListByTime.push(tempTimeArray);
                tempTimeArray = [];
                tempTimeArray.push(point);
                tempTime = point.t;
            } else {
                tempTimeArray.push(point);
                tempTime = point.t;
            }
        });
        pointListByTime.push(tempTimeArray);
        return pointListByTime;
    }
    function groupBy(array, f) {

        const groups = {};
        array.forEach(
            function (object) {
                const group = JSON.stringify(f(object));
                groups[group] = groups[group] || []; //if groups[group] doesn't exist, [] is assigned
                groups[group].push(object);
            }
        );
        return groups;
    }

//--CLUSTERING----------------------------------------------------------------------------------------------------------
//  ToDo: data.clts.points.push(cluster.members) --> change .points. to .members

    function cluster(trajs) {
        const vertices = [];
        trajs.forEach(function(traj) {
            //subsampling
            const points = traj.points;
            const tempTraj = new Trajectory(subsamplePoints(points));
            data.trjs.subsa.push(tempTraj);
            vertices.push(tempTraj.points);
        });

        //centroid seed
        const P = vertices; //Points
        const G = generateGrid(P); //Grid
        const R = seedCentroids(P, G); //Results

        guiPar.redist.change = true;
        let i = 0;
        while((i < bd.redist) && guiPar.redist.change) {
            redistributePoints(P, R, G);
            recalculateCentroids(R, G);
            console.log(i);
            i++;
        }
        let ml = 0;
        R.forEach(function(cluster) {
            if(ml < cluster.members.length) ml = cluster.members.length;
        });


        R.forEach(function(cluster) {
            //cluster.centroid.color = Math.random() * par.ct.color + par.ct.corrColor;
            const scale = chroma.scale(par.ct.colorScaleType).domain([0,ml]);
            cluster.centroid.color = scale(cluster.members.length).darken(par.ct.colorDarkenFactor).hex();
            data.clts.clusters.push(cluster);
        });
    }

    function subsamplePoints(points) {
        const vertices = [];//R = Radius for subsampling, r = radius remaining for next segment, i = iterator, p0 = first point of traj, //pA and pB are start and end of segment to be subsampled, D = dist between pA and pB, d = remaining distance
        //p = subsampled point, vh = ratio of _________ (?),

        const R = par.subsaRadius;
        let r = R;

        const p0 = new Point({
            did: points[0].did,
            x: points[0].x,
            y: points[0].y,
            f: points[0].f,
            t: points[0].t
        });
        p0.prevPoint = null;
        vertices.push(p0);

        let tempPrevPoint = p0;

        for (let i = 0; i < points.length - 2; i++) {
            if (points.hasOwnProperty(i)) {

                const pA = points[i];
                const pB = points[i + 1];

                const D = getSpatialDistance(pA, pB);
                let d = D;
                while (d > r) {
                    const vh = ( r + ( D - d ) ) / D;// t not interpolated!! f not interpolated
                    const p = new Point({
                        did: pA.did,
                        x: (1 - vh) * pA.x + vh * pB.x,
                        y: (1 - vh) * pA.y + vh * pB.y,
                        f: pA.f,
                        t: pA.t
                    });
                    p.prevPoint = tempPrevPoint;
                    tempPrevPoint = p;

                    vertices.push(p);

                    d -= r;
                    r = R;
                }
                r -= d;
            }
        }
        return vertices;
    }
    function generateGrid(points) {

        const P = points;
        const G = {
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0,
            grid: []
        };
        for (let i in P) {
            if(P.hasOwnProperty(i)){
                for (let j in P[i]) {
                    if(P[i].hasOwnProperty(j)){
                        const p = P[i][j];
                        if (G.xMin > p.x) G.xMin = p.x;
                        if (G.xMax < p.x) G.xMax = p.x;
                        if (G.yMin > p.y) G.yMin = p.y;
                        if (G.yMax < p.y) G.yMax = p.y;
                    }
                }
            }
        }
        for (let x = G.xMin; x <= G.xMax; x += bd.maxRadius) {
            const gX = [];
            for (let y = G.yMin; y <= G.yMax; y += bd.maxRadius) {
                const gY = [];
                gX.push(gY);
            }
            G.grid.push(gX);
        }
        return G;
    }
    function seedCentroids(points, G) {
        const P = points;
        const R = []; //results

        P.forEach(function(t) {
            t.forEach(function(p) {
                putInProperGroup(p, R, G);
            });
        });
        return R;
    }
    function redistributePoints(P, R, G) {
        const originList = {};
        guiPar.redist.change = false;

        //--Remember number of members of each group, them remove members from group
        let r = 0;
        while(r < R.length) {
            if(R.hasOwnProperty(r)){
                originList[r] = R[r].members.length;
                R[r].members = [];
            }
            r++;
        }

        let cnt = 0;

        //--Assign every Point to a group
        P.forEach(function(t) {
            t.forEach(function(p) {

                let cent = getClosestCentroid(p, G);
                if (cent !== null) {// FEHLER! WARUM KANN c NULL SEIN? -> Kein centroid in reichweite

                    cent.cluster.addMember(p);

                } else {

                    data.clts.errors.push(p);
                    cnt++;
                }
            });
        });

        if(cnt !== 0) console.log('redistPoints: No Centroid found in ' + cnt + ' cases!');

        //test for changes
        r = 0;
        while(r < R.length) {
            if(R.hasOwnProperty(r)){
                if(originList[r] !== R[r].members.length) {
                    guiPar.redist.change = true;
                }
            }
            r++;
        }
    }

    function recalculateCentroids(R, G) {

        console.log('start' + R.length);

        const tempR = R;
        R = [];

        let cnt = 0;

        for(let r = 0; r < tempR.length; r++) {
            if(tempR.hasOwnProperty(r)){
                let clus = tempR[r];
                const cent = clus.centroid;
                let gc = getGridPosition(cent, G);

                const index = G.grid[gc.i][gc.j].indexOf(cent);
                G.grid[gc.i][gc.j].splice(index, 1);

                if(clus.members.length !== 0) {

                    clus.updateCentroid();

                    gc = getGridPosition(clus.centroid, G);
                    G.grid[gc.i][gc.j].push(clus.centroid);

                    R.push(clus);

                }
                //trying to remove/merge clusters with only 1 point
                /*else if(gr.members.length === 1) {

                    const p = gr.members[0];
                    let c = getClosestCentroid(p, G);
                    if(c !== null) {// FEHLER! WARUM KANN c NULL SEIN? -> Kein centroid in reichweite

                        const gr2 = c.g;//---------------------------------------------------
                        gr2.members.push(p);
                        gr2.members.forEach(function(point) {
                            point.c = c;
                            point.g = gr2;
                        });

                    } else {
                        data.clts.errors.push(p);
                        cnt++;
                    }

                }*/ else {
                    let k = 0;
                }
            }
        }
        console.log('end ' + R.length + ', Number of merged centroids: ' + cnt);

    }

    function putInProperGroup(p, R, G) {
        const cent = getClosestCentroid(p, G);
        let clus = new Cluster();
        let gc;

        if (cent === null) {
            clus.centroid = new Centroid({
                x: p.x,
                y: p.y,
                f: p.f,
                g: clus,
            });
            clus.addMember(p);
            //data.clts.centroids.push(clus.centroid);

            R.push(clus);
        } else {
            clus = cent.cluster; // g is group with centroid cent // indices? centroid array? -------------------------------

            gc = getGridPosition(cent, G);

            const index = G.grid[gc.i][gc.j].indexOf(cent);
            G.grid[gc.i][gc.j].splice(index, 1);

            clus.centroid = updateCentroid(cent, clus.members);
            clus.addMember(p);
        }
        gc = getGridPosition(clus.centroid, G);
        G.grid[gc.i][gc.j].push(clus.centroid);
    }
    function getClosestCentroid(p, G) {

        const gc = getGridPosition(p, G);
        const C = [];
        const range = 1;


        for(let k = Math.max(gc.i - range, 1);
            k < Math.min(gc.i + range, G.grid.length);
            k++) {

            for(let m = Math.max(gc.j - range, 1);
                m < Math.min(gc.j + range, G.grid[gc.i].length);
                m++) {

                for(let c in G.grid[k][m]) {
                    if(G.grid[k][m].hasOwnProperty(c)) {
                        if(((getSpatialDistance(p, G.grid[k][m][c])) <= bd.maxRadius) && (p.f === G.grid[k][m][c].f)) {
                            C.push(G.grid[k][m][c]);
                        }
                    }
                }
            }
        }

        if(C.length === 0) {
            return null;
        } else if(C.length === 1) {
            return C[0];
        } else {
            let ck = C[0];
            C.forEach(function(c) {
                if (getSpatialDistance(c, p) <= getSpatialDistance(ck, p)) {
                    ck = c;
                }
            });
            return ck;
        }
    }
    function getGridPosition(p, G) {
        return {
            i: Math.floor(( p.x - G.xMin ) / bd.maxRadius),
            j: Math.floor(( p.y - G.yMin ) / bd.maxRadius)
        };
    }
    function updateCentroid(centroid, points) {

        let sumX = 0;
        let sumY = 0;
        const numPoints = points.length;

        for (let p in points) {
            if(points.hasOwnProperty(p)){
                sumX += points[p].x;
                sumY += points[p].y;
            }
        }

        if (numPoints > 0) {
            centroid.x = sumX / numPoints;
            centroid.y = sumY / numPoints;
            return centroid;
        } else {
            return null;
        }
    }
    function getSpatialDistance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
    }

    function connectTheDots(clusters) {
        clusters.forEach(function(cluster) {
            const centroid = cluster.centroid;
            //centroid.color = Math.random() * par.ct.color + par.ct.corrColor;
//            centroid.prevCents = new Set();
//            centroid.nextCents = new Set();

            cluster.members.forEach(function (point) {
                if ((point.prevPoint !== null) && (point.prevPoint.c !== null)){
                    if((point.prevPoint.c !== point.c) && (point.prevPoint.c.f === point.c.f)) {
                        centroid.prevCents.add(point.prevPoint.c);
                    }
                }
                if ((point.nextPoint !== null) && (point.nextPoint.c !== null)){
                    if((point.nextPoint.c !== point.c) && (point.nextPoint.c.f === point.c.f)) {
                        centroid.nextCents.add(point.nextPoint.c);
                    }
                }
            });
        });
        clusters.forEach(function (cluster) {
            const centroid = cluster.centroid;
            centroid.nextCents.forEach(function(nextCentroid) {
                data.grph.edges.push({
                    start: centroid,
                    end: nextCentroid
                });
            });
        });
    }

    function rand_BoxMuller() {
        const u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1].
        const v = 1 - Math.random();
        return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    }
    function genBetterTrajs(trajs) {

        data.trjs.better = [];
        trajs.forEach(function (trajectory) {
            let tempTrajs = [];
            let tempTraj = new Trajectory([]);
            tempTraj.centroids.push(trajectory.points[0].centroid);

            //Points are not passed on to BetterTrajectories
            for(let i = 1; i < trajectory.points.length; i++) {
                if(trajectory.points[i-1].centroid !== trajectory.points[i].centroid) {
                    if(trajectory.points[i-1].centroid.f === trajectory.points[i].centroid.f) {
                        tempTraj.centroids.push(trajectory.points[i].centroid);
                    } else {
                        tempTrajs.push(tempTraj);
                        tempTraj = new Trajectory([]);
                        tempTraj.centroids.push(trajectory.points[i].centroid);
                    }
                }
            }
            tempTrajs.push(tempTraj);
            tempTrajs.forEach(function (tempTraj) {
                tempTraj.deviation = rand_BoxMuller();
                data.trjs.better.push(tempTraj);
            });
        });
    }
    function genEvenBetterTrajs(betterTrajs) {

        data.trjs.evenbetter = [];
        betterTrajs.forEach(function (trajectory) {

            let i = 0;

            trajectory.anchors.push(trajectory.centroids[i]);

            i++;

            if(trajectory.centroids.length > 2) {

                while (i < trajectory.centroids.length - 1) {

                    const p0 = trajectory.centroids[i - 1];
                    const p1 = trajectory.centroids[i];
                    const p2 = trajectory.centroids[i + 1];

                    let p1p0 = {x: p0.x - p1.x, y: p0.y - p1.y};
                    let p1p2 = {x: p2.x - p1.x, y: p2.y - p1.y};

                    let abs_p1p0 = Math.sqrt(p1p0.x * p1p0.x + p1p0.y * p1p0.y);
                    let abs_p1p2 = Math.sqrt(p1p2.x * p1p2.x + p1p2.y * p1p2.y);

                    let cos_p0p2 = ((p1p0.x * p1p2.x + p1p0.y * p1p2.y) / (abs_p1p0 * abs_p1p2));

                    //let alpha = ((cos_p0p2 + 1.0) / 2.0 + params.alpha) / (1.0 + params.alpha);
                    let alpha = (cos_p0p2 + 1.0) / 2.0;

                    //boundaries
                    let beta = Math.max(alpha, 0.5);
                    //beta = Math.min(beta, 0.95);

                    //beta = alpha;

                    const p01 = new Point({
                        x: (1 - beta) * p0.x + beta * p1.x,
                        y: (1 - beta) * p0.y + beta * p1.y,
                        f: p0.f
                    });
                    const p12 = new Point({
                        x: beta * p1.x + (1 - beta) * p2.x,
                        y: beta * p1.y + (1 - beta) * p2.y,
                        f: p1.f
                    });

                    trajectory.anchors.push(p01);
                    trajectory.anchors.push(p12);

                    i++;
                }
            }

            if(trajectory.centroids.length > 1){
                trajectory.anchors.push(trajectory.centroids[i]);
                data.trjs.evenbetter.push(trajectory);
            }
        });
    }

//--MAKE-(THREE.JS)-----------------------------------------------------------------------------------------------------

    function makeAllTrajectories() {

        if (bd.lineType === 'Point') {

            makePoints();

        } else if (bd.lineType === 'Line') {

            makeLine();

        } else if (bd.lineType === 'Clusters') {

            makeClusters();

        } else if (bd.lineType === 'Graph') {

            makeGraph();

        } else if (bd.lineType === 'Better') {

            makeBetter();

        } else if (bd.lineType === 'EvenBetter') {

            makeEvenBetter();
        }
    }

    function makePoints() {
        const tempTrajGeom = makePointGeometry(data.pnts);
        draw.pnts.push(createDots(tempTrajGeom, par.pt.color, par.pt.opacity, par.pt.dot.size));
    }
    function makeLine() {
        data.trjs.raw.forEach(function (traj) {
            const tempTrajGeom = makePointGeometry(traj.points);
            draw.trjs.raw.push(createLine(tempTrajGeom, traj.color, par.tj.opacity));
        });
    }
    function makeClusters() {
        cluster(data.trjs.raw);
        const drawStuff = makeClusteredGeom(data.clts);
        drawStuff.cents.forEach(function(cent) {
            draw.clts.centroids.push(cent);
        });
        drawStuff.circles.forEach(function(circle) {
            draw.clts.circles.push(circle);
        });
        drawStuff.points.forEach(function (pointGeom) {
            draw.clts.members.push(pointGeom);
        });

        draw.clts.errors.push(drawStuff.errors);

    } //ToDo: temp code inside--------------------------------------------------------------
    function makeGraph() {
        cluster(data.trjs.raw);
        connectTheDots(data.clts.clusters);
        const drawGraphStuff = makeGraphGeom(data.clts, data.grph);
        drawGraphStuff.cents.forEach(function (centGeom) {
            draw.clts.centroids.push(centGeom);
        });
        drawGraphStuff.edges.forEach(function (edgeGeom) {
            draw.grph.edges.push(edgeGeom);
        });
    }
    function makeBetter() {
        cluster(data.trjs.raw);
        genBetterTrajs(data.trjs.subsa);
        const drawBetterStuff = makeBetterGeom(data.clts, data.trjs.better);
        drawBetterStuff.cents.forEach(function (centGeom) {
            draw.clts.centroids.push(centGeom);
        });
        drawBetterStuff.trajs.forEach(function (trajGeom) {
            draw.trjs.better.push(trajGeom);
        });
    }
    function makeEvenBetter() {
        cluster(data.trjs.raw);
        genBetterTrajs(data.trjs.subsa);
        genEvenBetterTrajs(data.trjs.better);
        const drawBetterStuff = makeEvenBetterGeom(data.clts, data.trjs.evenbetter);
        drawBetterStuff.cents.forEach(function (centGeom) {
            draw.clts.centroids.push(centGeom);
        });
        drawBetterStuff.trajs.forEach(function (trajGeom) {
            draw.trjs.evenbetter.push(trajGeom);
        });
    }

    function makePointGeometry(points) {
        const pointsGeom = new THREE.Geometry();
        points.forEach(function(point) {
            pointsGeom.vertices.push(new THREE.Vector3(point.x, -point.y, point.f));
        });
        return pointsGeom;
    } //three.js
    function makeClusteredGeom(clts) {

        const centDots = [];
        const circleMeshes = [];
        const pointDots = [];

        clts.clusters.forEach(function(cluster) {
            const cent = cluster.centroid;
            const centGeom = makePointGeometry([cent]);
            centDots.push(createDots(centGeom, cluster.centroid.color, par.ct.opacity, par.ct.dot.size));

            const circleGeom = new THREE.CircleGeometry(bd.maxRadius / 2, 20);
            circleGeom.translate(cent.x, -cent.y, cent.f - 0.1);
            circleMeshes.push(createCircle(circleGeom, cluster.centroid.color, 0.2));

            const pointGeom = new THREE.Geometry();
            cluster.members.forEach(function(point) {
                pointGeom.vertices.push(new THREE.Vector3(point.x, -point.y, point.f));
            });
            pointDots.push(createDots(pointGeom, cluster.centroid.color, par.pt.opacity, par.pt.dot.size));

        });

        /* const centVect = centGeoms[g].vertices[0];
         const rainbowColor = new THREE.Color(
         (1 / bd.width) * centVect.x, //r
         (1 / bd.height) * -centVect.y, //g
         (1 / Math.abs(threePar.cam.near - threePar.cam.far)) * (centVect.z + 100) //b
         );*/

        const errorGeom = new THREE.Geometry();
        clts.errors.forEach(function(point) {
            errorGeom.vertices.push(new THREE.Vector3(point.x, -point.y, point.f));
        }); //temp

        const errorDots = createDots(errorGeom, 0x00ff00, par.pt.opacity, par.pt.dot.size); //temp


        return {
            cents: centDots,
            circles: circleMeshes,
            points: pointDots,
            errors: errorDots,
        };
    } //three.js
    function makeGraphGeom(clts, graph) {
        const centDots = [];
        const edgeLines = [];

        clts.clusters.forEach(function(cluster) {
            const centGeom = makePointGeometry([cluster.centroid]);
            centDots.push(createDots(centGeom, cluster.centroid.color, par.ct.opacity, par.ct.dot.size));
        });

        //const mat = new THREE.LineBasicMaterial({color: par.ln.color});
        const mat = new THREE.LineBasicMaterial({color: 0xffffff, vertexColors: THREE.VertexColors, shading: THREE.FlatShading});
        graph.edges.forEach(function(ge) {
            const edgeGeom = new THREE.Geometry();
            edgeGeom.vertices.push(new THREE.Vector3(ge.start.x, -ge.start.y, ge.start.f));
            edgeGeom.vertices.push(new THREE.Vector3(ge.end.x, -ge.end.y, ge.end.f));
            edgeLines.push(new THREE.LineSegments(edgeGeom, mat));
            edgeGeom.colors.push(new THREE.Color(ge.start.color));
            edgeGeom.colors.push(new THREE.Color(ge.end.color));
        });

        return {
            cents: centDots,
            edges: edgeLines
        };
    } //three.js
    function makeBetterGeom(clts, trajs) {
        const centDots = [];
        const trajLines = [];

        clts.clusters.forEach(function(cluster) {
            const centGeom = makePointGeometry([cluster.centroid]);
            centDots.push(createDots(centGeom, cluster.centroid.color, par.ct.opacity, par.ct.dot.size));
        });

        //const mat = new THREE.LineBasicMaterial({color: par.ln.color, opacity: par.ln.opacity, transparent: par.ln.transparency});
        const mat = new THREE.LineBasicMaterial({color: 0xffffff, vertexColors: THREE.VertexColors, shading: THREE.FlatShading,
            opacity: par.ln.opacity, transparent: par.ln.transparency});
        trajs.forEach(function (traj) {
            const trajGeom = new THREE.Geometry();
            traj.centroids.forEach(function(cent) {
                trajGeom.vertices.push(
                    new THREE.Vector3(
                        cent.x + traj.deviation * par.tj.deviationFactor,
                        -cent.y + traj.deviation * par.tj.deviationFactor,
                        cent.f));
                trajGeom.colors.push(new THREE.Color(cent.color));
            });
            trajLines.push(new THREE.Line(trajGeom, mat));
        });

        return {
            cents: centDots,
            trajs: trajLines
        };
    } //three.js
    function makeEvenBetterGeom(clts, trajs) {
        const centDots = [];
        const anchorGeoms = [];

        clts.clusters.forEach(function(cluster) {
            const centGeom = makePointGeometry([cluster.centroid]);
            centDots.push(createDots(centGeom, cluster.centroid.color, par.ct.opacity, par.ct.dot.size));
        });

        trajs.forEach(function(traj) {
            const anchorGeom = new THREE.Geometry();
            traj.anchors.forEach(function(point) {
                anchorGeom.vertices.push(
                    new THREE.Vector3(
                        point.x + traj.deviation * par.tj.deviationFactor,
                        -point.y + traj.deviation * par.tj.deviationFactor,
                        point.f));
            });
            anchorGeoms.push(anchorGeom);
        });

        //started to implement splines --> continue
        /*trajs.forEach(function (traj) {
         const anchorVertices = [];
         traj.anchors.forEach(function (point) {
         anchorVertices.push(
         new THREE.Vector3(
         point.x + traj.deviation * 0.25,
         point.y * -1 + traj.deviation * 0.25,
         point.f));
         });
         const anchorSpline = new THREE.SplineCurve3(anchorVertices);
         const path = new THREE.Path(anchorSpline.getPoints( 50 ));
         const anchorGeom = path.createPointsGeometry( 50 );
         anchorGeoms.push(anchorGeom);
         });*/

        //edges zeichnen
        const anchorLines = [];
        anchorGeoms.forEach(function(ag) {
            const curve = new THREE.CatmullRomCurve3(ag.vertices);
            let tempTrajGeom = new THREE.Geometry();
            tempTrajGeom.vertices = curve.getPoints(50);

            const mat = new THREE.LineBasicMaterial({color: par.ln.color, transparent: par.ln.transparency, opacity: par.ln.opacity});
            anchorLines.push(new THREE.Line(tempTrajGeom, mat));
        });

        return {
            cents: centDots,
            trajs: anchorLines
        };
    } //three.js

    function createDots(geom, color, opa, pointSize) {
        const mat = new THREE.PointsMaterial({color: color, opacity: opa, size: pointSize, sizeAttenuation: false});
        return new THREE.Points(geom, mat);
    } //three.js
    function createLine(geom, color, opa) {
        const mat = new THREE.LineBasicMaterial({color: color, opacity: opa});
        return new THREE.Line(geom, mat);
    } //three.js
    function createCircle(geom, color, opa) {
        const mat = new THREE.MeshBasicMaterial({color: color, opacity: opa, transparent: true});
        return new THREE.Mesh(geom, mat);
    } //three.js
//--ADD-&-REMOVE--------------------------------------------------------------------------------------------------------
//  ToDo: review lineTypes

    //--Meshes----------------------------------------------------------------------------------------------------------
    function hideAllBgMeshes() {
        for (let bgMesh in draw.bgMs) {
            if (draw.bgMs.hasOwnProperty(bgMesh)) {
                scene.remove(draw.bgMs[bgMesh]);
            }
        }
    } //three.js
    function removeAllBgMeshes() {
        hideAllBgMeshes();
        draw.bgMs = {};
    }
    function deleteAllBgMeshes() {
        removeAllBgMeshes();
        //data.bgMs = {};
    }

    //--Grids-----------------------------------------------------------------------------------------------------------
    function hideAllGrids() {
        for (let grid in draw.grds) {
            if (draw.grds.hasOwnProperty(grid)) {
                scene.remove(draw.grds[grid]);
            }
        }
    } //three.js
    function removeAllGrids() {
        hideAllGrids();
        draw.grds = {};
    }
    function deleteAllGrids() {
        removeAllGrids();
        data.grds = {};
    }

    //--Special-Trajectories--------------------------------------------------------------------------------------------
    function hideClusterTrajectories() {
        for(let t in draw.trjs.better) {
            scene.remove(draw.trjs.better[t]);
        }
        for(let t in draw.trjs.evenbetter) {
            scene.remove(draw.trjs.evenbetter[t]);
        }
        for(let c in draw.clts.centroids) {
            scene.remove(draw.clts.centroids[c]);
        }
        for(let ci in draw.clts.circles) {
            scene.remove(draw.clts.circles[ci]);
        }
        for(let m in draw.clts.members) {
            scene.remove(draw.clts.members[m]);
        }
        for(let er in draw.clts.errors) {
            scene.remove(draw.clts.errors[er]);
        }
        for(let e in draw.grph.edges) {
            scene.remove(draw.grph.edges[e]);
        }
    }
    function removeClusterTrajectories() {
        hideClusterTrajectories();

        //draw.pnts = data.pnts;
        draw.trjs = {
            raw: draw.trjs.raw,
            subsa: [],
            better: [],
            evenbetter: []
        };
        draw.clts = {
            centroids: [],
            circles: [],
            members: [],
            errors: [],
        };
        draw.grph = {
            edges: []
        };
    }
    function deleteClusterTrajectories() {
        removeClusterTrajectories();
        //data.pnts = data.pnts;
        data.trjs = {
            raw: data.trjs.raw,
            subsa: [],
            better: [],
            evenbetter: []
        };
        data.clts = {
            clusters: [],
            centroids: [],
            circles: [],
            members: [],
            errors: [],
        };
        data.grph = {
            edges: []
        };
    }

    //--All-Trajectories------------------------------------------------------------------------------------------------
    function addAllTrajectories() { //abgesehen von clusters
        if (bd.lineType === 'Point') {
            draw.pnts.forEach(function(point) {
                scene.add(point);
            });
        } else if (bd.lineType === 'Line') {
            draw.trjs.raw.forEach(function(traj) {
                scene.add(traj);
            });
        } else if(bd.lineType === 'Clusters') {
            draw.clts.centroids.forEach(function(cent) {
                scene.add(cent);
            });
            draw.clts.circles.forEach(function(circle) {
                scene.add(circle);
            });
            draw.clts.members.forEach(function(point) {
                scene.add(point);
            });
            draw.clts.errors.forEach(function(error) {
                scene.add(error);
            }); //temp
        } else if(bd.lineType === 'Graph') {
            draw.clts.centroids.forEach(function(cent) {
                scene.add(cent);
            });
            draw.grph.edges.forEach(function(edge) {
                scene.add(edge);
            });
        } else if(bd.lineType === 'Better') {
            draw.clts.centroids.forEach(function(cent) {
                scene.add(cent);
            });
            draw.trjs.better.forEach(function(traj) {
                scene.add(traj);
            });
        } else if(bd.lineType === 'EvenBetter') {
            draw.clts.centroids.forEach(function(cent) {
                scene.add(cent);
            });
            draw.trjs.evenbetter.forEach(function(traj) {
                scene.add(traj);
            });
        }
    } //three.js

    function hideAllTrajectories() {
        hideClusterTrajectories();
        for(let p in draw.pnts) {
            scene.remove(draw.pnts[p]);
        }
        for(let t in draw.trjs.raw) {
            scene.remove(draw.trjs.raw[t]);
        }
    } //three.js
    function removeAllTrajectories() {
        hideAllTrajectories();
        removeClusterTrajectories();
        draw.pnts = [];
        draw.trjs.raw = [];
    }
    function deleteAllTrajectories() {
        removeAllTrajectories();
        deleteClusterTrajectories();
        data.pnts = [];
        data.trjs.raw = [];
    }

    //--All-------------------------------------------------------------------------------------------------------------
    function hideAll() {
         hideAllBgMeshes();
         hideAllGrids();
         hideAllTrajectories();
    }
    function removeAll(){
        removeAllBgMeshes();
        removeAllGrids();
        removeAllTrajectories();
    }
    function deleteAll() {
        deleteAllBgMeshes();
        deleteAllGrids();
        deleteAllTrajectories();
    }

//--CHANGE--------------------------------------------------------------------------------------------------------------
//  ToDo: review changeClusterRadius

    function changeScale() {
        deleteAllBgMeshes();
        deleteAllGrids();
        loadNewBgMesh(bd.path, bd.floor); //also invokes loadNewGrid();
        addAllTrajectories();
    }
    function changeFloors() {
        if (!(draw.bgMs[bd.floor] instanceof THREE.Mesh)) {
            loadNewBgMesh(bd.path, bd.floor); //also invokes loadGrid()
        }
        updateCamera();
        updateRaycaster();
    }
    function changeLineType() {

        hideAllTrajectories();
        if(bd.lineType === 'Point'){
            if(draw.pnts.length === 0){
                makeAllTrajectories();
            }
        } else if (bd.lineType === 'Line') {
            if(draw.trjs.raw.length === 0){
                makeAllTrajectories();
            }
        } else if(bd.lineType === 'Clusters') {
            if((draw.clts.centroids.length === 0) ||
                (draw.clts.circles.length === 0) ||
                (draw.clts.members.length === 0)) {
                deleteClusterTrajectories();
                makeAllTrajectories();
            }
        } else if(bd.lineType === 'Graph') {
            if((draw.clts.centroids.length === 0) ||
                (draw.grph.edges.length === 0)) {
                deleteClusterTrajectories();
                makeAllTrajectories();
            }
        } else if(bd.lineType === 'Better') {
            if((draw.clts.centroids.length === 0) ||
                (draw.trjs.better.length === 0)) {
                deleteClusterTrajectories();
                makeAllTrajectories();
            }
        } else if(bd.lineType === 'EvenBetter') {
            if((draw.clts.centroids.length === 0) ||
                (draw.trjs.evenbetter.length === 0)) {
                deleteClusterTrajectories();
                makeAllTrajectories();
            }
        }
        addAllTrajectories();
    }
    function changeClusterRadius() {
        hideAllTrajectories();
        deleteClusterTrajectories();
        makeAllTrajectories();
        addAllTrajectories();
    }

</script>
</body>
</html>