<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TrajTool</title>
    <style>
        body { margin: 0; overflow: hidden }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>
<!--Trajectory viewer-->
<script>

//--CONSTANTS-&-VARIABLES-----------------------------------------------------------------------------------------------

    let camera, scene, renderer;
    let mouse, raycaster;
    let gui;
    let buildingFileClicker, trajectoryFileClicker;

    const threePar = {
        cam: {
            near: -100.0,
            far: 100.0,
        },
        rend: {
            aa: true,
            alpha: true,
            color: 0xffffff,
            alphaVal: 0.0,
        },
        rayc: {
            linePrec: 1,
        },
    };
    const guiPar = {
        bgLoader: {
            path: {
                init: 'LUCI-neu-',
            },
            ext: {
                init: '.png',
            },
            name: 'Load building',
        },
        scale: {
            min: 45.0,
            max: 100.0,
            step: 1.0,
            init: 49.0,
            name: 'Scale (1:X)',
        },
        floor: {
            min: -2.0,
            max: 2.0,
            step: 1.0,
            init: 1.0,
            name: 'Floor',
        },
        dataLoader: {
            name: 'Load trajectories',
        },
        lineType: {
            init: 'Point',
            choices: [
                'Point', 'Line', 'Clusters', 'Graph', 'Better', 'EvenBetter'
            ],
            name: 'Line type',
        },
        cMaxRad: {
            min: 5.0,
            max: 50.0,
            step: 5.0,
            init: 20.0,
            name: 'Radius',
        },
    };
    const par = {
        tj: {
            color: 0xff0000,
            clickColor: 0x000000,
            cutTime: 20000.0,
            dot: {
                size: 3.5,
            },
        },
        pt: {
            color: 0xff0000,
            dot: {
                size: 3.5,
            },
        },
        ct: {
            dot: {
                size: 10.0,
            },
        },
        bg: {
            dir: 'img/',
            corrZ: -0.4,
        },
        gd: {
            delta: 5.0,
            corrZ: 0.4,
            line: {
                color: 0x555555,
                opacity: 1,
            }
        },
        csv: {
            header: 't,x,y,acc,f,did',
        },
        //tj = trajectory; pt = point; ct = centroid; bg = background; gd = grid
    };

    const bd = {
        w: window.innerWidth, //building width
        wListener: function () {},
        get width() {
            return this.w;
        },
        set width(val) {
            this.w = val;
            this.wListener(val)
        },
        registerWListener: function (listener) {
            this.hListener = listener;
        },

        h: window.innerHeight, //building height
        hListener: function () {},
        get height() {
            return this.h;
        },
        set height(val) {
            this.h = val;
            this.hListener(val);
        },
        registerHListener: function (listener) {
            this.wListener = listener;
        },

        get ratio() {
            return this.w / this.h;
        },

        f: guiPar.floor.init, //building floor
        fListener: function () {},
        get floor() {
            return this.f;
        },
        set floor(val) {
            if (val !== this.f) {
                this.f = val;
                this.fListener(val);
            }
        },
        registerFListener: function (listener) {
            this.fListener = listener;
        },

        s: guiPar.scale.init, //building scale
        sListener: function () {},
        get scale() {
            return this.s;
        },
        get scaleFraction() {
            return ( 1 / this.s );
        },
        set scale(val) {
            if (val !== this.s) {
                this.s = val;
                this.sListener(val);
            }
        },
        registerSListener: function (listener) {
            this.sListener = listener;
        },

        filePath: guiPar.bgLoader.path.init,
        fileExt: guiPar.bgLoader.ext.init,
        get path() {
            return this.filePath + this.f + this.fileExt;
        },

        lt: guiPar.lineType.init, //trajectory linetype
        ltListener: function () {},
        get lineType() {
            return this.lt;
        },
        set lineType(val) {
            if (val !== this.lt) {
                this.lt = val;
                this.ltListener(val);
            }
        },
        registerLtListener: function (listener) {
            this.ltListener = listener;
        },

        mR: guiPar.cMaxRad.init, //cluster maxRadius
        mRListener: function () {},
        get maxRadius() {
            return this.mR;
        },
        set maxRadius(val) {
            if (val !== this.mR) {
                this.mR = val;
                this.mRListener(val);
            }
        },
        registerMRListener: function (listener) {
            this.mRListener = listener;
        }
    };
    bd.registerWListener(function () {
        updateCamera(bd.floor);
        updateRenderer();
    });
    bd.registerHListener(function () {
        updateCamera(bd.floor);
        updateRenderer();
    });
    bd.registerFListener(function () {
        changeFloors(bd.floor);
    });
    bd.registerSListener(function () {
        changeScale();
    });
    bd.registerLtListener(function () {
        changeLineType();
    });
    bd.registerMRListener(function () {
        changeClusterRadius();
    });

    const data = {
        grds: {},

        pnts: [],
        trjs: {
            raw: [],
            subsa: [],
            better: [],
            evenbetter: []
        },
        clts: {
            centroids: [],
            points: []
        },
        grph: {
            edges: []
        },
        cnts: [],
    };
    const draw = {
        bgMs: {},
        grds: {},

        pnts: [],
        trjs: {
            raw: [],
            subsa: [],
            better: [],
            evenbetter: []
        },
        clts: {
            centroids: [],
            points: []
        },
        grph: {
            edges: []
        }
    };

    const Point = function(point) {
        this.color = par.pt.color;
        this.did = point.did;
        this.x = point.x;
        this.y = point.y;
        this.f = point.f;
        this.t = point.t;
        this.c = null;
        this.g = null;
        this.prevPoint = null;
        this.nextPoint = null;
    };
    const Trajectory = function(points) {
        this.color = par.tj.color;
        this.points = points;
        this.deviation = 0;
        this.centroids = [];
        this.anchors = [];
    };
    const Centroid = function(c) {
        this.x = c.x;
        this.y = c.y;
        this.f = c.f;
        this.g = c.g;
        this.color = Math.random() * 0xffffff;
    };

//--START---------------------------------------------------------------------------------------------------------------

    init();
    initRaycaster();
    update();

//--INITALIZATION-------------------------------------------------------------------------------------------------------
//  ToDo: Review init function (camera?)

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(0, 0, 0, 0, 0, 0, 0);
        initRenderer();
        initCamera();
        initRaycaster();
        initBackgroundFileInput();
        initDataFileInput();
        initDatGUI();
        initWindowResizeListeners();
    }

    function initRenderer() {
        renderer = new THREE.WebGLRenderer({antialias: threePar.rend.aa, alpha: threePar.rend.alpha});
        renderer.setClearColor(threePar.rend.color, threePar.rend.alphaVal);//        renderer.setPixelRatio( window.devicePixelRatio ) ;
        document.body.appendChild(renderer.domElement);
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function initCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera = new THREE.OrthographicCamera(0, bd.width,
                0, -bd.width / windowRatio, threePar.cam.near, threePar.cam.far);
        } else {
            camera = new THREE.OrthographicCamera(0, bd.height * windowRatio,
                0, -bd.height, threePar.cam.near, threePar.cam.far);
        }
        camera.updateProjectionMatrix();
    } //three.js
    function updateRenderer() {
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function updateCamera(floor) {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera.right = bd.width;
            camera.bottom = -bd.width / windowRatio;
            camera.near = -(floor + par.gd.corrZ);
        } else {
            camera.right = bd.height * windowRatio;
            camera.bottom = -bd.height;
            camera.near = -(floor + par.gd.corrZ);
        }
        camera.updateProjectionMatrix();
//        if( camerahelper ) {
//            camerahelper.update();
//        }
    } //three.js

    function update() {
        requestAnimationFrame(update);
        renderer.render(scene, camera);
    } //three.js

    function initRaycaster() {
        raycaster = new THREE.Raycaster();
        raycaster.near = threePar.cam.near;
        raycaster.far = threePar.cam.far;
        raycaster.linePrecision = threePar.rayc.linePrec;
        mouse = new THREE.Vector2();
        window.addEventListener('click', onMouseClick, false);
    } //three.js
    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        let intersects = [];
        scene.children.forEach(function (ch){
            intersects.push(raycaster.intersectObject(ch, false))
        });

        for(let int in intersects){
            if(intersects[int].length !== 0){
                const obj = intersects[int][0].object;
                if(obj.type === 'Line'){
                    if(obj.material.color.r === 1){
                        obj.material.color = new THREE.Color(par.tj.clickColor);
                    } else if(obj.material.color.r === 0){
                        obj.material.color = new THREE.Color(par.tj.color);
                    }
                    obj.material.needsUpdate = true;
                }
            }
        }
    } //temp code inside

    function initWindowResizeListeners() {
        window.addEventListener('resize', onWindowResize, false);
    }
    function onWindowResize() {
        updateRenderer();
        updateCamera(bd.floor);
    }

    function initBackgroundFileInput() {
        const buildingFileInput = document.createElement('input');
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.accept = "image/*";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        document.body.appendChild(buildingFileInput);

        buildingFileInput.addEventListener('change', function () {
            const file = buildingFileInput.files[0];
            const fileName = buildingFileInput.files[0].name;
            const fileType = /image.*/;

            if(file.type.match(fileType)) {
                bd.filePath = fileName.slice(0, -5);
                bd.fileExt = fileName.slice(-4, fileName.length);
                deleteAll();
                changeFloors(bd.floor);
            } else {
                alert("File not supported");
            }
        });
        buildingFileClicker = {
            loadBuildingFile: function () {
                document.getElementById("buildingFileInput").click();
            }
        };
    }
    function initDataFileInput() {
        const dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild(dataFileInput);

        dataFileInput.addEventListener('change', function () {
            const fileCount = dataFileInput.files.length;
            const result = [];
            for(let file = 0; file < fileCount; file++) {
                const reader = new FileReader();
                reader.onload = function () {
                    result.push(this.result);
                    if (result.length === fileCount) {
                        loadNewTrajectories(result);
                        makeAllTrajectories();
                        addAllTrajectories();
                    }
                };
                reader.readAsText(dataFileInput.files[file]);
            }
            this.value = null; //remove filename from input
        });
        trajectoryFileClicker = {
            loadDataFile: function () {
                document.getElementById("dataFileInput").click();
            }
        };
    }

    function initDatGUI() {
        gui = new dat.GUI();
        gui.add(buildingFileClicker, 'loadBuildingFile').name(guiPar.bgLoader.name);
        gui.add(bd, 'scale', guiPar.scale.min, guiPar.scale.max).step(guiPar.scale.step).name(guiPar.scale.name);
        gui.add(bd, 'floor', guiPar.floor.min, guiPar.floor.max).step(guiPar.floor.step).name(guiPar.floor.name);
        gui.add(trajectoryFileClicker, 'loadDataFile').name(guiPar.dataLoader.name);
        gui.add(bd, 'lineType', guiPar.lineType.choices).name(guiPar.lineType.name);
        gui.add(bd, 'maxRadius', guiPar.cMaxRad.min, guiPar.cMaxRad.max).step(guiPar.cMaxRad.step).name(guiPar.cMaxRad.name);
    } //dat.gui

//--LOAD-BASICS---------------------------------------------------------------------------------------------------------

    function loadNewBgMesh(buildingName, floor) {
        const buildingPath = par.bg.dir + buildingName;
        let backgroundMesh;
        let bgMaterial = new THREE.MeshBasicMaterial();

        const bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            function (texture) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //translate pixels into meters -- ATTENTION! BG-imgs have to have same size!
                bd.width = texture.image.naturalWidth * bd.scaleFraction;
                bd.height = texture.image.naturalHeight * bd.scaleFraction;

                //create bgPlane
                const backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push(new THREE.Vector3(0, 0, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(0, -bd.height, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, -bd.height, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, 0, floor + par.bg.corrZ));

                backgroundPlane.faces.push(new THREE.Face3(0, 1, 3));
                backgroundPlane.faces.push(new THREE.Face3(1, 2, 3));//backgroundPlane.computeFaceNormals();
                backgroundPlane.faceVertexUvs[0] = [];
                backgroundPlane.faceVertexUvs[0].push([new THREE.Vector2(0, 1),
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );

                draw.bgMs[floor] = backgroundMesh;
                scene.add(draw.bgMs[floor]);

                genGrid(floor);
                drawGrid(floor);
            },
            function () {
            },
            function () {
                console.log('BG-loading failed');
            }
        );
    } //three.js
    function genGrid(floor) {

        let coordLines = [];

        for (let i = 0; i < ( bd.height ); i += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: 0,
                    y: i,
                    f: floor + par.gd.corrZ,
                },
                p1: {
                    x: bd.width,
                    y: i,
                    f: floor + par.gd.corrZ,
                }
            });
        }
        for (let j = 0; j < ( bd.width ); j += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: j,
                    y: 0,
                    f: floor + par.gd.corrZ,
                },
                p1: {
                    x: j,
                    y: bd.height,
                    f: floor + par.gd.corrZ,
                }
            });
        }
        data.grds[floor] = coordLines;
    }
    function drawGrid(floor) {

        const coordGeometry = new THREE.Geometry();
        data.grds[floor].forEach(function(line) {
            coordGeometry.vertices.push(new THREE.Vector3(line.p0.x, -line.p0.y, line.p0.f));
            coordGeometry.vertices.push(new THREE.Vector3(line.p1.x, -line.p1.y, line.p1.f));
        });

        const coordMaterial = new THREE.LineBasicMaterial({
            color: par.gd.line.color,
            opacity: par.gd.line.color,
        });

        draw.grds[floor] = new THREE.LineSegments(coordGeometry, coordMaterial);
        //scene.add(draw.grds[floor]);
    } //three.js -- disabled

//--LOAD-TRAJECTORIES---------------------------------------------------------------------------------------------------
//  ToDo: Implement function for removing first and last locations of recording

    function loadNewTrajectories(readerResult) {

        let pointList = [];

    //--create-Point-Objects--------------------------------------------------------------------------------------------
        readerResult.forEach(function(file){
            const tempList = parseCSV(file);

            tempList.forEach(function (point) {
                const p = new Point(point);
                pointList.push(p);
                data.pnts.push(p);
            });
        });

    //--sort-Points-----------------------------------------------------------------------------------------------------
        pointList = sortPoints(pointList);

        const pointListByDID = groupPointListByDid(pointList);
        const pointListByDIDByTime = [];

        for (let did1 in pointListByDID) {
            if(pointListByDID.hasOwnProperty(did1)){
                pointListByDIDByTime[did1] = groupPointListByTime(pointListByDID[did1]);
            }
        }

    //--create-Trajectories---------------------------------------------------------------------------------------------
        for(let did2 in pointListByDIDByTime) {
            for(let pointGroup in pointListByDIDByTime[did2]) {
                if (pointListByDIDByTime[did2].hasOwnProperty(pointGroup)) {

                    const tempTrajectory = new Trajectory(pointListByDIDByTime[did2][pointGroup]);

                    if(tempTrajectory.points.length > 1) {

                        let tempPrevPoint = tempTrajectory.points[0];
                        tempPrevPoint.prevPoint = null;

                        for(let p = 0; p < tempTrajectory.points.length; p++){
                            tempPrevPoint.nextPoint = tempTrajectory.points[p];
                            tempTrajectory.points[p].prevPoint = tempPrevPoint;
                            tempPrevPoint = tempTrajectory.points[p];
                        }
                        data.trjs.raw.push(tempTrajectory);
                    }
                }
            }
        }
    }

    function parseCSV(csvString) {
        const parseResult = Papa.parse(csvString, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            comments: '#',
            //step: true,
            beforeFirstChunk: function (chunk) {
                const rows = chunk.split(/\r\n|\r|\n/);
                rows[0] = par.csv.header;
                return rows.join("\r\n");
            }
        });
        return parseResult.data;
    }
    function sortPoints(pointList) {
    pointList.sort(
        firstBy("did")
            .thenBy("t")
    );
    return pointList;
}
    function groupPointListByDid(pointList) {
        return groupBy(pointList, function (item) {
                return [item.did]; //, item.t
            }
        );
    }
    function groupPointListByTime(pointList) {

        const pointListByTime = [];

        let tempTime = pointList[0].t;
        let tempTimeArray = [];

        pointList.forEach(function(point) {
            if (tempTime + par.tj.cutTime < point.t) {
                pointListByTime.push(tempTimeArray);
                tempTimeArray = [];
                tempTimeArray.push(point);
                tempTime = point.t;
            } else {
                tempTimeArray.push(point);
                tempTime = point.t;
            }
        });
        pointListByTime.push(tempTimeArray);
        return pointListByTime;
    }
    function groupBy(array, f) {

        const groups = {};
        array.forEach(
            function (object) {
                const group = JSON.stringify(f(object));
                groups[group] = groups[group] || []; //if groups[group] doesn't exist, [] is assigned
                groups[group].push(object);
            }
        );
        return groups;
    }

//--CLUSTERING----------------------------------------------------------------------------------------------------------
//  ToDo: data.clts.points.push(cluster.members) --> change .points. to .members

    function cluster(trajs) {
        const vertices = [];
        trajs.forEach(function(traj) {
            //subsampling
            const points = traj.points;
            const tempTraj = new Trajectory(subsamplePoints(points));
            data.trjs.subsa.push(tempTraj);
            vertices.push(tempTraj.points);
        });
        //centroid seed
        const R = seedAndRedistCentroids(vertices);
        R.forEach(function(cluster) {
            data.clts.centroids.push(cluster.centroid);
            data.clts.points.push(cluster.members);
        });
    }

    function subsamplePoints(points) {
        const vertices = [];//R = Radius for subsampling, r = radius remaining for next segment, i = iterator, p0 = first point of traj, //pA and pB are start and end of segment to be subsampled, D = dist between pA and pB, d = remaining distance
        //p = subsampled point, vh = ratio of _________ (?),

        const R = 3;
        let r = R;

        const p0 = new Point({
            did: points[0].did,
            x: points[0].x,
            y: points[0].y,
            f: points[0].f,
            t: points[0].t
        });
        p0.prevPoint = null;
        vertices.push(p0);

        let tempPrevPoint = p0;

        for (let i = 0; i < points.length - 2; i++) {
            if (points.hasOwnProperty(i)) {

                const pA = points[i];
                const pB = points[i + 1];

                const D = getSpatialDistance(pA, pB);
                let d = D;
                while (d > r) {
                    const vh = ( r + ( D - d ) ) / D;// t not interpolated!!
                    const p = new Point({
                        did: pA.did,
                        x: ( 1 - vh ) * pA.x + vh * pB.x,
                        y: ( 1 - vh ) * pA.y + vh * pB.y,
                        f: pA.f,
                        t: pA.t
                    });
                    tempPrevPoint.nextPoint = p;
                    p.prevPoint = tempPrevPoint;
                    tempPrevPoint = p;

                    vertices.push(p);

                    d -= r;
                    r = R;
                }
                r -= d;
            }
        }
        return vertices;
    }
    function seedAndRedistCentroids(points) {

        const P = points;

        //grid
        const G = {
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0,
            grid: []
        };
        for (let i in P) {
            if(P.hasOwnProperty(i)){
                for (let j in P[i]) {
                    if(P[i].hasOwnProperty(j)){
                        const p = P[i][j];
                        if (G.xMin > p.x) G.xMin = p.x;
                        if (G.xMax < p.x) G.xMax = p.x;
                        if (G.yMin > p.y) G.yMin = p.y;
                        if (G.yMax < p.y) G.yMax = p.y;
                    }
                }
            }
        }
        for (let x = G.xMin; x <= G.xMax; x += bd.maxRadius) {
            const gX = [];
            for (let y = G.yMin; y <= G.yMax; y += bd.maxRadius) {

                const gY = [];
                gX.push(gY);
            }
            G.grid.push(gX);
        }

        const R = []; //results

        for (let i in P) {
            if(P.hasOwnProperty(i)){
                for (let j in P[i]) {
                    if (P[i].hasOwnProperty(j)) {
                        putInProperGroup(P[i][j], R, G);
                    }
                }
            }
        }
        redistributePoints(P, R, G);

        return R; //change to R later
    }
    function putInProperGroup(p, R, G) {
        const c = getClosestCentroid(p, G);
        let gr = {
            centroid: {},
            members: []
        };
        let gc;

        if (c === null) {

            gr.centroid = new Centroid({
                x: p.x,
                y: p.y,
                f: p.f,
                g: gr,
            });
            p.c = gr.centroid;
            gr.members.push(p);
            data.clts.centroids.push(gr.centroid);

            R.push(gr);
        } else {
            gr = c.g; // g is group with centroid c // indices? centroid array? -------------------------------
            gc = getGridPosition(c, G);

            const index = G.grid[gc.i][gc.j].indexOf(c);
            G.grid[gc.i][gc.j].splice(index, 1);

            gr.centroid = updateCentroid(c, gr.members);
            gr.centroid.g = gr;
            p.c = gr.centroid;
            gr.members.push(p);
        }
        gc = getGridPosition(gr.centroid, G);
        G.grid[gc.i][gc.j].push(gr.centroid);
    }
    function getClosestCentroid(p, G) {

        const gc = getGridPosition(p, G);
        const C = [];
        for (let k = Math.max(gc.i - 1, 1); k < Math.min(gc.i + 1, G.grid.length); k++) {
            for (let m = Math.max(gc.j - 1, 1); m < Math.min(gc.j + 1, G.grid[gc.i].length); m++) {
                for (let c in G.grid[k][m]) {
                    if (G.grid[k][m].hasOwnProperty(c)) {
                        if ((getSpatialDistance(p, G.grid[k][m][c]) <= bd.maxRadius )
                            && p.f === G.grid[k][m][c].f) {
                            C.push(G.grid[k][m][c]);
                        }
                    }
                }
            }
        }
        if (C.length === 0) {
            return null;
        } else if (C.length === 1) {
            return C[0];
        } else {
            let ck = C[0];

            for (let l in C) {
                if (getSpatialDistance(C[l], p) <= getSpatialDistance(ck, p)) {
                    ck = C[l];
                }
            }
            return ck;
        }
    }
    function getGridPosition(p, G) {
        return {
            i: Math.floor(( p.x - G.xMin ) / bd.maxRadius),
            j: Math.floor(( p.y - G.yMin ) / bd.maxRadius)
        };
    }
    function redistributePoints(P, R, G) {
        for (let r in R) {
            if(R.hasOwnProperty(r)){
                R[r].members = [];
            }
        }
        for (let i in P) {
            if(P.hasOwnProperty(i)){
                for (let j in P[i]) {
                    if (P[i].hasOwnProperty(j)) {
                        const c = getClosestCentroid(P[i][j], G);
                        if (c !== null) {// FEHLER! WARUM KANN c NULL SEIN? -> Kein centroid in reichweite
                            const gr = c.g;//---------------------------------------------------
                            gr.members.forEach(function (point) {
                                point.c = c;
                                point.g = gr;
                            });
                            gr.members.push(P[i][j]);
                        }
                    }
                }
            }
        }
    }
    function updateCentroid(centroid, points) {

        let sumX = 0;
        let sumY = 0;
        const numPoints = points.length;

        for (let p in points) {
            if(points.hasOwnProperty(p)){
                sumX += points[p].x;
                sumY += points[p].y;
            }
        }

        if (numPoints > 0) {
            centroid.x = sumX / numPoints;
            centroid.y = sumY / numPoints;
            return centroid;
        } else {
            return null;
        }
    }

    function getSpatialDistance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
    }

    function connectTheDots(centroids) {
        centroids.forEach(function (centroid) {

            centroid.prevCents = new Set();
            centroid.nextCents = new Set();

            centroid.g.members.forEach(function (point) {
                if ((point.prevPoint !== null) && (point.prevPoint.c !== null)){
                    if((point.prevPoint.c !== point.c) && (point.prevPoint.c.f === point.c.f)) {
                        centroid.prevCents.add(point.prevPoint.c);
                    }
                }
                if ((point.nextPoint !== null) && (point.nextPoint.c !== null)){
                    if((point.nextPoint.c !== point.c) && (point.nextPoint.c.f === point.c.f)) {
                        centroid.nextCents.add(point.nextPoint.c);
                    }
                }
            });
        });

        centroids.forEach(function (centroid) {
            centroid.nextCents.forEach(function (nextCentroid) {
                data.grph.edges.push({
                    start: centroid,
                    end: nextCentroid
                });
            });
        });
    }

    function rand_BoxMuller() {
        const u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1].
        const v = 1 - Math.random();
        return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    }
    function genBetterTrajs(trajs) {

        data.trjs.better = [];
        trajs.forEach(function (trajectory) {
            let tempTrajs = [];
            let tempTraj = new Trajectory([]);
            tempTraj.centroids.push(trajectory.points[0].c);

            //Points are not passed on to BetterTrajectories
            for(let i = 1; i < trajectory.points.length; i++) {
                if(trajectory.points[i-1].c !== trajectory.points[i].c) {
                    if(trajectory.points[i-1].c.f === trajectory.points[i].c.f) {
                        tempTraj.centroids.push(trajectory.points[i].c);
                    } else {
                        tempTrajs.push(tempTraj);
                        tempTraj = new Trajectory([]);
                        tempTraj.centroids.push(trajectory.points[i].c);
                    }
                }
            }
            tempTrajs.push(tempTraj);
            tempTrajs.forEach(function (tempTraj) {
                tempTraj.deviation = rand_BoxMuller();
                data.trjs.better.push(tempTraj);
            });
        });
    }
    function genEvenBetterTrajs(betterTrajs) {

        data.trjs.evenbetter = [];
        betterTrajs.forEach(function (trajectory) {

            let i = 0;

            trajectory.anchors.push(trajectory.centroids[i]);

            i++;

            if(trajectory.centroids.length > 2) {

                while (i < trajectory.centroids.length - 1) {

                    const p0 = trajectory.centroids[i - 1];
                    const p1 = trajectory.centroids[i];
                    const p2 = trajectory.centroids[i + 1];

                    let p1p0 = {x: p0.x - p1.x, y: p0.y - p1.y};
                    let p1p2 = {x: p2.x - p1.x, y: p2.y - p1.y};

                    let abs_p1p0 = Math.sqrt(p1p0.x * p1p0.x + p1p0.y * p1p0.y);
                    let abs_p1p2 = Math.sqrt(p1p2.x * p1p2.x + p1p2.y * p1p2.y);

                    let cos_p0p2 = ((p1p0.x * p1p2.x + p1p0.y * p1p2.y) / (abs_p1p0 * abs_p1p2));

                    //let alpha = ((cos_p0p2 + 1.0) / 2.0 + params.alpha) / (1.0 + params.alpha);
                    let alpha = (cos_p0p2 + 1.0) / 2.0;

                    //boundaries
                    let beta = Math.max(alpha, 0.5);
                    //beta = Math.min(beta, 0.95);

                    //beta = alpha;

                    const p01 = new Point({
                        x: (1 - beta) * p0.x + beta * p1.x,
                        y: (1 - beta) * p0.y + beta * p1.y,
                        f: p0.f
                    });
                    const p12 = new Point({
                        x: beta * p1.x + (1 - beta) * p2.x,
                        y: beta * p1.y + (1 - beta) * p2.y,
                        f: p1.f
                    });

                    trajectory.anchors.push(p01);
                    trajectory.anchors.push(p12);

                    i++;
                }
            }

            if(trajectory.centroids.length > 1){
                trajectory.anchors.push(trajectory.centroids[i]);
                data.trjs.evenbetter.push(trajectory);
            }
        });
    }

//--MAKE-(THREE.JS)-----------------------------------------------------------------------------------------------------

    function makeAllTrajectories() {

        if (bd.lineType === 'Point') {

            makePoints();

        } else if (bd.lineType === 'Line') {

            makeLine();

        } else if (bd.lineType === 'Clusters') {

            makeClusters();

        } else if (bd.lineType === 'Graph') {

            makeGraph();

        } else if (bd.lineType === 'Better') {

            makeBetter();

        } else if (bd.lineType === 'EvenBetter') {

            makeEvenBetter();
        }
    }

    function makePoints() {
        const tempTrajGeom = makePointGeometry(data.pnts);
        draw.pnts.push(createDots(tempTrajGeom, par.pt.color, par.pt.dot.size));
    }
    function makeLine() {
        data.trjs.raw.forEach(function (traj) {
            const tempTrajGeom = makePointGeometry(traj.points);
            draw.trjs.raw.push(createLine(tempTrajGeom, traj.color));
        });
    }
    function makeClusters() {
        cluster(data.trjs.raw);
        const drawStuff = makeClusteredGeom(data.clts);
        drawStuff.cents.forEach(function (centGeom) {
            draw.clts.centroids.push(centGeom);
        });
        drawStuff.points.forEach(function (pointGeom) {
            draw.clts.points.push(pointGeom);
        });
    }
    function makeGraph() {
        cluster(data.trjs.raw);
        connectTheDots(data.clts.centroids);
        const drawGraphStuff = makeGraphGeom(data.clts, data.grph);
        drawGraphStuff.cents.forEach(function (centGeom) {
            draw.clts.centroids.push(centGeom);
        });
        drawGraphStuff.edges.forEach(function (edgeGeom) {
            draw.grph.edges.push(edgeGeom);
        });
    }
    function makeBetter() {
        cluster(data.trjs.raw);
        genBetterTrajs(data.trjs.subsa);
        const drawBetterStuff = makeBetterGeom(data.clts, data.trjs.better);
        drawBetterStuff.cents.forEach(function (centGeom) {
            draw.clts.centroids.push(centGeom);
        });
        drawBetterStuff.trajs.forEach(function (trajGeom) {
            draw.trjs.better.push(trajGeom);
        });
    }
    function makeEvenBetter() {
        cluster(data.trjs.raw);
        genBetterTrajs(data.trjs.subsa);
        genEvenBetterTrajs(data.trjs.better);
        const drawBetterStuff = makeEvenBetterGeom(data.clts, data.trjs.evenbetter);
        drawBetterStuff.cents.forEach(function (centGeom) {
            draw.clts.centroids.push(centGeom);
        });
        drawBetterStuff.trajs.forEach(function (trajGeom) {
            draw.trjs.evenbetter.push(trajGeom);
        });
    }

    function makePointGeometry(points) {
        const pointsGeom = new THREE.Geometry();
        points.forEach(function (point) {
            pointsGeom.vertices.push(new THREE.Vector3(point.x, -point.y, point.f));
        });
        return pointsGeom;
    } //three.js
    function makeClusteredGeom(clusters) {

        const centGeoms = [];
        const pointGeoms = [];

        for (let c in clusters.centroids) {

            const centGeom = new THREE.Geometry();
            const cent = clusters.centroids[c];
            //centGeom.name = cent.did;
            centGeom.vertices.push(new THREE.Vector3(cent.x, cent.y * -1, cent.f));
            centGeoms.push(centGeom);

            const pointGeom = new THREE.Geometry();
            for (let p in clusters.centroids[c].g.members) {
                const point = clusters.centroids[c].g.members[p];
                pointGeom.name = point.did;
                pointGeom.vertices.push(new THREE.Vector3(point.x, point.y * -1, point.f));
            }
            pointGeoms.push(pointGeom);
        }
        const centDots = [];
        const pointDots = [];
        for (let g in centGeoms) {
            const randColor = Math.random() * 0xffffff;
            centDots.push(createDots(centGeoms[g], randColor, par.ct.dot.size));
            pointDots.push(createDots(pointGeoms[g], randColor, par.pt.dot.size));
        }

        return {
            cents: centDots,
            points: pointDots
        };
    } //three.js
    function makeGraphGeom(clusters, graph) {
        const centGeoms = [];
        const edgeGeoms = [];

        for(let c in clusters.centroids) {
            const centGeom = new THREE.Geometry();
            const cent = clusters.centroids[c];
            //centGeom.name = cent.did;
            centGeom.vertices.push(new THREE.Vector3(cent.x, cent.y * -1, cent.f));
            centGeoms.push(centGeom);
        }

        for(let e in graph.edges){
            const edgeGeom = new THREE.Geometry();
            const edge = graph.edges[e];
            edgeGeom.vertices.push(new THREE.Vector3(edge.start.x, edge.start.y * -1, edge.start.f));
            edgeGeom.vertices.push(new THREE.Vector3(edge.end.x, edge.end.y * -1, edge.end.f));
            edgeGeoms.push(edgeGeom);
        }

        //edges zeichnen
        const centDots = [];
        const edgeLines = [];
        for(let cg in centGeoms) {
            const randColor = Math.random() * 0xffffff;
            centDots.push(createDots(centGeoms[cg], randColor, par.ct.dot.size));//edgeLines.push( makeLine( edgeGeoms[g], 0x000000 ) );
        }
        for(let eg in edgeGeoms) {
            const mat = new THREE.LineBasicMaterial({color: 0x000000, opacity: 1});
            edgeLines.push(new THREE.LineSegments(edgeGeoms[eg], mat));
        }

        return {
            cents: centDots,
            edges: edgeLines
        };
    } //three.js
    function makeBetterGeom(clusters, trajs) {
        const trajGeoms = [];
        const centDots = [];
        const trajLines = [];

        clusters.centroids.forEach(function (cent) {
            const centGeom = new THREE.Geometry();
            centGeom.name = cent.did;
            centGeom.vertices.push(new THREE.Vector3(cent.x, cent.y * -1, cent.f));
            //centGeoms.push(centGeom);

            centDots.push(createDots(centGeom, cent.color, par.ct.dot.size));
        });

        trajs.forEach(function (traj) {
            const trajGeom = new THREE.Geometry();
            traj.centroids.forEach(function (point) {
                trajGeom.vertices.push(
                    new THREE.Vector3(
                        point.x + traj.deviation * 0.25,
                        point.y * -1 + traj.deviation * 0.25,
                        point.f));
            });
            trajGeoms.push(trajGeom);
        });

        //edges zeichnen
        /*for(let cg in centGeoms) {
         const randColor = Math.random() * 0xffffff;
         centDots.push(createDots(centGeoms[cg], randColor, par.ct.dot.size));//edgeLines.push( makeLine( edgeGeoms[g], 0x000000 ) );
         }*/
        for(let tg in trajGeoms) {
            const mat = new THREE.LineBasicMaterial({color: 0x0000ff, transparent: true, opacity: 0.4});
            trajLines.push(new THREE.Line(trajGeoms[tg], mat));
        }

        return {
            cents: centDots,
            trajs: trajLines
        };
    } //three.js
    function makeEvenBetterGeom(clusters, trajs) {
        const centGeoms = [];
        const anchorGeoms = [];

        clusters.centroids.forEach(function (cent) {
            const centGeom = new THREE.Geometry();
            centGeom.name = cent.did;
            centGeom.vertices.push(new THREE.Vector3(cent.x, cent.y * -1, cent.f));
            centGeoms.push(centGeom);
        });

        trajs.forEach(function (traj) {
            const anchorGeom = new THREE.Geometry();
            traj.anchors.forEach(function (point) {
                anchorGeom.vertices.push(
                    new THREE.Vector3(
                        point.x + traj.deviation * 0.25,
                        point.y * -1 + traj.deviation * 0.25,
                        point.f));
            });
            anchorGeoms.push(anchorGeom);
        });

        //started to implement splines --> continue
        /*trajs.forEach(function (traj) {
         const anchorVertices = [];
         traj.anchors.forEach(function (point) {
         anchorVertices.push(
         new THREE.Vector3(
         point.x + traj.deviation * 0.25,
         point.y * -1 + traj.deviation * 0.25,
         point.f));
         });
         const anchorSpline = new THREE.SplineCurve3(anchorVertices);
         const path = new THREE.Path(anchorSpline.getPoints( 50 ));
         const anchorGeom = path.createPointsGeometry( 50 );
         anchorGeoms.push(anchorGeom);
         });*/

        //edges zeichnen
        const centDots = [];
        const anchorLines = [];
        for(let cg in centGeoms) {
            const randColor = Math.random() * 0xffffff;
            centDots.push(createDots(centGeoms[cg], randColor, par.ct.dot.size));//edgeLines.push( makeLine( edgeGeoms[g], 0x000000 ) );
        }
        for(let ag in anchorGeoms) {

            const curve = new THREE.CatmullRomCurve3(anchorGeoms[ag].vertices);
            let tempTrajGeom = new THREE.Geometry();
            tempTrajGeom.vertices = curve.getPoints(50);

            const mat = new THREE.LineBasicMaterial({color: 0x000000, transparent: true, opacity: 0.4});
            anchorLines.push(new THREE.Line(tempTrajGeom, mat));
        }

        return {
            cents: centDots,
            trajs: anchorLines
        };
    } //three.js

    function createDots(geom, color, pointSize) {
        const mat = new THREE.PointsMaterial({color: color, opacity: 1, size: pointSize, sizeAttenuation: false});
        return new THREE.Points(geom, mat);
    } //three.js
    function createLine(geom, color) {
        const mat = new THREE.LineBasicMaterial({color: color, opacity: 1});
        return new THREE.Line(geom, mat);
    } //three.js

//--ADD-&-REMOVE--------------------------------------------------------------------------------------------------------
//  ToDo: review lineTypes

    //--Meshes----------------------------------------------------------------------------------------------------------
    function hideAllBgMeshes() {
        for (let bgMesh in draw.bgMs) {
            if (draw.bgMs.hasOwnProperty(bgMesh)) {
                scene.remove(draw.bgMs[bgMesh]);
            }
        }
    } //three.js
    function removeAllBgMeshes() {
        hideAllBgMeshes();
        draw.bgMs = {};
    }
    function deleteAllBgMeshes() {
        removeAllBgMeshes();
        //data.bgMs = {};
    }

    //--Grids-----------------------------------------------------------------------------------------------------------
    function hideAllGrids() {
        for (let grid in draw.grds) {
            if (draw.grds.hasOwnProperty(grid)) {
                scene.remove(draw.grds[grid]);
            }
        }
    } //three.js
    function removeAllGrids() {
        hideAllGrids();
        draw.grds = {};
    }
    function deleteAllGrids() {
        removeAllGrids();
        data.grds = {};
    }

    //--Special-Trajectories--------------------------------------------------------------------------------------------
    function removeClusterTrajectories() {
        //draw.pnts = data.pnts;
        draw.trjs = {
            raw: data.trjs.raw,
            subsa: [],
            better: [],
            evenbetter: []
        };
        draw.clts = {
            centroids: [],
            points: []
        };
        draw.grph = {
            edges: []
        };
    }
    function deleteClusterTrajectories() {
        removeClusterTrajectories();
        //data.pnts = data.pnts;
        data.trjs = {
            raw: data.trjs.raw,
            subsa: [],
            better: [],
            evenbetter: []
        };
        data.clts = {
            centroids: [],
            points: []
        };
        data.grph = {
            edges: []
        };
    }

    //--All-Trajectories------------------------------------------------------------------------------------------------
    function addAllTrajectories() { //abgesehen von clusters
    if (bd.lineType === 'Point') {
        draw.pnts.forEach(function (point) {
            scene.add(point);
        });
    } else if (bd.lineType === 'Line') {
        draw.trjs.raw.forEach(function (traj) {
            scene.add(traj);
        });
    }



    else if(bd.lineType === 'Clusters') {
        draw.clts.centroids.forEach(function (cent) {
            scene.add(cent);
        });
        draw.clts.points.forEach(function (point) {
            scene.add(point);
        });
    } else if(bd.lineType === 'Graph') {
        draw.clts.centroids.forEach(function (cent) {
            scene.add(cent);
        });
        draw.grph.edges.forEach(function (edge) {
            scene.add(edge);
        });
    } else if(bd.lineType === 'Better') {
        draw.clts.centroids.forEach(function (cent) {
            scene.add(cent);
        });
        draw.trjs.better.forEach(function (traj) {
            scene.add(traj);
        });
    } else if(bd.lineType === 'EvenBetter') {
        draw.clts.centroids.forEach(function (cent) {
            scene.add(cent);
        });
        draw.trjs.evenbetter.forEach(function (traj) {
            scene.add(traj);
        });
    }
} //three.js

    function hideAllTrajectories() {
        for(let p in draw.pnts) {
            scene.remove(draw.pnts[p]);
        }
        for(let t in draw.trjs.raw) {
            scene.remove(draw.trjs.raw[t]);
        }
        for(let t in draw.trjs.better) {
            scene.remove(draw.trjs.better[t]);
        }
        for(let t in draw.trjs.evenbetter) {
            scene.remove(draw.trjs.evenbetter[t]);
        }
        for(let c in draw.clts.centroids) {
            scene.remove(draw.clts.centroids[c]);
        }
        for(let p in draw.clts.points) {
            scene.remove(draw.clts.points[p]);
        }
        for(let e in draw.grph.edges) {
            scene.remove(draw.grph.edges[e]);
        }
    } //three.js
    function removeAllTrajectories() {
        hideAllTrajectories();
        draw.pnts = [];
        draw.trjs = {
            raw: [],
            subsa: [],
            better: [],
            evenbetter: [],
        };
        draw.clts = {
            centroids: [],
            points: [],
        };
        draw.grph = {
            edges: [],
        }
    }
    function deleteAllTrajectories() {
        removeAllTrajectories();
        data.pnts = [];
        data.trjs = {
            raw: [],
            subsa: [],
            better: [],
            evenbetter: []
        };
        data.clts = {
            centroids: [],
            points: []
        };
        data.grph = {
            edges: []
        };
    }

    //--All-------------------------------------------------------------------------------------------------------------
    function hideAll() {
         hideAllBgMeshes();
         hideAllGrids();
         hideAllTrajectories();
    }
    function removeAll(){
        removeAllBgMeshes();
        removeAllGrids();
        removeAllTrajectories();
    }
    function deleteAll() {
        deleteAllBgMeshes();
        deleteAllGrids();
        deleteAllTrajectories();
    }

//--CHANGE--------------------------------------------------------------------------------------------------------------
//  ToDo: review changeClusterRadius

    function changeScale() {
        deleteAllBgMeshes();
        deleteAllGrids();
        loadNewBgMesh(bd.path, bd.floor); //also invokes loadNewGrid();
        addAllTrajectories();
    }
    function changeFloors(floor) {
        if (!(draw.bgMs[floor] instanceof THREE.Mesh)) {
            loadNewBgMesh(bd.path, floor); //also invokes loadGrid()
        }
        updateCamera(bd.floor);
    }
    function changeLineType() {

        hideAllTrajectories();
        if(bd.lineType === 'Point'){
            if(draw.pnts.length === 0){
                makeAllTrajectories();
            }
        } else if (bd.lineType === 'Line') {
            if(draw.trjs.raw.length === 0){
                makeAllTrajectories();
            }
        } else  if(bd.lineType === 'Clusters') {
            if((draw.clts.centroids.length === 0) || (draw.clts.points.length === 0)) {
                deleteClusterTrajectories();
                makeAllTrajectories();
            }
        } else if(bd.lineType === 'Graph') {
            if((draw.clts.centroids.length === 0) || (draw.grph.edges.length === 0)) {
                deleteClusterTrajectories();
                makeAllTrajectories();
            }
        } else if(bd.lineType === 'Better') {
            if((draw.clts.centroids.length === 0) || (draw.trjs.better.length === 0)) {
                deleteClusterTrajectories();
                makeAllTrajectories();
            }
        } else if(bd.lineType === 'EvenBetter') {
            if((draw.clts.centroids.length === 0) || (draw.trjs.evenbetter.length === 0)) {
                deleteClusterTrajectories();
                makeAllTrajectories();
            }
        }
        addAllTrajectories();
    }
    function changeClusterRadius() {
        hideAllTrajectories();
        deleteClusterTrajectories();
        makeAllTrajectories();
        addAllTrajectories();
    }

</script>
</body>
</html>