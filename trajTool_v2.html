<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TrajTool</title>
    <style>
        body { margin: 0; overflow: hidden }
        canvas { width: 100%!important; height: auto!important; }

        .noselect {
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none; /* Safari */
            -khtml-user-select: none; /* Konqueror HTML */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently supported by Chrome and Opera */
        }
    </style>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/chroma.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>
<script src="js/levenshtein_obj.js"></script>
<script src="js/reimg.js"></script>

<!--Trajectory viewer-->
<script>

    function OrbitControls( object, domElement ) {

        this.object = object;

        this.domElement = ( domElement !== undefined ) ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = - Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.25;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        // Mouse buttons
        this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {

            return spherical.phi;

        };

        this.getAzimuthalAngle = function () {

            return spherical.theta;

        };

        this.reset = function () {

            scope.target.copy( scope.target0 );
            scope.object.position.copy( scope.position0 );
            scope.object.zoom = scope.zoom0;

            scope.object.updateProjectionMatrix();
            scope.dispatchEvent( changeEvent );

            scope.update();

            state = STATE.NONE;

        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = function() {

            var offset = new THREE.Vector3();

            // so camera.up is the orbit axis
            var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
            var quatInverse = quat.clone().inverse();

            var lastPosition = new THREE.Vector3();
            var lastQuaternion = new THREE.Quaternion();

            return function update () {

                var position = scope.object.position;

                offset.copy( position ).sub( scope.target );

                // rotate offset to "y-axis-is-up" space
                offset.applyQuaternion( quat );

                // angle from z-axis around y-axis
                spherical.setFromVector3( offset );

                if ( scope.autoRotate && state === STATE.NONE ) {

                    rotateLeft( getAutoRotationAngle() );

                }

                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;

                // restrict theta to be between desired limits
                spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

                // restrict phi to be between desired limits
                spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

                spherical.makeSafe();


                spherical.radius *= scale;

                // restrict radius to be between desired limits
                spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

                // move target to panned location
                scope.target.add( panOffset );

                offset.setFromSpherical( spherical );

                // rotate offset back to "camera-up-vector-is-up" space
                offset.applyQuaternion( quatInverse );

                position.copy( scope.target ).add( offset );

                scope.object.lookAt( scope.target );

                if ( scope.enableDamping === true ) {

                    sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                    sphericalDelta.phi *= ( 1 - scope.dampingFactor );

                } else {

                    sphericalDelta.set( 0, 0, 0 );

                }

                scale = 1;
                panOffset.set( 0, 0, 0 );

                // update condition is:
                // min(camera displacement, camera rotation in radians)^2 > EPS
                // using small-angle approximation cos(x/2) = 1 - x^2 / 8

                if ( zoomChanged ||
                    lastPosition.distanceToSquared( scope.object.position ) > EPS ||
                    8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

                    scope.dispatchEvent( changeEvent );

                    lastPosition.copy( scope.object.position );
                    lastQuaternion.copy( scope.object.quaternion );
                    zoomChanged = false;

                    return true;

                }

                return false;

            };

        }();

        this.dispose = function() {

            scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
            scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
            scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

            scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
            scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
            scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

            document.removeEventListener( 'mousemove', onMouseMove, false );
            document.removeEventListener( 'mouseup', onMouseUp, false );

            window.removeEventListener( 'keydown', onKeyDown, false );

            //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

        };

        //
        // internals
        //

        var scope = this;

        var changeEvent = { type: 'change' };
        var startEvent = { type: 'start' };
        var endEvent = { type: 'end' };

        var STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();

        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {

            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

        }

        function getZoomScale() {

            return Math.pow( 0.95, scope.zoomSpeed );

        }

        function rotateLeft( angle ) {

            sphericalDelta.theta -= angle;

        }

        function rotateUp( angle ) {

            sphericalDelta.phi -= angle;

        }

        var panLeft = function() {

            var v = new THREE.Vector3();

            return function panLeft( distance, objectMatrix ) {

                v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
                v.multiplyScalar( - distance );

                panOffset.add( v );

            };

        }();

        var panUp = function() {

            var v = new THREE.Vector3();

            return function panUp( distance, objectMatrix ) {

                v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
                v.multiplyScalar( distance );

                panOffset.add( v );

            };

        }();

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = function() {

            var offset = new THREE.Vector3();

            return function pan ( deltaX, deltaY ) {

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                if ( scope.object instanceof THREE.PerspectiveCamera ) {

                    // perspective
                    var position = scope.object.position;
                    offset.copy( position ).sub( scope.target );
                    var targetDistance = offset.length();

                    // half of the fov is center to top of screen
                    targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

                    // we actually don't use screenWidth, since perspective camera is fixed to screen height
                    panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
                    panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

                } else if ( scope.object instanceof THREE.OrthographicCamera ) {

                    // orthographic
                    panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
                    panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

                } else {

                    // camera neither orthographic nor perspective
                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
                    scope.enablePan = false;

                }

            };

        }();

        function dollyIn( dollyScale ) {

            if ( scope.object instanceof THREE.PerspectiveCamera ) {

                scale /= dollyScale;

            } else if ( scope.object instanceof THREE.OrthographicCamera ) {

                scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
                scope.object.updateProjectionMatrix();
                zoomChanged = true;

            } else {

                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                scope.enableZoom = false;

            }

        }

        function dollyOut( dollyScale ) {

            if ( scope.object instanceof THREE.PerspectiveCamera ) {

                scale *= dollyScale;

            } else if ( scope.object instanceof THREE.OrthographicCamera ) {

                scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
                scope.object.updateProjectionMatrix();
                zoomChanged = true;

            } else {

                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                scope.enableZoom = false;

            }

        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate( event ) {

            //console.log( 'handleMouseDownRotate' );

            rotateStart.set( event.clientX, event.clientY );

        }

        function handleMouseDownDolly( event ) {

            //console.log( 'handleMouseDownDolly' );

            dollyStart.set( event.clientX, event.clientY );

        }

        function handleMouseDownPan( event ) {

            //console.log( 'handleMouseDownPan' );

            panStart.set( event.clientX, event.clientY );

        }

        function handleMouseMoveRotate( event ) {

            //console.log( 'handleMouseMoveRotate' );

            rotateEnd.set( event.clientX, event.clientY );
            rotateDelta.subVectors( rotateEnd, rotateStart );

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            // rotating across whole screen goes 360 degrees around
            rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

            // rotating up and down along whole screen attempts to go 360, but limited to 180
            rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

            rotateStart.copy( rotateEnd );

            scope.update();

        }

        function handleMouseMoveDolly( event ) {

            //console.log( 'handleMouseMoveDolly' );

            dollyEnd.set( event.clientX, event.clientY );

            dollyDelta.subVectors( dollyEnd, dollyStart );

            if ( dollyDelta.y > 0 ) {

                dollyIn( getZoomScale() );

            } else if ( dollyDelta.y < 0 ) {

                dollyOut( getZoomScale() );

            }

            dollyStart.copy( dollyEnd );

            scope.update();

        }

        function handleMouseMovePan( event ) {

            //console.log( 'handleMouseMovePan' );

            panEnd.set( event.clientX, event.clientY );

            panDelta.subVectors( panEnd, panStart );

            pan( panDelta.x, panDelta.y );

            panStart.copy( panEnd );

            scope.update();

        }

        function handleMouseUp( event ) {

            //console.log( 'handleMouseUp' );

        }

        function handleMouseWheel( event ) {

            //console.log( 'handleMouseWheel' );

            if ( event.deltaY < 0 ) {

                dollyOut( getZoomScale() );

            } else if ( event.deltaY > 0 ) {

                dollyIn( getZoomScale() );

            }

            scope.update();

        }

        function handleKeyDown( event ) {

            //console.log( 'handleKeyDown' );

            switch ( event.keyCode ) {

                case scope.keys.UP:
                    pan( 0, scope.keyPanSpeed );
                    scope.update();
                    break;

                case scope.keys.BOTTOM:
                    pan( 0, - scope.keyPanSpeed );
                    scope.update();
                    break;

                case scope.keys.LEFT:
                    pan( scope.keyPanSpeed, 0 );
                    scope.update();
                    break;

                case scope.keys.RIGHT:
                    pan( - scope.keyPanSpeed, 0 );
                    scope.update();
                    break;

            }

        }

        function handleTouchStartRotate( event ) {

            //console.log( 'handleTouchStartRotate' );

            rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

        }

        function handleTouchStartDolly( event ) {

            //console.log( 'handleTouchStartDolly' );

            var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
            var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

            var distance = Math.sqrt( dx * dx + dy * dy );

            dollyStart.set( 0, distance );

        }

        function handleTouchStartPan( event ) {

            //console.log( 'handleTouchStartPan' );

            panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

        }

        function handleTouchMoveRotate( event ) {

            //console.log( 'handleTouchMoveRotate' );

            rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
            rotateDelta.subVectors( rotateEnd, rotateStart );

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            // rotating across whole screen goes 360 degrees around
            rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

            // rotating up and down along whole screen attempts to go 360, but limited to 180
            rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

            rotateStart.copy( rotateEnd );

            scope.update();

        }

        function handleTouchMoveDolly( event ) {

            //console.log( 'handleTouchMoveDolly' );

            var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
            var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

            var distance = Math.sqrt( dx * dx + dy * dy );

            dollyEnd.set( 0, distance );

            dollyDelta.subVectors( dollyEnd, dollyStart );

            if ( dollyDelta.y > 0 ) {

                dollyOut( getZoomScale() );

            } else if ( dollyDelta.y < 0 ) {

                dollyIn( getZoomScale() );

            }

            dollyStart.copy( dollyEnd );

            scope.update();

        }

        function handleTouchMovePan( event ) {

            //console.log( 'handleTouchMovePan' );

            panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

            panDelta.subVectors( panEnd, panStart );

            pan( panDelta.x, panDelta.y );

            panStart.copy( panEnd );

            scope.update();

        }

        function handleTouchEnd( event ) {

            //console.log( 'handleTouchEnd' );

        }

        //
        // event handlers - FSM: listen for events and reset state
        //

        function onMouseDown( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();

            if ( event.button === scope.mouseButtons.ORBIT ) {

                if ( scope.enableRotate === false ) return;

                handleMouseDownRotate( event );

                state = STATE.ROTATE;

            } else if ( event.button === scope.mouseButtons.ZOOM ) {

                if ( scope.enableZoom === false ) return;

                handleMouseDownDolly( event );

                state = STATE.DOLLY;

            } else if ( event.button === scope.mouseButtons.PAN ) {

                if ( scope.enablePan === false ) return;

                handleMouseDownPan( event );

                state = STATE.PAN;

            }

            if ( state !== STATE.NONE ) {

                document.addEventListener( 'mousemove', onMouseMove, false );
                document.addEventListener( 'mouseup', onMouseUp, false );

                scope.dispatchEvent( startEvent );

            }

        }

        function onMouseMove( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();

            if ( state === STATE.ROTATE ) {

                if ( scope.enableRotate === false ) return;

                handleMouseMoveRotate( event );

            } else if ( state === STATE.DOLLY ) {

                if ( scope.enableZoom === false ) return;

                handleMouseMoveDolly( event );

            } else if ( state === STATE.PAN ) {

                if ( scope.enablePan === false ) return;

                handleMouseMovePan( event );

            }

        }

        function onMouseUp( event ) {

            if ( scope.enabled === false ) return;

            handleMouseUp( event );

            document.removeEventListener( 'mousemove', onMouseMove, false );
            document.removeEventListener( 'mouseup', onMouseUp, false );

            scope.dispatchEvent( endEvent );

            state = STATE.NONE;

        }

        function onMouseWheel( event ) {

            if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

            event.preventDefault();
            event.stopPropagation();

            handleMouseWheel( event );

            scope.dispatchEvent( startEvent ); // not sure why these are here...
            scope.dispatchEvent( endEvent );

        }

        function onKeyDown( event ) {

            if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

            handleKeyDown( event );

        }

        function onTouchStart( event ) {

            if ( scope.enabled === false ) return;

            switch ( event.touches.length ) {

                case 1:	// one-fingered touch: rotate

                    if ( scope.enableRotate === false ) return;

                    handleTouchStartRotate( event );

                    state = STATE.TOUCH_ROTATE;

                    break;

                case 2:	// two-fingered touch: dolly

                    if ( scope.enableZoom === false ) return;

                    handleTouchStartDolly( event );

                    state = STATE.TOUCH_DOLLY;

                    break;

                case 3: // three-fingered touch: pan

                    if ( scope.enablePan === false ) return;

                    handleTouchStartPan( event );

                    state = STATE.TOUCH_PAN;

                    break;

                default:

                    state = STATE.NONE;

            }

            if ( state !== STATE.NONE ) {

                scope.dispatchEvent( startEvent );

            }

        }

        function onTouchMove( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            switch ( event.touches.length ) {

                case 1: // one-fingered touch: rotate

                    if ( scope.enableRotate === false ) return;
                    if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...

                    handleTouchMoveRotate( event );

                    break;

                case 2: // two-fingered touch: dolly

                    if ( scope.enableZoom === false ) return;
                    if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...

                    handleTouchMoveDolly( event );

                    break;

                case 3: // three-fingered touch: pan

                    if ( scope.enablePan === false ) return;
                    if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...

                    handleTouchMovePan( event );

                    break;

                default:

                    state = STATE.NONE;

            }

        }

        function onTouchEnd( event ) {

            if ( scope.enabled === false ) return;

            handleTouchEnd( event );

            scope.dispatchEvent( endEvent );

            state = STATE.NONE;

        }

        function onContextMenu( event ) {

            event.preventDefault();

        }

        //

        scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

        scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
        scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

        scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
        scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
        scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

        window.addEventListener( 'keydown', onKeyDown, false );

        // force an update at start

        this.update();

    }

    OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
    OrbitControls.prototype.constructor = OrbitControls;

    Object.defineProperties( OrbitControls.prototype, {

        center: {

            get: function () {

                console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
                return this.target;

            }

        },

        // backward compatibility

        noZoom: {

            get: function () {

                console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
                return ! this.enableZoom;

            },

            set: function ( value ) {

                console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
                this.enableZoom = ! value;

            }

        },

        noRotate: {

            get: function () {

                console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
                return ! this.enableRotate;

            },

            set: function ( value ) {

                console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
                this.enableRotate = ! value;

            }

        },

        noPan: {

            get: function () {

                console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
                return ! this.enablePan;

            },

            set: function ( value ) {

                console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
                this.enablePan = ! value;

            }

        },

        noKeys: {

            get: function () {

                console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
                return ! this.enableKeys;

            },

            set: function ( value ) {

                console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
                this.enableKeys = ! value;

            }

        },

        staticMoving : {

            get: function () {

                console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
                return ! this.enableDamping;

            },

            set: function ( value ) {

                console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
                this.enableDamping = ! value;

            }

        },

        dynamicDampingFactor : {

            get: function () {

                console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
                return this.dampingFactor;

            },

            set: function ( value ) {

                console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
                this.dampingFactor = value;

            }

        }

    } );

    THREE.OrbitControls = OrbitControls;

    //const THREE = require('js/three.js');
    //'use strict';

//--VARIABLES-----------------------------------------------------------------------------------------------------------

    let camera, scene, renderer, controls;
    let mouse, raycaster, INTERSECTED = new Set();
    let gui, infoDiv;
    let buildingFileClicker, trajectoryFileClicker, groundtruthFileClicker;
    let pointList, groundtruthList;

//--PARAMETERS----------------------------------------------------------------------------------------------------------

    const threePar = {
        cam: {
            corrNear: -0.1,
            corrFar: 0.1,
            corrZ: 100,
            positionZ: 100,
        },
        rend: {
            aa: true,
            alpha: true,
            color: 0xffffff,
            alphaVal: 0,
        },
        rayc: {
            hoverColor: 0x00cc00,
            clickColor: 0x00ff00,
            linePrec: 1,
        },
    };
    const guiPar = {
        folders: {
            load: {
                name: "Load",
            },
            del: {
                name: "Delete",
            },
            bdSettings: {
                name: "Building settings",
            },
            viewSettings: {
                name: "View settings",
            },
            lineTypes: {
                name: "Visible data",
            },
            dataSettings: {
                name: "Data settings",
            },
            infoSettings: {
                name: "Info-box settings"
            }
        },
        buttons: {
            bgLoader: {
                func: 'loadBuildingFile',
                name: 'Load building',
                initPath: 'LUCI_neu_',
                initExt: '.png',
            },
            dataLoader: {
                func: 'loadDataFile',
                name: 'Load trajectories',
            },
            gtLoader: {
                func: 'loadGroundtruthFile',
                name: 'Load groundtruths',
            },
            delAll: {
                func: 'deleteEverything',
                name: 'Delete everything',
            },
            delTrajectories: {
                func: 'deleteTrajectoryData',
                name: 'Delete trajectories',
            },
            toggleGrid: {
                func: 'toggleAllGrids',
                name: 'Toggle grid',
            },
            screenshot: {
                func: 'takeScreenshot',
                name: 'Take screenshot',
            }

        },
        sliders: {
            scale: {
                func: 'scale',
                name: 'Scale (1:X)',
                min: 45,
                max: 100,
                step: 1,
                init: 49,
            },
            cutTime: {
                func: 'cutTime',
                name: 'Cut time',
                min: 1000,
                max: 1000000,
                step: 1000,
                init: 20000,
            },
            maxClusterRad: {
                func: 'maxRadius',
                name: 'Cluster radius',
                min: 5,
                max: 50,
                step: 5,
                init: 20,
            },
            redist: {
                func: 'redist',
                name: 'Redist count',
                min: 0,
                max: 50,
                step: 1,
                init: 50,
            },
            zoom: {
                func: 'zoom',
                name: 'Zoom',
                min: 1,
                max: 2,
                step: 0.1,
                init: 1, //1.2,
            },
            floor: {
                func: 'floor',
                name: 'Floor',
                min: -2,
                max: 2,
                step: 1,
                init: 1,
            },
        },
        checkboxes: {
            lineTypes: {
                choices: {
                    points: {name: 'Dots', init: true},
                    lines: {name: 'Lines', init: false},
                    centroids: {name: 'Centroids', init: false},
                    circles: {name: 'Circles', init: false},
                    clusters: {name: 'Clusters', init: false},
                    graph: {name: 'Graph', init: false},
                    curves: {name: 'Curves', init: false},
                    groundtruth: {name: 'GT', init: true},
                },
            },
            infoTypes: {
                choices: {
                    basic: {name: 'Basic', init: true},
                    analysis: {name: 'Analysis', init: true},
                    extensive: {name: 'Extensive', init: true},
                }
            },
            toggleGrid: {
                func: 'grid',
                name: 'Show grid',
                init: false,
            }
        }

    }; //ToDo: building path changed-----------------------------------------------------------------
    const par = {
        bg: {
            dir: 'img/',
            corrZ: -1,
        },
        gd: {
            delta: 5,
            corrZ: 1,
            line: {
                color: 0x555555,
                opacity: 1,
            }
        },
        tj: {
            color: 0xff0000,
            opacity: 1,
            clickColor: 0x000000,
            cutTime: 20000,
            dot: {
                opacity: 1,
                size: .4,
            },
            deviationFactor: 0.25, //should be changed depending on number of trajectories on connection
        },
        ln: {
            color: 0x000000,
            opacity: 0.4,
            transparency: true,
        },
        ct: {
            size: 1,
            opacity: 1,
            corrZ: 0.1,
            circles: {
                opacity: 0.2,
                segNum: 20,
                corrZ: -0.0,
            },
        },
        cl: {
            color: 0xffffff,
            corrColor: 0x555555,
            colorScaleType: ['darkgreen', 'forestgreen', 'yellowgreen', 'gold', 'orangered', 'crimson', 'darkred'], //'RdYlBu',
            colorDarkenFactor: 0,
            errors: {
                color: 0x0000ff,
            }
        },
        gt: {
            cutTime: 20000000,
        },
        csv: {
            header: 't,x,y,acc,f,did',
            removeCount: 2,
        },
        subsaRadius: 3,

        //tj = trajectory; pt = point; ct = centroid; bg = background; gd = grid
    };

//--CONSTANTS-----------------------------------------------------------------------------------------------------------

    const bd = {

        img: null,

        w: window.innerWidth, //building width
        wListener: function() {
            updateCamera();
            updateRenderer();
        },
        get width() {
            return this.w;
        },
        set width(val) {
            this.w = val;
            this.wListener(val)
        },

        h: window.innerHeight, //building height
        hListener: function() {
            updateCamera();
            updateRenderer();
        },
        get height() {
            return this.h;
        },
        set height(val) {
            this.h = val;
            this.hListener(val);
        },

        get ratio() {
            return this.w / this.h;
        },

        g: guiPar.checkboxes.toggleGrid.init,
        gListener: function() {
            toggleAllGrids();
        },
        get grid() {
            return this.g;
        },
        set grid(val) {
            if (val !== this.g) {
                this.g = val;
                this.gListener();
            }
        },
        z: guiPar.sliders.zoom.init,
        zListener: function() {
            updateCamera();
        },
        get zoom() {
            return this.z;
        },
        set zoom(val) {
            if (val !== this.z) {
                this.z = val;
                this.zListener();
            }
        },

        f: guiPar.sliders.floor.init, //building floor
        fListener: function() {
            changeFloors();
        },
        get floor() {
            return this.f;
        },
        set floor(val) {
            //if (val !== this.f) {
                this.f = val;
                this.fListener();
            //}
        },

        s: guiPar.sliders.scale.init, //building scale
        sListener: function() {
            changeScale();
        },
        get scale() {
            return this.s;
        },
        get scaleFraction() {
            return ( 1 / this.s );
        },
        set scale(val) {
            if (val !== this.s) {
                this.s = val;
                this.sListener(val);
            }
        },

        filePath: guiPar.buttons.bgLoader.initPath,
        fileExt: guiPar.buttons.bgLoader.initExt,
        get path() {
            return this.filePath + this.f + this.fileExt;
        },

        lt: {
            pt: guiPar.checkboxes.lineTypes.choices.points.init,
            ln: guiPar.checkboxes.lineTypes.choices.lines.init,
            ct: guiPar.checkboxes.lineTypes.choices.centroids.init,
            ci: guiPar.checkboxes.lineTypes.choices.circles.init,
            cl: guiPar.checkboxes.lineTypes.choices.clusters.init,
            bt: guiPar.checkboxes.lineTypes.choices.graph.init,
            eb: guiPar.checkboxes.lineTypes.choices.curves.init,
            gt: guiPar.checkboxes.lineTypes.choices.groundtruth.init,

            ltListener: function() {
                changeLineType();
            },

            get points() {return this.pt},
            set points(val) {
                this.pt = val;
                this.ltListener('points');
            },
            get lines() {return this.ln},
            set lines(val) {
                this.ln = val;
                this.ltListener('lines');
            },
            get centroids() {return this.ct},
            set centroids(val) {
                this.ct = val;
                this.ltListener('centroids');
            },
            get circles() {return this.ci},
            set circles(val) {
                this.ci = val;
                this.ltListener('circles');
            },
            get clusters() {return this.cl},
            set clusters (val) {
                this.cl = val;
                this.ltListener('clusters');
            },
            get graph() {return this.bt},
            set graph (val) {
                this.bt = val;
                this.ltListener('graph');
            },
            get curves() {return this.eb},
            set curves (val) {
                this.eb = val;
                this.ltListener('curves');
            },
            get groundtruth() {return this.gt},
            set groundtruth(val) {
                this.gt = val;
                this.ltListener('groundtruth');
            },
        }, //trajectory linetype
        get lineType() {
            return this.lt;
        },

        iT: {
            ba: guiPar.checkboxes.infoTypes.choices.basic.init,
            an: guiPar.checkboxes.infoTypes.choices.analysis.init,
            ex: guiPar.checkboxes.infoTypes.choices.extensive.init,

            itListener: function(){
                changeInfoType();
            },

            get basic() {return this.ba},
            set basic(val) {
                this.ba = val;
                this.itListener();
            },
            get analysis() {return this.an},
            set analysis(val) {
                this.an = val;
                this.itListener();
            },
            get extensive() {return this.ex},
            set extensive(val) {
                this.ex = val;
                this.itListener();
            },
        },
        get infoType() {
            return this.lt;
        },

        cT: guiPar.sliders.cutTime.init,
        cTListener: function() {
            changeCutTime();
        },
        get cutTime() {return this.cT},
        set cutTime(val) {
            this.cT = val;
            this.cTListener();
        },

        mR: guiPar.sliders.maxClusterRad.init, //cluster maxRadius
        mRListener: function() {
            changeClusterRadius();
        },
        get maxRadius() {
            return this.mR;
        },
        set maxRadius(val) {
            if (val !== this.mR) {
                this.mR = val;
                this.mRListener(val);
            }
        },

        redi: guiPar.sliders.redist.init,
        rediListener: function() {
            changeMaxRedist();
        },
        get redist() {
            return this.redi;
        },
        set redist(val) {
            if(val !== this.redi) {
                this.redi = val;
                this.rediListener(val);
            }
        },
    };
    const flags = {
        dom: {
            infoDivCount: 0,
        },
        data: {
            points: 0,
            subsaPoints: 0,
            trajectories: 0,
            centroids: 0,
            edges: 0,
        },
        clustering: {
            redistChange: true,
        },
        camera: {
            threeD: false,
        },
        raycaster: {
            shiftDown: false,
        },
    };

    const data = {
        grds: {},
        trjs: {
            valid: false,
            value: [],
        },
        grts: {
            valid: false,
            value: [],
        },
        clts: {
            valid: false,
            value: [],
        },
        edgs: {
            valid: false,
            value: [],
        },
        errs: {
            valid: false,
            value: [],
        }, //temp
    };
    const draw = {
        bgMs: [],
        grds: [],
        errs: null,
    };

//--CLASSES-------------------------------------------------------------------------------------------------------------

    class infoCont {
        constructor(heading, cont) {
            this.div = null;
            this.id = "infoCont_" + flags.dom.infoDivCount;
            flags.dom.infoDivCount++;
            this.style = {
                contDiv: {
                    position: "relative",
                    width: "auto",
                    height: "auto",
                    backgroundColor: "rgba(30, 30, 30, 1)",
                    margin: "0px",
                    paddingLeft: "4px",
                    paddingRight: "4px",
                    paddingTop: "1px",
                    paddingBottom: "2px",
                    borderBottom: "1px solid rgba(255,255,255,0.1)"
                },
                table: {},
                heading: {
                    fontWeight: "bold",
                    height: "1.8em",
                },
            };

            this.heading = heading || ["Description", "Value"];
            this.contBlocks = cont || [["Trajectory", ""]];
        }

        createDiv() {
            const contDiv = document.createElement('div');
            contDiv.id = this.id;
            for(let key in this.style.contDiv) {
                if(this.style.contDiv.hasOwnProperty(key)) {
                    contDiv.style[key] = this.style.contDiv[key];
                }
            }
            const table = document.createElement('table');
            table.style.borderSpacing = "5px";

            const heading = document.createElement('tr');
            for(let key in this.style.heading) {
                if(this.style.heading.hasOwnProperty(key)) {
                    heading.style[key] = this.style.heading[key];
                }
            }
            let first;
            if(this.heading.length <= 3) first = true;
            this.heading.customForEach(function(col) {
                const tempCol = document.createElement('td');
                tempCol.style.borderBottom = "1px dotted rgba(255,255,255,0.1)";

                //if(first) {
                    tempCol.style.width = "120px";
                //}
                first = false;

                tempCol.appendChild(document.createTextNode(col));
                heading.appendChild(tempCol);
            });
            table.appendChild(heading);

            this.contBlocks.customForEach(function(content) {
                const tr = document.createElement('tr');
                content.customForEach(function(col) {
                    const tempCol =  document.createElement('td');
                    tempCol.style.verticalAlign = "top";
                    tempCol.appendChild(document.createTextNode(col));
                    tr.appendChild(tempCol);
                });
                table.appendChild(tr);
            });

            contDiv.appendChild(table);
            this.div = contDiv;
        }

        removeDiv() {
            document.body.removeChild(this.div);
        }
    }

    class Point {
        constructor(p) {
            this.ID = p.ID;
            this.did = p.did;
            this.x = p.x;
            this.y = p.y;
            this.f = p.f;
            this.t = p.t;
            this.traj = p.traj;
            this.cl = null;
            this.col = null;
        }
        get color() {return this.col}
        set color(val) {this.col = val}

        get cluster() {return this.cl}
        set cluster(clus) {
            this.cl = clus;
        }
        clearCluster() {
            this.cl = null;
        }
        get trajectory() {return this.traj}
        set trajectory(tj) {this.traj = tj}
    }
    class Centroid extends Point {
        constructor(p) {
            super(p);
            this.cl = p.cl;
            this.ID = flags.data.centroids;
            flags.data.centroids++;
        }
    }
    class Anchor extends Point {
        constructor(p) {
            super(p);
            this.col = p.col;
        }
    }

    class Trajectory {
        constructor(rawData, floor, ID) {
            this.ID = ID;
            this.f = floor;
            this.color = Math.random() * 0xffffff; //par.tj.color;
            this.deviation = rand_BoxMuller();
            this.data = {
                raw: rawData,
                subsa: [],
                clusters: [],
                anchors: [],
            };
            this.drawing = {
                dots: null,
                line: null,
                clusLine: null,
                anchLine: null,
            };
        }
        get rawPoints() {return this.data.raw}
        set rawPoints(points) {this.data.raw = points}
        emptyRawPoints() {this.data.raw = []}
        get subsaPoints() {return this.data.subsa}
        set subsaPoints(points) {this.data.subsa = points}
        emptySubsaPoints() {this.data.subsa = []}
        get clusters() {return this.data.clusters}
        set clusters(clusters) {this.data.clusters = clusters}
        addCluster(clus) {
            this.data.clusters.push(clus);
            clus.addTrajectory(this);
        }
        findClusters() {
            this.emptyClusters();

            let tc;

            /*if(this.subsaPoints[0].cluster){
                tc = this.subsaPoints[0].cluster;
                this.addCluster(this.subsaPoints[0].cluster);
            } else {
                console.log('subsaP 0 has no cluster');
            }//ToDo: find cause of missing centroids*/

            let i = 0;
            while(i < this.subsaPoints.length) {
                if(this.subsaPoints[i].cluster){
                    /*if(!tc) {
                        tc = this.subsaPoints[i].cluster;
                    }*/

                    if(!tc) {

                        tc = this.subsaPoints[i].cluster;
                        this.addCluster(tc);

                    } else if(tc !== this.subsaPoints[i].cluster) {

                        let c = this.subsaPoints[i].cluster;
                        tc.addNextCluster(c);
                        this.addCluster(c);
                        tc = c;
                    }

                } else {
                    console.log('subsaP ' + i + ' has no cluster');
                }
                i++;
            }
        }
        emptyClusters() {
            this.data.clusters = [];
        }
        get anchors() {return this.data.anchors}
        set anchors(anchs) {this.data.anchors = anchs}
        addAnchor(anch) {
            this.data.anchors.push(anch);
            //anch. implement if Anchor becomes a class
        }
        findAnchors() {
            this.emptyAnchors();
            this.addAnchor(new Anchor(this.clusters[0].centroid));

            let i = 1;
            if(this.clusters.length > 2) {
                while (i < this.clusters.length - 1) {

                    const p0 = this.clusters[i - 1].centroid;
                    const p1 = this.clusters[i].centroid;
                    const p2 = this.clusters[i + 1].centroid;

                    let p1p0 = {x: p0.x - p1.x, y: p0.y - p1.y};
                    let p1p2 = {x: p2.x - p1.x, y: p2.y - p1.y};

                    let abs_p1p0 = Math.sqrt(p1p0.x * p1p0.x + p1p0.y * p1p0.y);
                    let abs_p1p2 = Math.sqrt(p1p2.x * p1p2.x + p1p2.y * p1p2.y);

                    let cos_p0p2 = ((p1p0.x * p1p2.x + p1p0.y * p1p2.y) / (abs_p1p0 * abs_p1p2));

                    //let alpha = ((cos_p0p2 + 1.0) / 2.0 + params.alpha) / (1.0 + params.alpha);
                    let alpha = (cos_p0p2 + 1.0) / 2.0;

                    //boundaries
                    let beta = Math.max(alpha, 0.6); //changed to 0.6 to prevent hard edges
                    //beta = Math.min(beta, 0.95);

                    //beta = alpha;

                    const p01 = new Anchor({
                        x: (1 - beta) * p0.x + beta * p1.x,
                        y: (1 - beta) * p0.y + beta * p1.y,
                        f: p1.f,
                    });
                    const p12 = new Anchor({
                        x: beta * p1.x + (1 - beta) * p2.x,
                        y: beta * p1.y + (1 - beta) * p2.y,
                        f: p1.f
                    });

                    this.addAnchor(p01);
                    this.addAnchor(p12);

                    i++;
                }
            }

            if(this.clusters.length > 1){
                this.addAnchor(new Anchor(this.clusters[i].centroid));
            }
        }
        findBezAnchors() {
            this.emptyAnchors();

            let i = 0;
            while( i < this.clusters.length - 1) {

                const cA = this.clusters[i].centroid;
                const cB = this.clusters[i+1].centroid;

                const alpha = 0.5;

                const tempScale = chroma.scale([cA.cluster.color, cB.cluster.color]);

                const p = new Anchor({
                    x: alpha * cA.x + (1 - alpha) * cB.x,
                    y: alpha * cA.y + (1 - alpha) * cB.y,
                    f: cA.f,
                    col: tempScale(alpha),
            });
                /*const tempColor = (((cA.color * 0x0000FF + cB.color * 0x0000FF) / 2) +
                                    ((cA.color * 0x00FF00 + cB.color * 0x00FF00) / 2) +
                                    ((cA.color * 0xFF0000 + cB.color * 0xFF0000) / 2));*/

                this.addAnchor(new Anchor(cA));
                this.addAnchor(p);

                i++;
            }
            this.addAnchor(new Anchor(this.clusters[i].centroid));
        }
        emptyAnchors() {
            this.data.anchors = [];
        }

        emptyClusterData() {
            this.emptyClusterDrawing();
            this.emptySubsaPoints();
            this.emptyClusters();
            this.emptyAnchors();
        }

        get dots() {return this.drawing.dots}
        set dots(dots) {this.drawing.dots = dots}
        get line() {return this.drawing.line}
        set line(line) {this.drawing.line = line}
        get clusLine() {return this.drawing.clusLine}
        set clusLine(clusLine) {this.drawing.clusLine = clusLine}
        get anchLine() {return this.drawing.anchLine}
        set anchLine(anchLine) {this.drawing.anchLine = anchLine}

        emptyClusterDrawing() {
            this.clusLine = null;
            this.anchLine = null;
        }
        emptyDrawing() {
            this.emptyClusterDrawing();
            this.dots = null;
            this.line = null;
        }

        getBasicInfo() {
            const lM = this.getLengthInMeters();
            const lP = this.rawPoints.length;
            const dur = this.getDurationInS();
            const speed = Math.round((lM / dur) * 360) / 100;
            return {
                'Type': this.constructor.name,
                'ID': this.ID,
                'Floor': this.f,
                'Length': {
                    'm': lM,
                    'pts': lP,
                },
                'Duration': {
                    's': dur,
                },
                'Avg. speed': {
                    'km/h': speed,
                },
            };
        }
        getLengthInMeters() {
            const rp = this.rawPoints;
            let l = 0;
            for(let i = 0; i < rp.length - 1; i++) {
                l += Math.sqrt((rp[i].x - rp[i+1].x) * (rp[i].x - rp[i+1].x) +
                                (rp[i].y - rp[i+1].y) * (rp[i].y - rp[i+1].y));
            }
            return Math.round(l * 100) / 100;
        }
        getDurationInS() {
            return Math.trunc((this.rawPoints[this.rawPoints.length - 1].t - this.rawPoints[0].t) / 1000);
        }

        getAnalysisInfo() {
            return {
                'Visited clusters': this.getVisitedClusters(),
            }
        }
        getVisitedClusters() {
            /*let IDs = "";
            this.clusters.customForEach(function(clus) {
                IDs += clus.centroid.ID.toString();
                IDs += "-";
            });
            IDs = IDs.slice(0,-1);*/

            let IDs = [];
            this.clusters.customForEach(function(clus) {
                IDs.push(clus.centroid.ID);
            });
            return IDs;
        }


        getExtensiveInfo() {return {}}
    }
    class Cluster {
        constructor() {
            this.data = {
                centroid: {},
                edges: new Set(),
                members: [],
                trajs: new Set(),
                anchors: [],
            };
            this.drawing = {
                centroid: null,
                circle: null,
                members: null,
            };
            this.prev = new Set();
            this.next = new Set();
            this.col = Math.random() * 0xffffff;
        }
        get centroid() {return this.data.centroid}
        set centroid(cent) {
            this.data.centroid = cent;
            this.data.centroid.cluster = this;
        }
        updateCentroid() {

            let sumX = 0;
            let sumY = 0;
            const points = this.members;
            const numPoints = this.members.length;

            for (let p in points) {
                if(points.hasOwnProperty(p)){
                    sumX += points[p].x;
                    sumY += points[p].y;
                }
            }

            if (numPoints > 0) {
                const tempCent = this.centroid;
                tempCent.x = sumX / numPoints;
                tempCent.y = sumY / numPoints;
                this.centroid = tempCent;
            } else {
                //ToDo: implement: delete cluster --------------------------------------
                this.centroid = null;
                console.error("updateCentroid: cluster has no members");
            }
        }

        get edges() {return this.data.edges}
        set edges(val) {this.data.edges = val}
        addEdge(edge) {
            this.data.edges.add(edge);
        }

        get members() {return this.data.members}
        set members(memb) {
            this.data.members = memb;
            this.data.members.customForEach(function(pt) {
                pt.cluster = this;
            });
        }
        addMember(pt) {
            pt.cluster = this;
            this.data.members.push(pt);
        }
        clearMembers() {
            this.data.members.customForEach(function(pt) {
                pt.clearCluster();
            });
            this.data.members = [];
            this.clearTrajectories();
        }

        get trajectories() {
            return this.data.trajs;
        }
        addTrajectory(traj) {
            this.data.trajs.add(traj);

        }
        clearTrajectories() {
            this.data.trajs.clear();
        }

        get anchors() {return this.data.anchors}
        addAnchor(anch) {
            this.data.anchors.push(anch);
        }

        get centDot() {return this.drawing.centroid}
        set centDot(cent) {this.drawing.centroid = cent}
        get circMesh() {return this.drawing.circle}
        set circMesh(circle) {this.drawing.circle = circle}
        get membDots() {return this.drawing.members}
        set membDots(point) {this.drawing.members = point}

        get prevClusters() {return this.prev}
        set prevClusters(set) {this.prev = set}
        addPrevCluster(clus) {
            this.prev.add(clus);
            if(clus) clus.next.add(this);
        }
        get nextClusters() {return this.next}
        set nextClusters(set) {this.next = set}
        addNextCluster(clus) {
            this.next.add(clus);
            if(clus) clus.prev.add(this);
        }


        emptyClusterDrawing() {
            this.centDot = null;
            this.circMesh = null;
            this.membDots = null;
        }

        getBasicInfo() {

            const edgesIn = this.getInEdges(this);
            const edgesOut = this.getOutEdges(this);

            return {
                'Type': this.centroid.constructor.name,
                'ID': this.centroid.ID,
                'Members': this.members.length,
                'Edges': {
                    'in': edgesIn,
                    'out': edgesOut,
                },
                'Ts Passing': this.trajectories.size
            };
        }
        getOutEdges(clus) {
            let count = 0;
            this.edges.forEach(function(edge) {
                if(edge.prevCluster === clus) count++;
            });
            return count;
        }
        getInEdges(clus) {
            let count = 0;
            this.edges.forEach(function(edge) {
                if(edge.nextCluster === clus) count++;
            });
            return count;
        }

        getAnalysisInfo() {
            return {
                'Origins': this.getOriginClusters(),
                'Destinations': this.getDestinationClusters()
            }
        }
        getOriginClusters() {
            let IDs = new Set();
            this.prevClusters.forEach(function(clus) {
                IDs.add(clus.centroid.ID);
            });
            //IDs.sort((a,b) => (a - b));
            //return IDs.join(", ");
            return IDs;
        }
        getDestinationClusters() {
            let IDs = new Set();
            this.nextClusters.forEach(function(clus) {
                IDs.add(clus.centroid.ID);
            });
            //IDs.sort((a,b) => (a - b));
            //return IDs.join(", ");
            return IDs;
        }

        getExtensiveInfo() {
            return {
                'Centroid': {
                    'x': this.centroid.x,
                    'y': this.centroid.y,
                },
            }
        }

    }
    class Edge {
        constructor(prevCluster, nextCluster) {
            this.data = {
                prevCluster: prevCluster,
                nextCluster: nextCluster,
            };
            this.drawing = {
                line: null,
            };
        }
        get prevCluster() {return this.data.prevCluster}
        get nextCluster() {return this.data.nextCluster}
    }

//--START---------------------------------------------------------------------------------------------------------------

    init();
    initRaycaster(); //broken for now
    update();

//--INITALIZATION-------------------------------------------------------------------------------------------------------
//  ToDo: Review init function (camera?)

    function init() {
        initCustomForEach();
        initSpreadObjToArray();
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(0, 0, 0, 0, 0, 0, 0);
        initDOM();
        initRenderer();
        initCamera();

        if(flags.threeD) {
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.addEventListener( 'change', update ); // remove when using animation loop
            controls.enableZoom = false;
        }

        initBackgroundFileInput();
        initPositionFileInput();
        initGroundtruthFileInput();
        initDatGUI();
        initWindowResizeListeners();
        initKeypressListener();
    }

    function initDOM() {
        const guiDiv = document.createElement('div');
        guiDiv.id = "guiDiv";
        guiDiv.className = "noselect";
        guiDiv.style.position = "absolute";
        guiDiv.style.right = "0px";
        guiDiv.style.height = "auto";
        document.body.appendChild(guiDiv);

        infoDiv = document.createElement('div');
        infoDiv.id = "infoDiv";
        infoDiv.className = "noselect";
        infoDiv.style.position = "absolute";
        infoDiv.style.right = "0px";
        infoDiv.style.bottom = "0px";
        infoDiv.style.width = "490px"; //"245px";
        infoDiv.style.height = "auto";
        infoDiv.style.maxHeight = "330px";
        infoDiv.style.backgroundColor = "rgba(20, 20, 20, 1)";
        infoDiv.style.overflowY = "auto";
        infoDiv.style.overflowX = "hidden";
        infoDiv.style.padding = "0px";
        infoDiv.style.color = "white";
        infoDiv.style.font = "11px 'Lucida Grande', sans-serif";

        const style = {
            position: "relative",
            width: "100%",
            height: "auto",
            margin: "0px",
            padding: "3px",
            borderBottom: "1px solid rgba(255,255,255,0.1)"
        };
        const tempDiv = document.createElement('div');
        tempDiv.id = "infoCont_heading";
        for(let key in style) {
            tempDiv.style[key] = style[key];
        }

        const table = document.createElement('table');
        table.style.width = "100%";
        table.style.borderSpacing = "2px";
        table.style.overflow = "hidden";
        const heading = document.createElement('tr');
        const desCol = document.createElement('td');
        desCol.style.textAlign = "center";
        desCol.appendChild(document.createTextNode('Info'));
        heading.appendChild(desCol);
        table.appendChild(heading);
        tempDiv.appendChild(table);
        infoDiv.appendChild(tempDiv);
        document.body.appendChild(infoDiv);

        createTestInfo(0);
    }
    function createTestInfo(num) {
        for(let i = 1; i <= num; i++) {
            let test = new infoCont(
                ["Col 1", "Col 2"],
                [
                    ["Trajectory " + i,"wtf"],
                    ["Cluster " + i, "lorem ipsum, braindead ofofofofofofofoofofofo"]
                ]
            );
            test.createDiv();
        }
    }

    function initRenderer() {
        renderer = new THREE.WebGLRenderer({antialias: threePar.rend.aa, alpha: threePar.rend.alpha});
        renderer.setClearColor(threePar.rend.color, threePar.rend.alphaVal);//        renderer.setPixelRatio( window.devicePixelRatio ) ;
        document.body.appendChild(renderer.domElement);
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function initCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera = new THREE.OrthographicCamera(0, bd.width,
                0, -bd.width / windowRatio, 0, 200);
        } else {
            camera = new THREE.OrthographicCamera(0, bd.height * windowRatio,
                0, -bd.height, 0, 200);
        } //Temp code inside

        camera.position.z = 100;
        camera.lookAt(new THREE.Vector3(0,0,0));
        camera.updateProjectionMatrix();
    } //three.js
    function initRaycaster() {
        raycaster = new THREE.Raycaster();
        raycaster.near = 0;
        raycaster.far = 200;
        raycaster.linePrecision = threePar.rayc.linePrec;
        mouse = new THREE.Vector2();
        window.addEventListener('click', onMouseClick, false);
        window.addEventListener('mousemove', hoverDetector, false);
    } //three.js

//--UPDATE--------------------------------------------------------------------------------------------------------------

    function updateRenderer() {
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function updateCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera.right = bd.width;
            camera.bottom = -bd.width / windowRatio;
            camera.near = -(bd.floor * 10 + 5) + threePar.cam.corrZ;
            camera.far = -(bd.floor * 10 - 5) + threePar.cam.corrZ;
        } else {
            camera.right = bd.height * windowRatio;
            camera.bottom = -bd.height;
            camera.near = -(bd.floor * 10 + 5) + threePar.cam.corrZ;
            camera.far = -(bd.floor * 10 - 5) + threePar.cam.corrZ;
        }
        camera.zoom = bd.zoom;
        camera.updateProjectionMatrix();
    } //three.js
    function updateRaycaster() {
        raycaster.near = -(bd.floor * 10 + 5) + threePar.cam.corrZ;
        raycaster.far = -(bd.floor * 10 - 5) + threePar.cam.corrZ;
    }//three.js

    function update() {
        requestAnimationFrame(update);
        renderer.render(scene, camera);
    } //three.js

    function takeScreenshot() {
        renderer.render(scene, camera);
        //const screenshot = renderer.domElement.toDataURL();
        //console.log(screenshot);
        ReImg.fromCanvas(renderer.domElement).downloadPng();
    }

//--HELPERS-------------------------------------------------------------------------------------------------------------

    function initCustomForEach() {
        function arrayForeach(fn) {
            const arr = this;
            const len = arr.length;
            for(let i = 0; i < len; ++i) {
                fn(arr[i]);
            }
        }

        Object.defineProperty(Array.prototype, 'customForEach', {
            enumerable: false,
            value: arrayForeach
        });
    }
    function initSpreadObjToArray() {
        function toArray() {
            const obj = this;
            const arr = [];
            for(let key in obj) {
                if(obj.hasOwnProperty(key)) arr.push([key, obj[key]]);
            }
            return arr;
        }
        Object.defineProperty(Object.prototype, 'toArray', {
            enumerable: false,
            value: toArray
        });
    }
    function rand_BoxMuller() {
        const u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1].
        const v = 1 - Math.random();
        return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    }

//--RAYCASTER-----------------------------------------------------------------------------------------------------------

    function hoverDetector() {

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // create an array containing all objects in the scene with which the ray intersects
        let intersects = raycaster.intersectObjects(scene.children, true) ;

        // INTERSECTED = the object in the scene currently closest to the camera
        // and intersected by the Ray projected from the mouse position

        // if there is one (or more) intersections
        if (intersects.length > 0) {

            let obj;
            let tempGeom = null;

            for(let o = 0; o < intersects.length; o++) {

                const tempObj = intersects[o].object;

                if((!(intersects[o].distance.isNaN)) && (tempObj.geometry !== tempGeom) &&
                    ((Math.trunc(intersects[o].point.z * 100) / 100) >= (bd.floor * 10) - 1) &&
                    ((Math.trunc(intersects[o].point.z * 100) / 100) <= (bd.floor * 10) + 1) &&
                    (tempObj.geometry.vertices[0].z >= ((bd.floor * 10) - 1)) &&
                    (tempObj.geometry.vertices[0].z <= ((bd.floor * 10) + 1)))
                    outer_if:{

                        tempGeom = tempObj.geometry;

                        if(tempObj.userData instanceof Trajectory) {

                            obj = {
                                type: 'trajectory',
                                userData: tempObj.userData,
                                state: '',
                            };
                            break outer_if;
                        } else if(tempObj.userData instanceof Centroid) {
                            obj = {
                                type: 'centroid',
                                userData: tempObj.userData.cluster,
                                state: '',
                            };
                            break outer_if;
                        } else if(tempObj.userData instanceof Array) {
                            if(tempObj.userData[0].cluster) {
                                obj = {
                                    type: 'member',
                                    userData: tempObj.userData[0].cluster,
                                    state: '',
                                };
                            } else {
                                obj = {
                                    type: 'error',
                                    userData: tempObj.userData,
                                    state: '',
                                };
                            }
                            break outer_if;
                        }
                    }
            }

            if(obj) {
                if(INTERSECTED.size === 0) {

                    highlight(obj, threePar.rayc.hoverColor);
                    showInfo(obj);
                    INTERSECTED.add(obj);

                } else {

                    //if(!flags.raycaster.shiftDown) { //shift not pressed -> remove all highlights

                        /*INTERSECTED.forEach(function(o) {
                            unHighlight('hover', o);
                        });
                        unShowInfo('hover', ...INTERSECTED);
                        INTERSECTED.clear();

                        INTERSECTED.add(obj);
                        highlight(obj, threePar.rayc.hoverColor);
                        showInfo(obj);*/

                    //} else { //shift pressed

                        let isHighlighted = false;
                        INTERSECTED.forEach(function(o) {
                            if(obj.userData === o.userData) {
                                obj = o;
                                isHighlighted = true;
                            }
                        });
                        if(isHighlighted) { //if clicked object is already highlighted -> remove highlight

                            if(obj.state === 'clicked') {

                                //unHighlight('click', obj);
                                unShowInfo('click', ...INTERSECTED);
                                showInfo(...INTERSECTED);
                                highlight(obj, threePar.rayc.hoverColor);

                            } else {

                                unShowInfo('click', ...INTERSECTED);
                                INTERSECTED.add(obj);
                                showInfo(...INTERSECTED);

                                highlight(obj, threePar.rayc.hoverColor);

                            }

                            /*unHighlight('hover', obj);
                            unShowInfo('hover', ...INTERSECTED);
                            INTERSECTED.delete(obj);
                            showInfo(...INTERSECTED);*/

                        } else { //if clicked object is not yet highlighted -> add highlight

                            unShowInfo('hover', ...INTERSECTED);
                            INTERSECTED.add(obj);
                            //INTERSECTED.forEach(function(o) {
                            highlight(obj, threePar.rayc.hoverColor);
                            //});
                            showInfo(...INTERSECTED);
                        }
                   //}
                }
            } else if(!flags.raycaster.shiftDown) {

                unShowInfo('hover', ...INTERSECTED);

                INTERSECTED.forEach(function(o) {
                    if(o.state === 'clicked') {
                        highlight(o, threePar.rayc.clickColor);
                    } else {

                        unHighlight('hover', o);
                        INTERSECTED.delete(o);

                    }

                });
                if(INTERSECTED.size !== 0) {
                    showInfo(...INTERSECTED);
                }
            }
        }
    }

    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // create an array containing all objects in the scene with which the ray intersects
        let intersects = raycaster.intersectObjects(scene.children, true) ;

        // INTERSECTED = the object in the scene currently closest to the camera
        // and intersected by the Ray projected from the mouse position

        // if there is one (or more) intersections
        if (intersects.length > 0) {

            let obj;
            let tempGeom = null;

            for(let o = 0; o < intersects.length; o++) {

                const tempObj = intersects[o].object;

                if((!(intersects[o].distance.isNaN)) && (tempObj.geometry !== tempGeom) &&
                    ((Math.trunc(intersects[o].point.z * 100) / 100) >= (bd.floor * 10) - 1) &&
                    ((Math.trunc(intersects[o].point.z * 100) / 100) <= (bd.floor * 10) + 1) &&
                    (tempObj.geometry.vertices[0].z >= ((bd.floor * 10) - 1)) &&
                    (tempObj.geometry.vertices[0].z <= ((bd.floor * 10) + 1)))
                    outer_if:{

                    tempGeom = tempObj.geometry;

                    if(tempObj.userData instanceof Trajectory) {
                        obj = {
                            type: 'trajectory',
                            userData: tempObj.userData,
                            state: '',
                        };
                        break outer_if;
                    } else if(tempObj.userData instanceof Centroid) {
                        obj = {
                            type: 'centroid',
                            userData: tempObj.userData.cluster,
                            state: '',
                        };
                        break outer_if;
                    } else if(tempObj.userData instanceof Array) {
                        if(tempObj.userData[0].cluster) {
                            obj = {
                                type: 'member',
                                userData: tempObj.userData[0].cluster,
                                state: '',
                            };
                        } else {
                            obj = {
                                type: 'error',
                                userData: tempObj.userData,
                                state: '',
                            };
                        }
                        break outer_if;
                    }
                }
            }

            if(obj) {
                if(INTERSECTED.size === 0) {

                    highlight(obj, threePar.rayc.clickColor);
                    showInfo(obj);
                    obj.state = 'clicked';
                    INTERSECTED.add(obj);

                } else {

                    if(!flags.raycaster.shiftDown) { //shift not pressed -> remove all highlights

                        unShowInfo('click', ...INTERSECTED);

                        INTERSECTED.forEach(function(o) {
                            if(obj.userData === o.userData) {
                                obj = o;
                            }
                        });

                        if(obj.state === 'clicked') {
                            let k = 0;
                        } else {
                            INTERSECTED.forEach(function(o) {
                                unHighlight('click', o);
                            });
                            unShowInfo('click', ...INTERSECTED);
                            INTERSECTED.clear();

                            highlight(obj, threePar.rayc.clickColor);
                            showInfo(obj);
                            obj.state = 'clicked';
                            INTERSECTED.add(obj);
                        }

                        /*INTERSECTED.forEach(function(o) {
                            if(o.state === 'clicked') {
                                unHighlight('click', o);
                                INTERSECTED.delete(o);
                            }
                        });*/

                    } else { //shift pressed

                        let isIntersected = false;
                        INTERSECTED.forEach(function(o) {
                            if(obj.userData === o.userData) {
                                obj = o;
                                isIntersected = true;
                            }
                        });
                        if(isIntersected) { //if clicked object is already highlighted -> remove highlight

                            if(obj.state === 'clicked') {

                                unHighlight('click', obj);
                                unShowInfo('click', ...INTERSECTED);
                                INTERSECTED.delete(obj);
                                showInfo(...INTERSECTED);

                            } else {

                                unShowInfo('click', ...INTERSECTED);
                                INTERSECTED.add(obj);
                                highlight(obj, threePar.rayc.clickColor);
                                obj.state = 'clicked';
                                showInfo(...INTERSECTED);

                            }

                        } else { //if clicked object is not yet highlighted -> add highlight

                            unShowInfo('click', ...INTERSECTED);
                            INTERSECTED.add(obj);
                            highlight(obj, threePar.rayc.clickColor);
                            obj.state = 'clicked';
                            showInfo(...INTERSECTED);
                        }
                    }
                }
            } else {
                if(!flags.raycaster.shiftDown) {
                    INTERSECTED.forEach(function(o) {
                        unHighlight('click', o);
                    });
                    unShowInfo('click', ...INTERSECTED);
                    INTERSECTED.clear();
                }
            }
        }
    }

    function highlight(o, color){
        switch(o.type) {
            case 'trajectory': {
                clickTrajectory(color, o.userData, true, true, true, true);
                o.userData.clusters.customForEach(function(clus) {
                    clickCluster(color, clus, true, false, false);
                });
                break;
            }
            case 'centroid': {
                clickCluster(color, o.userData, true, true, true);
                o.userData.trajectories.forEach(function(traj) {
                    clickTrajectory(color, traj, true, true, true, true);
                });
                break;
            }
            case 'member': {
                clickCluster(color, o.userData, true, true, true);
                o.userData.trajectories.forEach(function(traj) {
                    clickTrajectory(color, traj, true, true, true, true);
                });
                break;
            }
            case 'error': {
                clickErrors(color);
                break;
            }
        }
    }
    function unHighlight(interaction, o) {
        switch (o.type) {
            case 'trajectory': {
                uncolorTrajectory(o.userData);
                o.userData.clusters.customForEach(function (clus) {
                    unClickCluster(clus);
                });
                break;
            }
            case 'centroid': {
                unClickCluster(o.userData);
                o.userData.trajectories.forEach(function (traj) {
                    uncolorTrajectory(traj);
                });
                break;
            }
            case 'member': {
                unClickCluster(o.userData);
                o.userData.trajectories.forEach(function (traj) {
                    uncolorTrajectory(traj);
                });
                break;
            }
            case 'error':
                unClickErrors();
                break;
        }

    }

    function clickTrajectory(color, traj, dots, line, clusLine, anchLine) {
        if(traj.dots && dots) {
            traj.dots.children.customForEach(function(dot) {
                dot.material.color.set(color);
                dot.material.needsUpdate = true;
            });
        }
        if(traj.line && line) {
            traj.line.material.color.set(color);
            traj.line.material.needsUpdate = true;
        }
        if(traj.clusLine && clusLine) {
            traj.clusLine.material.vertexColors = THREE.NoColors;
            traj.clusLine.material.color.set(color);
            traj.clusLine.material.needsUpdate = true;
        }
        if(traj.anchLine && anchLine) {
            //traj.drawing.anchLine.material.vertexColors = THREE.NoColors;
            traj.anchLine.material.color.set(color);
            traj.anchLine.material.needsUpdate = true;
        }
        /*if(clickClusters && (traj.clusters.length !== 0)) {
            traj.clusters.customForEach(function(clus) {
                if(clus.centDot) {
                    clus.centDot.material.color.set(threePar.rayc.clickColor);
                    clus.centDot.material.needsUpdate = true;
                }
            });
        }*/
    }
    function uncolorTrajectory(traj) {
        if (traj.dots) {
            traj.dots.children.customForEach(function(dot) {
                dot.material.color.set(traj.color);
                dot.material.needsUpdate = true;
            });
        }
        if (traj.line) {
            traj.line.material.color.set(traj.color);
            traj.line.material.needsUpdate = true;
        }
        if (traj.clusLine) {
            traj.clusLine.material.vertexColors = THREE.VertexColors;
            traj.clusLine.material.color.set(0xffffff);
            traj.clusLine.material.needsUpdate = true;
        }
        if (traj.anchLine) {
            //traj.anchLine.material.vertexColors = THREE.VertexColors;
            traj.anchLine.material.color.set(par.ln.color);
            traj.anchLine.material.needsUpdate = true;
        }
        /*if(traj.clusters.length !== 0) {
            traj.clusters.customForEach(function(clus) {
                if(clus.centDot) {
                    clus.centDot.material.color.set(clus.color);
                    clus.centDot.material.needsUpdate = true;
                }
            });
        }*/
    }
    function clickCluster(color, clus, centDot, circMesh, membDots) {
        if (clus.centDot && centDot) {
            clus.centDot.material.color.set(color);
            clus.centDot.material.needsUpdate = true;
        }
        if (clus.circMesh && circMesh) {
            clus.circMesh.material.color.set(color);
            clus.circMesh.material.needsUpdate = true;
        }
        if (clus.membDots && membDots) {
            clus.membDots.children.customForEach(function(dot) {
                dot.material.color.set(color);
                dot.material.needsUpdate = true;
            });
        }
       /* if (clickTrajectories && (clus.trajectories.size !== 0)) {
            clus.trajectories.forEach(function (traj) {
                clickTrajectory(traj, false); //ToDo
            });
        }*/
    }
    function unClickCluster(clus) {
        if (clus.centDot) {
            clus.centDot.material.color.set(clus.color);
            clus.centDot.material.needsUpdate = true;
        }
        if (clus.circMesh) {
            clus.circMesh.material.color.set(clus.color);
            clus.circMesh.material.needsUpdate = true;
        }
        if (clus.membDots) {
            clus.membDots.children.customForEach(function(dot) {
                dot.material.color.set(clus.color);
                dot.material.needsUpdate = true;
            });
        }
        /*if (clus.trajectories.size !== 0) {
            clus.trajectories.forEach(function (traj) {
                uncolorTrajectory(traj)
            });
        }*/
    }
    function clickErrors(color) {
        if (draw.errs) {
            draw.errs.children.customForEach(function(dot) {
                dot.material.color.set(color);
                dot.material.needsUpdate = true;
            });
        }
    }
    function unClickErrors() {
        if (draw.errs) {
            draw.errs.children.customForEach(function(dot) {
                dot.material.color.set(par.cl.errors.color);
                dot.material.needsUpdate = true;
            });
        }
    }

    function showInfo(...os) {

        const tempInfo = [];
        let infos = {
            basic: {
                info: [],
            },
            analysis: {
                info: [],
            },
            extensive: {
                info: [],
            },
        };
        let info;

        os.customForEach(function(o) {
            if (o.type !== 'error') {
                if(bd.iT.basic) infos.basic.info.push(o.userData.getBasicInfo());
                if(bd.iT.analysis) infos.analysis.info.push(o.userData.getAnalysisInfo());
                if(bd.iT.extensive) infos.extensive.info.push(o.userData.getExtensiveInfo());
            } else {
                //tempInfo.push(["Number of Errors: ", o.userData.length]);
            }
        });

        infos = reorderInfo(infos);

        if(os.length === 1) {

            for(let type in infos) {
                for(let item in infos[type]) {
                    if(infos[type].hasOwnProperty(item)) {
                        tempInfo.push([item, infos[type][item][0]]);
                    }
                }
            }

            info = new infoCont(
                ["Description", "Content"],
                writeInfo(tempInfo)
            );

        } else if(os.length === 2) {

            for(let type in infos) {
                for(let item in infos[type]) {
                    if(infos[type].hasOwnProperty(item)) {
                        tempInfo.push([item, infos[type][item][0], infos[type][item][1],
                            combineInfos(item, infos[type][item][0], infos[type][item][1])]);
                    }
                }
            }

            info = new infoCont(
                ["Description", "Content 1", "Content 2", "Comparison 1:2"],
                writeInfo(tempInfo)
            );

        } else {

            for(let type in infos) {
                for(let item in infos[type]) {
                    if (infos[type].hasOwnProperty(item)) {
                        tempInfo.push([item, combineInfos(item, ...infos[type][item])]);
                    }
                }
            }
            //ToDo: getDescription(item) function that replaces the desc for single objs with the one for multiple

            info = new infoCont(
                ["Description", "Comparison"],
                writeInfo(tempInfo)
            );
        }

        info.createDiv();
        infoDiv.appendChild(info.div);

        os.customForEach(function (o) {
            o.info = info;
        });

        function reorderInfo(infos) {
            for(let type in infos) {
                if(infos.hasOwnProperty(type)) {
                    for(let it in infos[type].info[0]) {
                        if(infos[type].info[0].hasOwnProperty(it)) {
                            infos[type][it] = [];
                        }
                    }
                    for(let obj in infos[type].info) {
                        if(infos[type].info.hasOwnProperty(obj)) {
                            for(let item in infos[type].info[obj]) {
                                if(infos[type].info[obj].hasOwnProperty(item)) {
                                    infos[type][item].push(infos[type].info[obj][item]);
                                }
                            }
                        }
                    }
                    delete infos[type].info;
                }
            }
            return infos;
        }
        function combineInfos(item, ...info) {

            let r;

            if(info.length === 2) {
                switch(item) {
                    case 'Type':
                        r = (info[0] === info[1]) ? "==" : "!=";
                        break;
                    case 'ID':
                        r = "";
                        break;
                    case 'Floor':
                        r = (info[0] === info[1]) ? "==" : "!=";
                        break;
                    case 'Length':
                        r = {
                            'm': Math.trunc((info[1]['m']  - info[0]['m']) * 100) / 100,
                            'pts': info[1]['pts'] - info[0]['pts'],
                        };
                        break;
                    case 'Duration':
                        r = {
                            's': Math.trunc(info[1]['s'] - info[0]['s']),
                        };
                        break;
                    case 'Avg. speed':
                        r = {
                            'km/h': Math.trunc((info[1]['km/h'] - info[0]['km/h']) * 100) / 100,
                        };
                        break;
                    case 'Visited clusters':
                        r = Levenshtein.get(info[0], info[1]); //edit distance
                        break;
                    case 'Members':
                        r = info[1] - info[0];
                        break;
                    case 'Edges':
                        r = {
                            'in': info[1]['in'] - info[0]['in'],
                            'out': info[1]['out'] - info[0]['out'],
                        };
                        break;
                    case 'Ts Passing':
                        r = info[1] - info[0];
                        break;
                    case 'Origins':
                    case 'Destinations':
                        r = new Set([...info[0]].filter(x => info[1].has(x)));
                        if(r.size === 0) r = "-";
                        break;
                    case 'Centroid':
                        r = {
                            'm': Math.trunc(getSpatialDistance(info[0], info[1]) * 100) / 100,
                        };
                        break;
                    case '':
                    case '':
                    case '':
                    case '':
                }
            }
            else if(info.length >= 3) {
                switch(item) {
                    case 'Type':
                        let types = groupBy(info, function(item) {return [item]});
                        r = "";
                        for(let type in types) {
                            r += type.slice(2,-2) + ": " + types[type].length;
                        }
                        break;
                    case 'ID':
                        r = info;
                        break;
                    case 'Floor':
                        let floors = groupBy(info, function(item) {return [item]});
                        r = "";
                        for(let floor in floors) {
                            r += "Floor " + floor.slice(1,-1) + ": " + floors[floor].length;
                        }
                        break;
                    case 'Length':
                        r = {
                            'm': 0,
                            'pts': 0,
                        };
                        info.customForEach(function(i) {
                            r['m'] += i['m'];
                            r['pts'] += i['pts'];
                        });
                        r['m'] = Math.trunc((r['m'] / info.length) * 100) / 100;
                        r['pts'] = Math.trunc((r['pts'] / info.length) * 100) / 100;
                        break;
                    case 'Duration':
                        r = {
                            's': 0,
                        };
                        info.customForEach(function(i) {
                            r['s'] += i['s'];
                        });
                        r['s'] = Math.trunc((r['s'] / info.length) * 100) / 100;
                        break;
                    case 'Avg. speed':
                        r = {
                            'km/h': 0,
                        };
                        info.customForEach(function(i) {
                            r['km/h'] += i['km/h'];
                        });
                        r['km/h'] = Math.trunc((r['km/h'] / info.length) * 100) / 100;
                        break;
                    case 'Visited clusters':
                        const visited = new Set();
                        info.customForEach(function(v) {
                            v.customForEach(function(c) {
                                visited.add(c);
                            });
                        });
                        r = visited;
                        break;
                    case 'Members':
                        r = 0;
                        info.customForEach(function(i) {
                            r += i;
                        });
                        r = Math.trunc((r / info.length) * 100) / 100;
                        break;
                    case 'Edges':
                        r = {
                            'in': 0,
                            'out': 0,
                        };
                        info.customForEach(function(i) {
                            r['in'] += i['in'];
                            r['out'] += i['out'];
                        });
                        r['in'] = Math.trunc((r['in'] / info.length) * 100) / 100;
                        r['out'] = Math.trunc((r['out'] / info.length) * 100) / 100;
                        break;
                    case 'Ts Passing':
                        r = 0;
                        info.customForEach(function(i) {
                            r += i;
                        });
                        r = Math.trunc((r / info.length) * 100) / 100;
                        break;
                    case 'Origins':
                    case 'Destinations':
                        //r = new Set([...info[0]].filter(x => info[1].has(x)));
                        //if(r.size === 0) r = "-";
                        r = "";
                        break;
                    case 'Centroid':
                        r = "";
                        break;
                    case '':
                    case '':
                    case '':
                    case '':
                }
            }

            return r;
        }
        function writeInfo(tempInfo) {

            const ti = [];

            tempInfo.customForEach(function(line) {

                let arr = [line[0]];

                for(let i = 1; i < line.length; i++) {

                    if(line[i] instanceof Array) {

                        arr.push(line[i].join(","));

                    } else if(line[i] instanceof Set) {

                        let IDs = [];
                        line[i].forEach(function(c) {
                            IDs.push(c);
                        });
                        IDs.sort((a,b) => (a - b));
                        arr.push(IDs.join(", "));

                    } else if(line[i] instanceof Object) {

                        let str = "";
                        for(let o in line[i]) {
                            if(line[i].hasOwnProperty(o)){
                                str += (line[i][o] + " " + o + " / ");
                            }
                        }
                        str = str.slice(0,-3);
                        arr.push(str);

                    } else {
                        arr.push(line[i]);
                    }
                }
                ti.push(arr);
            });

            return ti;
        }
    }
    function unShowInfo(interaction, ...os) {
        for(let o in os) {
            if(os.hasOwnProperty(o) && os[o].info) {
                if(document.getElementById('infoDiv')) {
                    document.getElementById('infoDiv').removeChild(os[o].info.div);
                }
                break;
            }
        }
        os.customForEach(function(o) {
            if(o.info) delete o.info;
        });
    }

    //temp code inside
    function onDocumentMouseMove(event) {
        // the following line would stop any other event handler from firing
        // (such as the mouse's TrackballControls)
        // event.preventDefault();

        // update the mouse variable
//        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
//        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

//--MORE-INITS----------------------------------------------------------------------------------------------------------

    function initWindowResizeListeners() {
        window.addEventListener(
            'resize',
            function() {
                updateRenderer();
                updateCamera();
            },
            false);
    }
    function initKeypressListener() {
        document.addEventListener("keydown", function(event) {
            if (event.keyCode === 16) {
                flags.raycaster.shiftDown = true;
            }
        });
        document.addEventListener("keyup", function(event) {
            if (event.keyCode === 16) {
                flags.raycaster.shiftDown = false;
            }
        });
    }

    function initBackgroundFileInput() {
        const buildingFileInput = document.createElement('input');
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.accept = "image/*";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        document.body.appendChild(buildingFileInput);

        buildingFileInput.addEventListener('change', function () {
            const file = buildingFileInput.files[0];
            const fileName = buildingFileInput.files[0].name;
            const fileType = /image.*/;

            if(file.type.match(fileType)) {

                deleteEverything();

                let f = '';
                let first = -1;

                for (let i = 0, len = fileName.length; i < len; i++) {

                    const m = fileName[i].match(/\d+/g);

                    if(m || (fileName[i] === '-')) {

                        f += fileName[i];
                        if(first === -1) first = i;

                    }
                }

                bd.filePath = fileName.slice(0, first);
                bd.fileExt = fileName.slice(-4, fileName.length);
                bd.floor = parseInt(f);

                //bd.img = file;


                //changeFloors();
            } else {
                alert("File not supported");
            }
        });
        buildingFileClicker = {
            loadBuildingFile: function () {
                document.getElementById("buildingFileInput").click();
            }
        };
    }
    function initPositionFileInput() {
        const dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild(dataFileInput);

        dataFileInput.addEventListener('change', function () {
            const fileCount = dataFileInput.files.length;
            const result = [];
            for(let file = 0; file < fileCount; file++) {
                const reader = new FileReader();
                reader.onload = function () {
                    result.push(this.result);
                    if (result.length === fileCount) {
                        pointList = loadPointList(result);
                        const sortedList = [];
                        pointList.customForEach(function(pl) {
                            sortedList.push(sortAndGroupList(pl, false, par.tj.cutTime));
                        });
                        sortedList.customForEach(function(pl) {
                            newTrajectories(pl);
                        });
                        data.trjs.valid = true;

                        deleteClusterTrajectories();
                        showCheckedDrawings();
                    }
                };
                reader.readAsText(dataFileInput.files[file]);
            }
            this.value = null; //remove filename from input
        });
        trajectoryFileClicker = {
            loadDataFile: function () {
                document.getElementById("dataFileInput").click();
            }
        };
    }
    function initGroundtruthFileInput() {
        const dataFileInput = document.createElement('input');
        dataFileInput.id = "groundtruthFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild(dataFileInput);

        dataFileInput.addEventListener('change', function () {
            const fileCount = dataFileInput.files.length;
            const result = [];
            for(let file = 0; file < fileCount; file++) {
                const reader = new FileReader();
                reader.onload = function () {
                    result.push(this.result);
                    if (result.length === fileCount) {
                        groundtruthList = loadGroundtruthList(result);
                        const sortedGts = [];
                        groundtruthList.customForEach(function(gt) {
                            //sortedGts.push(sortAndGroupList(gt, true, par.gt.cutTime));
                            sortedGts.push(sortAndGroupList(gt, false, par.tj.cutTime));
                        });
                        sortedGts.customForEach(function(gt) {
                            newGroundtruth(gt);
                        });
                        data.grts.valid = true;

                        //newTrajectories(sortAndGroupList(pointList, false));
                        hideGroundtruthTrajectories();
                        showCheckedDrawings();
                    }
                };
                reader.readAsText(dataFileInput.files[file]);
            }
            this.value = null; //remove filename from input
        });
        groundtruthFileClicker = {
            loadGroundtruthFile: function () {
                document.getElementById("groundtruthFileInput").click();
            }
        };
    }
    function initDatGUI() {
        //gui = new dat.GUI({autoPlace: false});
        gui = new dat.GUI({autoPlace: false, right: 0});

        const fLoad = gui.addFolder(guiPar.folders.load.name);
        fLoad.add(buildingFileClicker, guiPar.buttons.bgLoader.func).name(guiPar.buttons.bgLoader.name);
        fLoad.add(trajectoryFileClicker, guiPar.buttons.dataLoader.func).name(guiPar.buttons.dataLoader.name);
        fLoad.add(groundtruthFileClicker, guiPar.buttons.gtLoader.func).name(guiPar.buttons.gtLoader.name);
        fLoad.open();

        const fDelete = gui.addFolder(guiPar.folders.del.name);
        fDelete.add(this, guiPar.buttons.delAll.func).name(guiPar.buttons.delAll.name);
        fDelete.add(this, guiPar.buttons.delTrajectories.func).name(guiPar.buttons.delTrajectories.name);

        const fBdSettings = gui.addFolder(guiPar.folders.bdSettings.name);
        fBdSettings.add(bd, guiPar.sliders.scale.func, guiPar.sliders.scale.min, guiPar.sliders.scale.max)
                        .step(guiPar.sliders.scale.step).name(guiPar.sliders.scale.name);

        const fViewSettings = gui.addFolder(guiPar.folders.viewSettings.name);
        fViewSettings.add(bd, guiPar.checkboxes.toggleGrid.func).name(guiPar.checkboxes.toggleGrid.name);
        fViewSettings.add(bd, guiPar.sliders.zoom.func, guiPar.sliders.zoom.min, guiPar.sliders.zoom.max)
                            .step(guiPar.sliders.zoom.step).name(guiPar.sliders.zoom.name);
        fViewSettings.add(this, guiPar.buttons.screenshot.func).name(guiPar.buttons.screenshot.name);

        const fLineTypes = gui.addFolder(guiPar.folders.lineTypes.name);
        fLineTypes.add(bd, guiPar.sliders.floor.func, guiPar.sliders.floor.min, guiPar.sliders.floor.max)
                        .step(guiPar.sliders.floor.step).name(guiPar.sliders.floor.name).listen();
        for(let ch in guiPar.checkboxes.lineTypes.choices) {
            if(guiPar.checkboxes.lineTypes.choices.hasOwnProperty(ch)) {
                fLineTypes.add(bd.lt, ch).name(guiPar.checkboxes.lineTypes.choices[ch].name);
            }
        }
        fLineTypes.open();

        const fDataSettings = gui.addFolder(guiPar.folders.dataSettings.name);
        fDataSettings.add(bd, guiPar.sliders.cutTime.func, guiPar.sliders.cutTime.min, guiPar.sliders.cutTime.max)
                            .step(guiPar.sliders.cutTime.step).name(guiPar.sliders.cutTime.name);
        fDataSettings.add(bd, guiPar.sliders.maxClusterRad.func, guiPar.sliders.maxClusterRad.min, guiPar.sliders.maxClusterRad.max)
                            .step(guiPar.sliders.maxClusterRad.step).name(guiPar.sliders.maxClusterRad.name);
        fDataSettings.add(bd, guiPar.sliders.redist.func, guiPar.sliders.redist.min, guiPar.sliders.redist.max)
                            .step(guiPar.sliders.redist.step).name(guiPar.sliders.redist.name);

        const fInfoSettings = gui.addFolder(guiPar.folders.infoSettings.name);
        for(let ch in guiPar.checkboxes.infoTypes.choices) {
            if(guiPar.checkboxes.infoTypes.choices.hasOwnProperty(ch)) {
                fInfoSettings.add(bd.iT, ch).name(guiPar.checkboxes.infoTypes.choices[ch].name);
            }
        }
        fInfoSettings.open();


        const guiDiv = document.getElementById('guiDiv');
        guiDiv.appendChild(gui.domElement);

    } //dat.gui

//--LOAD-BASICS---------------------------------------------------------------------------------------------------------

    function loadNewBgMesh(buildingName, floor) {
        const buildingPath = par.bg.dir + buildingName;
        let backgroundMesh;
        let bgMaterial;// = new THREE.MeshBasicMaterial();

        //let image = new Image();
        //image.src = URL.createObjectURL(bd.img);
        //const texture = new THREE.Texture(image);

        const bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            ///URL.createObjectURL(bd.img),
            function (texture) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //translate pixels into meters -- ATTENTION! BG-imgs have to have same size!
                bd.width = texture.image.naturalWidth * bd.scaleFraction;
                bd.height = texture.image.naturalHeight * bd.scaleFraction;

                //create bgPlane
                const backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push(new THREE.Vector3(0, 0, floor * 10 + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(0, -bd.height, floor * 10 + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, -bd.height, floor * 10 + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, 0, floor * 10 + par.bg.corrZ));

                backgroundPlane.faces.push(new THREE.Face3(0, 1, 3));
                backgroundPlane.faces.push(new THREE.Face3(1, 2, 3));//backgroundPlane.computeFaceNormals();
                backgroundPlane.faceVertexUvs[0] = [];
                backgroundPlane.faceVertexUvs[0].push([new THREE.Vector2(0, 1),
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );

                draw.bgMs[floor] = backgroundMesh;
                scene.add(draw.bgMs[floor]);

                genGrid(floor);
                drawGrid(floor);
            },
            function () {
            },
            function () {
                console.log('BG-loading failed');
            }
        );
    } //three.js
    function genGrid(floor) {

        let coordLines = [];

        for (let i = 0; i < ( bd.height ); i += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: 0,
                    y: i,
                    f: floor,
                },
                p1: {
                    x: bd.width,
                    y: i,
                    f: floor,
                }
            });
        }
        for (let j = 0; j < ( bd.width ); j += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: j,
                    y: 0,
                    f: floor,
                },
                p1: {
                    x: j,
                    y: bd.height,
                    f: floor,
                }
            });
        }
        data.grds[floor] = {};
        data.grds[floor].value = coordLines;
        data.grds[floor].valid = true;
    }
    function drawGrid(floor) {

        const coordGeometry = new THREE.Geometry();
        data.grds[floor].value.customForEach(function(line) {
            coordGeometry.vertices.push(new THREE.Vector3(line.p0.x, -line.p0.y, line.p0.f * 10 + par.gd.corrZ));
            coordGeometry.vertices.push(new THREE.Vector3(line.p1.x, -line.p1.y, line.p1.f * 10 + par.gd.corrZ));
        });

        const coordMaterial = new THREE.LineBasicMaterial({
            color: par.gd.line.color,
            opacity: par.gd.line.color,
        });

        data.grds[floor].drawing = new THREE.LineSegments(coordGeometry, coordMaterial);
        if(bd.grid) scene.add(data.grds[floor].drawing);
    } //three.js -- disabled

//--LOAD-TRAJECTORIES---------------------------------------------------------------------------------------------------
//  ToDo: Implement function for removing first and last locations of recording

    function loadPointList(readerResult) {

        data.trjs.valid = false;
        data.clts.valid = false;
        data.errs.valid = false;

        const list = [];

        //--create-Point-Objects--------------------------------------------------------------------------------------------
        readerResult.customForEach(function(file) {

            let pointList = [];

            const tempList = parseCSV(file);

            tempList.splice(0, par.csv.removeCount);
            tempList.splice(-par.csv.removeCount);

            tempList.customForEach(function (point) {
                point.ID = flags.data.points;
                flags.data.points++;
                const p = new Point(point);
                pointList.push(p);
            });

            list.push(pointList);
        });

        return list;
    }
    function loadGroundtruthList(readerResult) {

        data.grts.valid = false;

        const list = [];

        //--create-Point-Objects--------------------------------------------------------------------------------------------
        readerResult.customForEach(function(file) {

            let pointList = [];

            const tempList = parseCSV(file);

            //ToDo: temporarily reinstated, remove splices
            tempList.splice(0, par.csv.removeCount);
            tempList.splice(-par.csv.removeCount);

            tempList.customForEach(function (point) {
                const p = new Point(point);
                pointList.push(p);
            });

            list.push(pointList);
        });

        return list;
    }

    function parseCSV(csvString) {
        const parseResult = Papa.parse(csvString, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            comments: '#',
            //step: true,
            beforeFirstChunk: function (chunk) {
                const rows = chunk.split(/\r\n|\r|\n/);
                rows[0] = par.csv.header;
                return rows.join("\r\n");
            }
        });
        return parseResult.data;
    }

    function sortAndGroupList(pL, floor, cutTime) {
        //--sort-Points-----------------------------------------------------------------------------------------------------
        let pointList = sortPointList(pL);

        const first = groupPointListByDid;
        const second = groupPointListByTime;
        const third = groupPointListByFloor;

        const pointListByOne = first(pointList);
        const pointListByOneByTwo = [];
        const pointListByOneByTwoByThree = [];

        for (let one in pointListByOne) {
            if (pointListByOne.hasOwnProperty(one)) {
                pointListByOneByTwo[one] = second(pointListByOne[one], cutTime);
            }
        }

        if(!floor) {
            return pointListByOneByTwo;
        } else {
            for (let one in pointListByOneByTwo) {
                if (pointListByOneByTwo.hasOwnProperty(one)) {
                    pointListByOneByTwoByThree[one] = [];
                    for (let two in pointListByOneByTwo[one]) {
                        if (pointListByOneByTwo[one].hasOwnProperty(two)) {
                            pointListByOneByTwoByThree[one][two] = third(pointListByOneByTwo[one][two]);
                        }
                    }
                }
            }
            return pointListByOneByTwoByThree;
        }

        /*const pointListByOne = groupPointListByDid(pointList);

        const pointListByDIDByFloor = [];
        pointListByOne.customForEach(function(didList) {
            pointListByDIDByFloor.push(groupPointListByFloor(didList));
        });

        const pointListByDIDByFloorByTime = [];
        pointListByDIDByFloor.customForEach(function(didList) {
           didList.customForEach(function(timeList) {
               pointListByDIDByFloorByTime.push(groupPointListByFloor(timeList));
           });
        });
        return pointListByOneByTwoByThree;*/
    }
    function sortPointList(pointList) {
        pointList.sort(
            firstBy("did")
                .thenBy("t")
                //.thenBy("f")
        );
        return pointList;
    }
    function groupPointListByDid(pointList) {
        return groupBy(pointList, function(item) {
                return [item.did]; //, item.t
            }
        );
    }
    function groupPointListByTime(pointList, cutTime) {

        const pointListByTime = [];

        let tempTime = pointList[0].t;
        let tempTimeArray = [];

        pointList.customForEach(function(point) {
            if (tempTime + cutTime < point.t) {
                pointListByTime.push(tempTimeArray);
                tempTimeArray = [];
                tempTimeArray.push(point);
                tempTime = point.t;
            } else {
                tempTimeArray.push(point);
                tempTime = point.t;
            }
        });
        pointListByTime.push(tempTimeArray);
        return pointListByTime;
    }
    function groupPointListByFloor(pointList) {
        return groupBy(pointList, function(item) {
                return [item.f]; //, item.t
            }
        );
    }
    function groupBy(array, f) {

        const groups = {};
        array.customForEach(
            function(object) {
                const group = JSON.stringify(f(object));
                groups[group] = groups[group] || []; //if groups[group] doesn't exist, [] is assigned
                groups[group].push(object);
            }
        );
        return groups;
    }

    function newTrajectories(pL) {
        //--create-Trajectories---------------------------------------------------------------------------------------------
        const pointListByDIDByTimeByFloor = pL;

        for(let did in pointListByDIDByTimeByFloor) {
            if(pointListByDIDByTimeByFloor.hasOwnProperty(did)) {
                for(let t in pointListByDIDByTimeByFloor[did]) {
                    if(pointListByDIDByTimeByFloor[did].hasOwnProperty(t)) {

                        const points = pointListByDIDByTimeByFloor[did][t];
                        let currentFloor = pointListByDIDByTimeByFloor[did][t][0].f;
                        let pointsList = [];
                        let tempList = [];

                        for (let p = 0; p < points.length; p++) {

                            if(currentFloor === points[p].f) {
                                tempList.push(points[p]);
                            } else {
                                points[p].floorChangeFrom = points[p-1];
                                currentFloor = points[p].f;
                                points[p-1].floorChangeTo = points[p];
                                pointsList.push(tempList);
                                tempList = [];
                                tempList.push(points[p]);
                            }
                        }
                        pointsList.push(tempList);

                        pointsList.customForEach(function(list) {

                            if(list.length > 1) {

                                const tempTrajectory = new Trajectory(list, list[0].f, flags.data.trajectories);
                                flags.data.trajectories++;

                                list.customForEach(function(p) {
                                    p.trajectory = tempTrajectory;
                                });

                                data.trjs.value.push(tempTrajectory);
                            }
                        });

                        data.trjs.value.customForEach(function(tempTrajectory) {

                            let tempPrevPoint = tempTrajectory.rawPoints[0];
                            if(tempPrevPoint.floorChangeFrom) {
                                tempTrajectory.floorChangeFrom =
                                    tempPrevPoint.floorChangeFrom.trajectory; // || tempPrevPoint.floorChangeFrom;

                                /*if(tempTrajectory.floorChangeFrom.floorChangeTo instanceof Point) {
                                    tempTrajectory.floorChangeFrom.floorChangeTo = tempTrajectory;
                                }*/
                            }

                            for (let p = 0; p < tempTrajectory.rawPoints.length; p++) {

                                tempTrajectory.rawPoints[p].trajectory = tempTrajectory;

                                tempPrevPoint = tempTrajectory.rawPoints[p];
                            }

                            if(tempPrevPoint.floorChangeTo) {
                                tempTrajectory.floorChangeTo =
                                    tempPrevPoint.floorChangeTo.trajectory; // || tempPrevPoint.floorChangeTo;

                                /*if(tempTrajectory.floorChangeTo.floorChangeFrom instanceof Point) {
                                 tempTrajectory.floorChangeTo.floorChangeFrom = tempTrajectory;
                                 }*/
                            }
                        });
                    }
                }
            }
        }
    }
    function newGroundtruth(pL) {
        /*const pointListByDIDByTimeByFloor = pL;

        for(let did in pointListByDIDByTimeByFloor) {
            if(pointListByDIDByTimeByFloor.hasOwnProperty(did)) {
                for(let t in pointListByDIDByTimeByFloor[did]) {
                    if(pointListByDIDByTimeByFloor[did].hasOwnProperty(t)) {
                        for (let f in pointListByDIDByTimeByFloor[did][t]) {
                            if (pointListByDIDByTimeByFloor[did][t].hasOwnProperty(f)) {

                                const tempTrajectory = new Trajectory(pointListByDIDByTimeByFloor[did][t][f], f, flags.data.trajectories);
                                flags.data.trajectories++;

                                tempTrajectory.rawPoints.customForEach(function(pt) {
                                    pt.trajectory = tempTrajectory;
                                });

                                if (tempTrajectory.rawPoints.length > 1) {

                                    let tempPrevPoint = tempTrajectory.rawPoints[0];

                                    for (let p = 0; p < tempTrajectory.rawPoints.length; p++) {
                                        tempPrevPoint = tempTrajectory.rawPoints[p];
                                    }
                                    data.grts.value.push(tempTrajectory);
                                }
                            }
                        }
                    }
                }
            }
        }*/

        const pointListByDIDByTimeByFloor = pL;

        for(let did in pointListByDIDByTimeByFloor) {
            if(pointListByDIDByTimeByFloor.hasOwnProperty(did)) {
                for(let t in pointListByDIDByTimeByFloor[did]) {
                    if(pointListByDIDByTimeByFloor[did].hasOwnProperty(t)) {

                        const points = pointListByDIDByTimeByFloor[did][t];
                        let currentFloor = pointListByDIDByTimeByFloor[did][t][0].f;
                        let pointsList = [];
                        let tempList = [];

                        for (let p = 0; p < points.length; p++) {

                            if(currentFloor === points[p].f) {
                                tempList.push(points[p]);
                            } else {
                                points[p].floorChangeFrom = points[p-1];
                                currentFloor = points[p].f;
                                points[p-1].floorChangeTo = points[p];
                                pointsList.push(tempList);
                                tempList = [];
                                tempList.push(points[p]);
                            }
                        }
                        pointsList.push(tempList);

                        pointsList.customForEach(function(list) {

                            if(list.length > 1) {

                                const tempTrajectory = new Trajectory(list, list[0].f, null);


                                list.customForEach(function(p) {
                                    p.trajectory = tempTrajectory;
                                });

                                data.grts.value.push(tempTrajectory);
                            }
                        });

                        /*data.grts.value.customForEach(function(tempTrajectory) {

                            let tempPrevPoint = tempTrajectory.rawPoints[0];
                            if(tempPrevPoint.floorChangeFrom) {
                                tempTrajectory.floorChangeFrom =
                                    tempPrevPoint.floorChangeFrom.trajectory; // || tempPrevPoint.floorChangeFrom;

                                /!*if(tempTrajectory.floorChangeFrom.floorChangeTo instanceof Point) {
                                 tempTrajectory.floorChangeFrom.floorChangeTo = tempTrajectory;
                                 }*!/
                            }

                            for (let p = 0; p < tempTrajectory.rawPoints.length; p++) {

                                tempTrajectory.rawPoints[p].trajectory = tempTrajectory;

                                tempPrevPoint = tempTrajectory.rawPoints[p];
                            }

                            if(tempPrevPoint.floorChangeTo) {
                                tempTrajectory.floorChangeTo =
                                    tempPrevPoint.floorChangeTo.trajectory; // || tempPrevPoint.floorChangeTo;

                                /!*if(tempTrajectory.floorChangeTo.floorChangeFrom instanceof Point) {
                                 tempTrajectory.floorChangeTo.floorChangeFrom = tempTrajectory;
                                 }*!/
                            }
                        });*/
                    }
                }
            }
        }
    }

//--CLUSTERING----------------------------------------------------------------------------------------------------------
//  ToDo: data.clts.points.push(cluster.members) --> change .points. to .members

    function cluster(trajs) {
        const vertices = [];

        flags.data.subsaPoints = 0;

        trajs.customForEach(function(traj) {
            traj.subsaPoints = subsamplePoints(traj);
            vertices.push(traj.subsaPoints);
        });

        console.log("subsaP: " + flags.data.subsaPoints);

        //centroid seed
        const P = vertices; //Points
        const G = generateGrid(P); //Grid
        const R = seedCentroids(P, G); //Results

        flags.clustering.redistChange = true;
        let i = 0;
        while((i < bd.redist) && flags.clustering.redistChange) {
            redistributePoints(P, R, G);
            recalculateCentroids(R, G);
            //console.log(i);
            i++;
        }
        let ml = 0;
        R.customForEach(function(cluster) {
            if(ml < cluster.members.length) ml = cluster.members.length;
        });

        R.customForEach(function(cluster) {
            //cluster.color = Math.random() * par.ct.color + par.ct.corrColor;
            const scale = chroma.scale(par.cl.colorScaleType).domain([0,ml]);
            cluster.color = scale(cluster.members.length).darken(par.cl.colorDarkenFactor).hex();
            data.clts.value.push(cluster); //ToDo
        });
        data.clts.valid = true;


        //build graph

        trajs.customForEach(function(traj) {
            traj.findClusters();
        });

        trajs.customForEach(function(traj) {
            /*if(traj.floorChangeFrom) {
                traj.clusters[0].addPrevCluster(traj.floorChangeFrom.clusters[traj.floorChangeFrom.clusters.length - 1]);
            }*/
            if(traj.floorChangeTo) {
                traj.clusters[traj.clusters.length - 1].addNextCluster(traj.floorChangeTo.clusters[0]);
            }
        });

        data.edgs.valid = false;
        data.clts.value.customForEach(function(clus) {
            createEdges(clus);
        });
        data.edgs.valid = true;
    }

    function subsamplePoints(traj) {
        const vertices = [];//R = Radius for subsampling, r = radius remaining for next segment, i = iterator, p0 = first point of traj, //pA and pB are start and end of segment to be subsampled, D = dist between pA and pB, d = remaining distance
        //p = subsampled point, vh = ratio of _________ (?),
        const points = traj.rawPoints;

        const R = par.subsaRadius;
        let r = R;

        const p0 = new Point({
            did: points[0].did,
            x: points[0].x,
            y: points[0].y,
            f: points[0].f,
            t: points[0].t,
            traj: traj,
            ID: flags.data.subsaPoints,
        });
        p0.floorChangeFrom = points[0].floorChangeFrom || null;

        flags.data.subsaPoints++;

        //data.subsaPnts.push(p0); //testing

        vertices.push(p0);

        let tempPrevPoint = p0;

        for (let i = 0; i < points.length - 2; i++) {
            if (points.hasOwnProperty(i)) {

                const pA = points[i];
                const pB = points[i + 1];

                const D = getSpatialDistance(pA, pB);
                let d = D;
                while (d > r) {
                    const vh = ( r + ( D - d ) ) / D;// t not interpolated!! f not interpolated
                    const p = new Point({
                        did: pA.did,
                        x: (1 - vh) * pA.x + vh * pB.x,
                        y: (1 - vh) * pA.y + vh * pB.y,
                        f: pA.f,
                        t: pA.t,
                        traj: traj,
                        ID: flags.data.subsaPoints,
                    });
                    flags.data.subsaPoints++;

                    tempPrevPoint = p;

                    vertices.push(p);

                    d -= r;
                    r = R;
                }
                r -= d;
            }
        }
        tempPrevPoint.floorChangeTo = points[points.length - 1].floorChangeTo || null;

        return vertices;
    }
    function generateGrid(points) {

        const P = points;
        const G = {
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0,
            grid: []
        };
        for (let i in P) {
            if(P.hasOwnProperty(i)){
                for (let j in P[i]) {
                    if(P[i].hasOwnProperty(j)){
                        const p = P[i][j];
                        if (G.xMin > p.x) G.xMin = p.x;
                        if (G.xMax < p.x) G.xMax = p.x;
                        if (G.yMin > p.y) G.yMin = p.y;
                        if (G.yMax < p.y) G.yMax = p.y;
                    }
                }
            }
        }
        for (let x = G.xMin; x <= G.xMax; x += bd.maxRadius) {
            const gX = [];
            for (let y = G.yMin; y <= G.yMax; y += bd.maxRadius) {
                const gY = [];
                gX.push(gY);
            }
            G.grid.push(gX);
        }
        return G;
    }
    function seedCentroids(points, G) {
        const P = points;
        const R = []; //results

        P.customForEach(function(t) {
            t.customForEach(function(p) {
                putInProperGroup(p, R, G);
            });
        });
        return R;
    }
    function redistributePoints(P, R, G) {
        const originList = {};
        flags.clustering.redistChange = false;

        //--Remember number of members of each group, them remove members from group
        let r = 0;
        while(r < R.length) {
            if(R.hasOwnProperty(r)){
                originList[r] = R[r].members.length;
                //R[r].members = [];
                R[r].clearMembers();
            }
            r++;
        }
        data.errs.value = [];
        data.errs.valid = false;

        let cnt = 0;

        //--Assign every Point to a group
        P.customForEach(function(t) {
            t.customForEach(function(p) {

                let cent = getClosestCentroid(p, G);
                if (cent !== null) {// FEHLER! WARUM KANN c NULL SEIN? -> Kein centroid in reichweite

                    cent.cluster.addMember(p);

                } else {

                    data.errs.value.push(p); //ToDo
                    cnt++;
                }
            });
        });

        console.log('redistPoints: No Centroid found in ' + cnt + ' cases!');

        //test for changes
        r = 0;
        while(r < R.length) {
            if(R.hasOwnProperty(r)){
                if(originList[r] !== R[r].members.length) {
                    flags.clustering.redistChange = true;
                }
            }
            r++;
        }
        data.errs.valid = true;
    }
    function recalculateCentroids(R, G) {

        //console.log('start' + R.length);

        const tempR = R;
        R = [];

        let cnt = 0;

        for(let r = 0; r < tempR.length; r++) {
            if(tempR.hasOwnProperty(r)){
                let clus = tempR[r];
                const cent = clus.centroid;
                let gc = getGridPosition(cent, G);

                const index = G.grid[gc.i][gc.j].indexOf(cent);
                G.grid[gc.i][gc.j].splice(index, 1);

                if(clus.members.length !== 0) {

                    clus.updateCentroid();

                    gc = getGridPosition(clus.centroid, G);
                    G.grid[gc.i][gc.j].push(clus.centroid);

                    R.push(clus);

                } else {
                    let k = 0;
                }
            }
        }
        //console.log('end ' + R.length + ', Number of merged centroids: ' + cnt);
    }

    function putInProperGroup(p, R, G) {
        const cent = getClosestCentroid(p, G);
        let clus = new Cluster();
        let gc;

        if (cent === null) {
            clus.centroid = new Centroid(p);
            clus.addMember(p);

            R.push(clus);
        } else {
            clus = cent.cluster; // g is group with centroid cent // indices? centroid array? -------------------------------

            gc = getGridPosition(cent, G);

            const index = G.grid[gc.i][gc.j].indexOf(cent);
            G.grid[gc.i][gc.j].splice(index, 1);

            clus.updateCentroid();
            clus.addMember(p);
        }
        gc = getGridPosition(clus.centroid, G);
        G.grid[gc.i][gc.j].push(clus.centroid);
    }
    function getClosestCentroid(p, G) {

        const gc = getGridPosition(p, G);
        const C = [];
        const range = 1;


        for(let k = Math.max(gc.i - range, 1);
            k < Math.min(gc.i + range, G.grid.length);
            k++) {

            for(let m = Math.max(gc.j - range, 1);
                m < Math.min(gc.j + range, G.grid[gc.i].length);
                m++) {

                for(let c in G.grid[k][m]) {
                    if(G.grid[k][m].hasOwnProperty(c)) {
                        if(((getSpatialDistance(p, G.grid[k][m][c])) <= bd.maxRadius) && (p.f === G.grid[k][m][c].f)) {
                            C.push(G.grid[k][m][c]);
                        }
                    }
                }
            }
        }

        if(C.length === 0) {
            return null;
        } else if(C.length === 1) {
            return C[0];
        } else {
            let ck = C[0];
            C.customForEach(function(c) {
                if (getSpatialDistance(c, p) <= getSpatialDistance(ck, p)) {
                    ck = c;
                }
            });
            return ck;
        }
    }
    function getGridPosition(p, G) {
        return {
            i: Math.floor(( p.x - G.xMin ) / bd.maxRadius),
            j: Math.floor(( p.y - G.yMin ) / bd.maxRadius)
        };
    }
    function getSpatialDistance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
    }

    function createEdges(clus) {
        clus.nextClusters.forEach(function(nextClus) {
            const edge = new Edge(clus, nextClus);
            clus.addEdge(edge);
            nextClus.addEdge(edge);
            data.edgs.value.push(edge);
        });
    }

//--MAKE-(THREE.JS)-----------------------------------------------------------------------------------------------------

    function makePoints(traj) {
        const dots = new THREE.Group();
        traj.rawPoints.customForEach(function(point) {
            const pointGeom = makeCircleGeometry(par.tj.dot.size, point, 0);
            dots.add(createCircle(pointGeom, traj.color, par.tj.opacity, par.tj.dot.size, traj));
        });
        traj.dots = dots;
    }
    function makeLine(traj) {
        const trajGeom = makePointGeometry(traj.rawPoints);
        traj.line = createLine(trajGeom, traj.color, par.tj.opacity, false, THREE.NoColors, THREE.FlatShading, traj);
    }
    function makeCentroid(clus) {
        const centGeom = makeCircleGeometry(par.ct.size, clus.centroid, par.ct.corrZ);
        clus.centDot = createCircle(centGeom, clus.color, par.ct.opacity, false, clus.centroid);
    }
    function makeCircle(clus) {
        const circleGeom = makeCircleGeometry(bd.maxRadius / 2, clus.centroid, par.ct.circles.corrZ);
        //squares
        //const circleGeom = makeSquareGeometry(bd.maxRadius, clus.centroid, par.ct.circles.corrZ);
        clus.circMesh = createCircle(circleGeom, clus.color, par.ct.circles.opacity, true, null);
    }
    function makeCluster(clus) {
        const members = new THREE.Group();
        clus.members.customForEach(function(point) {
            const pointGeom = makeCircleGeometry(par.tj.dot.size, point, 0);
            members.add(createCircle(pointGeom, clus.color, par.tj.dot.opacity, par.tj.dot.size, clus.members));
        });
        clus.membDots = members;
    }
    function makeErrors() {
        const errors = new THREE.Group();
        data.errs.value.customForEach(function(point) {
            const errorGeom = makeCircleGeometry(par.tj.dot.size, point, 0);
            errors.add(createCircle(errorGeom, par.cl.errors.color, par.tj.dot.opacity, par.tj.dot.size, data.errs.value)); //data.errs.value));
            point.isError = true;
        });
        draw.errs = errors;
    }
    function makeGraph(traj) {
        const trajGeom = makeTrajLineGeom(traj);
        traj.clusLine = createLine(trajGeom, 0xffffff, par.ln.opacity, par.ln.transparency,
                                    THREE.VertexColors, THREE.FlatShading, traj);
    }
    function makeAnchorCurve(traj) {
        traj.findClusters();
        //traj.findAnchors();
        traj.findBezAnchors();
        //const trajGeom = makeTrajCurveGeom(traj);
        const trajGeom = makeTrajBezCurveGeom(traj);
        if(trajGeom && (traj.anchors.length !== 0)) {
            traj.anchLine = createLine(trajGeom, par.ln.color, par.ln.opacity, par.ln.transparency,
                                        THREE.NoColors, THREE.FlatShading, traj);
        }
    }

    function makePointGeometry(points) {
        const pointsGeom = new THREE.Geometry();
        points.customForEach(function(point) {
            pointsGeom.vertices.push(new THREE.Vector3(point.x, -point.y, point.f * 10));
        });
        return pointsGeom;
    } //three.js
    function makeCircleGeometry(radius, point, corrZ) {
        const circleGeom = new THREE.CircleGeometry(radius, par.ct.circles.segNum);
        circleGeom.translate(point.x, -point.y, point.f * 10 + corrZ);
        return circleGeom;
    } //three.js
    function makeSquareGeometry(length, point, corrZ) {
        const squareGeom = new THREE.PlaneGeometry(length, length);
        squareGeom.translate(point.x, -point.y, point.f * 10 + corrZ);
        return squareGeom;
    }
    function makeLineSegGeom(lineSeg) {
        const lineSegGeom = new THREE.Geometry();
        lineSegGeom.vertices.push(new THREE.Vector3(lineSeg.start.x, -lineSeg.start.y, lineSeg.start.f));
        lineSegGeom.vertices.push(new THREE.Vector3(lineSeg.end.x, -lineSeg.end.y, lineSeg.end.f));
        lineSegGeom.colors.push(new THREE.Color(lineSeg.start.color));
        lineSegGeom.colors.push(new THREE.Color(lineSeg.end.color));
        return lineSegGeom;
    } //three.js
    function makeTrajLineGeom(traj) {
        const trajGeom = new THREE.Geometry();
        traj.clusters.customForEach(function(clus) {
            trajGeom.vertices.push(
                new THREE.Vector3(
                    clus.centroid.x + traj.deviation * par.tj.deviationFactor,
                    -clus.centroid.y + traj.deviation * par.tj.deviationFactor,
                    clus.centroid.f * 10));
            trajGeom.colors.push(new THREE.Color(clus.color));
        });
        return trajGeom;
    } //three.js
    function makeTrajCurveGeom(traj) {
        if(traj.anchors.length > 1) {
            const anchorGeom = new THREE.Geometry();
            traj.anchors.customForEach(function (anch) {
                anchorGeom.vertices.push(
                    new THREE.Vector3(
                        anch.x + traj.deviation * par.tj.deviationFactor,
                        -anch.y + traj.deviation * par.tj.deviationFactor,
                        anch.f * 10));
            });
            const curve = new THREE.CatmullRomCurve3(anchorGeom.vertices);
            let curveGeom = new THREE.Geometry();
            curveGeom.vertices = curve.getPoints(50);

            return curveGeom;
        } else {
            return false;
        }
        //started to implement splines --> continue
        /*trajs.customForEach(function (traj) {
         const anchorVertices = [];
         traj.anchors.customForEach(function (point) {
         anchorVertices.push(
         new THREE.Vector3(
         point.x + traj.deviation * 0.25,
         point.y * -1 + traj.deviation * 0.25,
         point.f));
         });
         const anchorSpline = new THREE.SplineCurve3(anchorVertices);
         const path = new THREE.Path(anchorSpline.getPoints( 50 ));
         const anchorGeom = path.createPointsGeometry( 50 );
         anchorGeoms.push(anchorGeom);
         });*/
    } //three.js
    function makeTrajBezCurveGeom(traj) {
        if(traj.anchors.length > 2) {
            const a = traj.anchors;

            const geom = new THREE.CurvePath();

            let i = 0;
            const curveS = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(
                    a[i].x + traj.deviation * par.tj.deviationFactor,
                    -a[i].y + traj.deviation * par.tj.deviationFactor,
                    a[i].f * 10),
                new THREE.Vector3(
                    a[i].x + traj.deviation * par.tj.deviationFactor,
                    -a[i].y + traj.deviation * par.tj.deviationFactor,
                    a[i].f * 10),
                new THREE.Vector3(
                    a[i + 1].x + traj.deviation * par.tj.deviationFactor,
                    -a[i + 1].y + traj.deviation * par.tj.deviationFactor,
                    a[i + 1].f * 10)
            );
            geom.add(curveS);

            i++;
            while (i < traj.anchors.length - 2) {

                const curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(
                        a[i].x + traj.deviation * par.tj.deviationFactor,
                        -a[i].y + traj.deviation * par.tj.deviationFactor,
                        a[i].f * 10),
                    new THREE.Vector3(
                        a[i + 1].x + traj.deviation * par.tj.deviationFactor,
                        -a[i + 1].y + traj.deviation * par.tj.deviationFactor,
                        a[i + 1].f * 10),
                    new THREE.Vector3(
                        a[i + 2].x + traj.deviation * par.tj.deviationFactor,
                        -a[i + 2].y + traj.deviation * par.tj.deviationFactor,
                        a[i + 2].f * 10)
                );
                geom.add(curve);

                i += 2;
            }

            const curveE = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(
                    a[i].x + traj.deviation * par.tj.deviationFactor,
                    -a[i].y + traj.deviation * par.tj.deviationFactor,
                    a[i].f * 10),
                new THREE.Vector3(
                    a[i + 1].x + traj.deviation * par.tj.deviationFactor,
                    -a[i + 1].y + traj.deviation * par.tj.deviationFactor,
                    a[i + 1].f * 10),
                new THREE.Vector3(
                    a[i + 1].x + traj.deviation * par.tj.deviationFactor,
                    -a[i + 1].y + traj.deviation * par.tj.deviationFactor,
                    a[i + 1].f * 10)
            );
            geom.add(curveE);

            return geom.createPointsGeometry(50);
        } else {
            return false;
        }
    }

    function createDots(geom, color, opa, pointSize, userData = {}) {
        const mat = new THREE.PointsMaterial({color: color, opacity: opa, size: pointSize, sizeAttenuation: false});
        const dots = new THREE.Points(geom, mat);
        dots.userData = userData;
        return dots;
    } //three.js
    function createLine(geom, color, opa, trans, vColors, shad, userData = {}) {
        const mat = new THREE.LineBasicMaterial({color: color, opacity: opa, transparent: trans, vertexColors: vColors, shading: shad});
        const line = new THREE.Line(geom, mat);
        line.userData = userData;
        return line;
    } //three.js
    function createCircle(geom, color, opa, trans, userData = {}) {
        const mat = new THREE.MeshBasicMaterial({color: color, opacity: opa, transparent: trans});
        const circle = new THREE.Mesh(geom, mat);
        circle.userData = userData;
        return circle;
    }
    function createLineSegment(geom, color, opa, trans, vColors, shad, userData = {}) {
        const mat = new THREE.LineBasicMaterial({color: color, opacity: opa, transparent: trans, vertexColors: vColors, shading: shad});
        const lineSeg = new THREE.LineSegments(geom, mat);
        lineSeg.userData = userData;
        return lineSeg;
    }

//--ADD-&-REMOVE--------------------------------------------------------------------------------------------------------
//  ToDo: review lineTypes

    //--All-Trajectories------------------------------------------------------------------------------------------------

    function showCheckedDrawings() {
        for(let ch in guiPar.checkboxes.lineTypes.choices) {
            if(guiPar.checkboxes.lineTypes.choices.hasOwnProperty(ch)) {
                if(bd.lineType[ch]) show(ch);
            }
        }
    }

    function show(choice) {
        switch(choice) {
            case 'points': {
                if(!data.trjs.valid) break;
                data.trjs.value.customForEach(function(traj) {
                    if(!traj.dots) makePoints(traj);
                    scene.add(traj.dots);
                });
                break;
            }
            case 'lines': {
                if(!data.trjs.valid) break;
                data.trjs.value.customForEach(function(traj) {
                    if(!traj.line) makeLine(traj);
                    scene.add(traj.line);
                });
                break;
            }
            case 'centroids': {
                if(!data.clts.valid) cluster(data.trjs.value);
                data.clts.value.customForEach(function(clus) {
                    if(!clus.centDot) makeCentroid(clus);
                    scene.add(clus.centDot);
                });
                break;
            }
            case 'circles': {
                if(!data.clts.valid) cluster(data.trjs.value);
                data.clts.value.customForEach(function(clus) {
                    if(!clus.circMesh) makeCircle(clus);
                    scene.add(clus.circMesh);
                });
                break;
            }
            case 'clusters': {
                if(!data.clts.valid) cluster(data.trjs.value);
                data.clts.value.customForEach(function(clus) {
                    if(!clus.membDots) makeCluster(clus);
                    scene.add(clus.membDots);
                });
                if(data.errs.value.length !== 0) {
                    if(!draw.errs) makeErrors();
                    scene.add(draw.errs);
                }
                break;
            }
            case 'graph': {
                if(!data.clts.valid) cluster(data.trjs.value);
                data.trjs.value.customForEach(function(traj) {
                    if(!traj.clusLine) {
                        makeGraph(traj);
                    }
                    scene.add(traj.clusLine);
                });
                break;
            }
            case 'curves': {
                if(!data.clts.valid) cluster(data.trjs.value);
                data.trjs.value.customForEach(function(traj) {
                    if(!traj.anchLine) makeAnchorCurve(traj);
                    if(traj.anchLine instanceof THREE.Line) {
                        scene.add(traj.anchLine);
                    }
                });
                break;
            }
            case 'groundtruth': {
                if(!data.grts.valid) break;
                data.grts.value.customForEach(function(traj) {
                    if(!traj.line) makeLine(traj);
                    scene.add(traj.line);
                });
                break;
            }
        }
    }

    function hideDrawing(choices) {
        choices.customForEach(function(choice) {
            switch(choice) {
                case 'bgMs': {
                    for (let bgMesh in draw.bgMs) {
                        if (draw.bgMs.hasOwnProperty(bgMesh)) {
                            scene.remove(draw.bgMs[bgMesh]);
                        }
                    }
                    break;
                }
                case 'grds': {
                    for(let floor in data.grds) {
                        if (data.grds.hasOwnProperty(floor)) {
                            scene.remove(data.grds[floor].drawing);
                        }
                    }
                    break;
                }
                case 'points': {
                    data.trjs.value.customForEach(function(traj) {
                        scene.remove(traj.dots);
                    });
                    break;
                }
                case 'lines': {
                    data.trjs.value.customForEach(function(traj) {
                        scene.remove(traj.line);
                    });
                    break;
                }
                case 'centroids': {
                    data.clts.value.customForEach(function(clus) {
                        scene.remove(clus.centDot);
                    });
                    break;
                }
                case 'circles': {
                    data.clts.value.customForEach(function(clus) {
                        scene.remove(clus.circMesh);
                    });
                    break;
                }
                case 'clusters': {
                    data.clts.value.customForEach(function(clus) {
                        scene.remove(clus.membDots);
                    });
                    scene.remove(draw.errs);
                    break;
                }
                case 'graph': {
                    data.trjs.value.customForEach(function(traj) {
                        scene.remove(traj.clusLine);
                    });
                    break;
                }
                case 'curves': {
                    data.trjs.value.customForEach(function(traj) {
                        scene.remove(traj.anchLine);
                    });
                    break;
                }
                case 'groundtruth': {
                    data.grts.value.customForEach(function(traj) {
                        scene.remove(traj.line);
                    });
                    break;
                }
            }
        });
    }
    function removeDrawing(choices) {
        choices.customForEach(function(choice) {
            switch(choice) {
                case 'bgMs': {
                    draw.bgMs = {};
                    break;
                }
                case 'grds': {
                    for (let floor in data.grds) {
                        if (data.grds.hasOwnProperty(floor)) {
                            delete data.grds[floor].drawing;
                        }
                    }
                    break;
                }
                case 'trjs': {
                    data.trjs.value.customForEach(function(traj) {
                        traj.emptyDrawing();
                    });
                    break;
                }
                case 'clts': {
                    data.clts.value.customForEach(function(clus) {
                        clus.emptyClusterDrawing();
                    });
                    break;
                }
                case 'errs': {
                    draw.errs = null;
                    break;
                }
                case 'grts': {
                    data.grts.value.customForEach(function(traj) {
                        traj.emptyDrawing();
                    });
                    break;
                }
            }
        });
    }
    function deleteData(choices) {
        choices.customForEach(function(choice) {
            switch(choice) {
                case 'trjs': {
                    data.trjs = {
                        valid: false,
                        value: [],
                    };
                    break;
                }
                case 'clts': {
                    data.clts = {
                        valid: false,
                        value: [],
                    };
                    break;
                }
                case 'edgs': {
                    data.edgs = {
                        valid: false,
                        value: [],
                    };
                    break;
                }
                case 'errs': {
                    data.errs = {
                        valid: false,
                        value: [],
                    };
                    draw.errs = null;
                    break;
                }
                case 'grts': {
                    data.grts = {
                        valid: false,
                        value: [],
                    };
                    break;
                }
            }
        });
    }

    //--All-Trajectories------------------------------------------------------------------------------------------------
    function hideTrajectoryDrawings() {
        hideDrawing(['points', 'lines', 'centroids', 'circles', 'clusters', 'graph', 'curves', 'groundtruth']);
    } //three.js
    function deleteTrajectoryData() {
        hideTrajectoryDrawings();
        deleteData(['trjs', 'clts', 'edgs', 'errs', 'grts']);
    }

    function hideGroundtruthTrajectories() {
        hideDrawing(['groundtruth']);
    }
    function deleteGroundtruthTrajectories() {
        hideGroundtruthTrajectories();
        deleteData(['grts']);
    }

    //--Special-Trajectories--------------------------------------------------------------------------------------------
    function hideClusterTrajectories() {
        hideDrawing(['centroids', 'circles', 'clusters', 'graph', 'curves']);
    }
    function deleteClusterTrajectories() {
        hideClusterTrajectories();
        data.trjs.value.customForEach(function(traj) {
            traj.emptyClusterData();
        });
        data.clts.valid = false;
        deleteData(['clts', 'edgs', 'errs']);
    }

    //--Everything------------------------------------------------------------------------------------------------------
    function hideEverything() {
         hideDrawing(['bgMs', 'grds']);
         hideTrajectoryDrawings();
    }
    function deleteEverything() {
        deleteAllBgMeshes();
        deleteAllGrids();
        deleteTrajectoryData();
    }

    //--Meshes----------------------------------------------------------------------------------------------------------
    function deleteAllBgMeshes() {
        hideDrawing(['bgMs']);
        removeDrawing(['bgMs']);
    }

    //--Grids-----------------------------------------------------------------------------------------------------------
    function toggleAllGrids() {
        if(bd.grid) {
            for(let f in data.grds) {
                scene.add(data.grds[f].drawing);
            }
        } else {
            hideDrawing(['grds']);
        }
    }
    function hideAllGrids() {
        hideDrawing(['grds']);
        bd.grid = false;
    }
    function deleteAllGrids() {
        hideDrawing(['grds']);
        removeDrawing(['grds']);
        deleteData(['grds']);
    }

//--CHANGE--------------------------------------------------------------------------------------------------------------

    function changeScale() {
        deleteAllBgMeshes();
        deleteAllGrids();
        loadNewBgMesh(bd.path, bd.floor); //also invokes loadNewGrid();
        showCheckedDrawings();
    }
    function changeFloors() {
        if (!(draw.bgMs[bd.floor] instanceof THREE.Mesh)) {
            loadNewBgMesh(bd.path, bd.floor); //also invokes loadGrid()
        }
        updateCamera();
        updateRaycaster();
    }
    function changeLineType() {
        hideTrajectoryDrawings();
        showCheckedDrawings();
    }
    function changeInfoType() {
        INTERSECTED.forEach(function(o) {
            unShowInfo(o);
            showInfo(o);
        });
    }
    function changeCutTime() {

    }
    function changeClusterRadius() {
        deleteClusterTrajectories();
        hideTrajectoryDrawings();
        showCheckedDrawings();
    }
    function changeMaxRedist() {
        hideTrajectoryDrawings();
        deleteClusterTrajectories();
        showCheckedDrawings();
    }

</script>
</body>
</html>