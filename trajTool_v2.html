<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TrajTool</title>
    <style>
        body { margin: 0; overflow: hidden }
        canvas { width: 100%!important; height: auto!important; }
    </style>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/chroma.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>

<!--Trajectory viewer-->
<script>

    //'use strict';

//--CONSTANTS-&-VARIABLES-----------------------------------------------------------------------------------------------

    let camera, scene, renderer;
    let mouse, raycaster, INTERSECTED;
    let gui;
    let buildingFileClicker, trajectoryFileClicker;

    const threePar = {
        cam: {
            corrNear: -0.1,
            corrFar: 0.1,
            corrZ: 100,
            positionZ: 100,
        },
        rend: {
            aa: true,
            alpha: true,
            color: 0xffffff,
            alphaVal: 0,
        },
        rayc: {
            clickColor: 0x00ff00,
            linePrec: 1,
        },
    };
    const guiPar = {
        bgLoader: {
            path: {
                init: 'white-',
            },
            ext: {
                init: '.png',
            },
            name: 'Load building',
        },
        scale: {
            min: 45,
            max: 100,
            step: 1,
            init: 49,
            name: 'Scale (1:X)',
        },
        floor: {
            min: -2,
            max: 2,
            step: 1,
            init: 1,
            name: 'Floor',
        },
        dataLoader: {
            name: 'Load trajectories',
        },
        lineType: {
            init: 'Point',
            name: 'Line type',
            choices: {
                points: {name: 'Dots', init: true},
                lines: {name: 'Lines', init: false},
                centroids: {name: 'Centroids', init: false},
                circles: {name: 'Circles', init: false},
                clusters: {name: 'Clusters', init: false},
                graph: {name: 'Graph', init: false},
                better: {name: 'Better', init: false},
                evenBetter: {name: 'Even Better', init: false},
            },
        },
        cMaxRad: {
            min: 5,
            max: 50,
            step: 5,
            init: 20,
            name: 'Radius',
        },
        redist: {
            min: 0,
            max: 50,
            step: 1,
            init: 50,
            name: 'Redist count',
            change: true,
        },
    }; //ToDo: building path changed-----------------------------------------------------------------
    const par = {
        bg: {
            dir: 'img/',
            corrZ: -0.1,
        },
        gd: {
            delta: 5,
            corrZ: 0.1,
            line: {
                color: 0x555555,
                opacity: 1,
            }
        },
        pt: {
            color: 0xff0000,
            opacity: 1,
            size: 3.5,
        },
        tj: {
            color: 0xff0000,
            opacity: 1,
            clickColor: 0x000000,
            cutTime: 20000,
            dot: {
                size: 3.5,
            },
            deviationFactor: 0.25, //should be changed depending on number of trajectories on connection
        },
        ln: {
            color: 0x000000,
            opacity: 0.4,
            transparency: true,
        },
        ct: {
            size: 10,
            opacity: 1,
            circles: {
                opacity: 0.2,
                segNum: 20,
                corrZ: -0.0,
            },
        },
        cl: {
            color: 0xffffff,
            corrColor: 0x555555,
            colorScaleType: ['darkgreen', 'forestgreen', 'yellowgreen', 'gold', 'orangered', 'crimson', 'darkred'], //'RdYlBu',
            colorDarkenFactor: 0,
            errors: {
                color: 0x0000ff,
            }
        },
        csv: {
            header: 't,x,y,acc,f,did',
            removeCount: 5,
        },
        subsaRadius: 3,

        //tj = trajectory; pt = point; ct = centroid; bg = background; gd = grid
    };

    const bd = {
        w: window.innerWidth, //building width
        wListener: function() {},
        get width() {
            return this.w;
        },
        set width(val) {
            this.w = val;
            this.wListener(val)
        },
        registerWListener: function(listener) {
            this.hListener = listener;
        },

        h: window.innerHeight, //building height
        hListener: function() {},
        get height() {
            return this.h;
        },
        set height(val) {
            this.h = val;
            this.hListener(val);
        },
        registerHListener: function(listener) {
            this.wListener = listener;
        },

        get ratio() {
            return this.w / this.h;
        },

        f: guiPar.floor.init, //building floor
        fListener: function() {},
        get floor() {
            return this.f;
        },
        set floor(val) {
            if (val !== this.f) {
                this.f = val;
                this.fListener();
            }
        },
        registerFListener: function(listener) {
            this.fListener = listener;
        },

        s: guiPar.scale.init, //building scale
        sListener: function() {},
        get scale() {
            return this.s;
        },
        get scaleFraction() {
            return ( 1 / this.s );
        },
        set scale(val) {
            if (val !== this.s) {
                this.s = val;
                this.sListener(val);
            }
        },
        registerSListener: function(listener) {
            this.sListener = listener;
        },

        filePath: guiPar.bgLoader.path.init,
        fileExt: guiPar.bgLoader.ext.init,
        get path() {
            return this.filePath + this.f + this.fileExt;
        },

        lt: {
            pt: guiPar.lineType.choices.points.init,
            ln: guiPar.lineType.choices.lines.init,
            ct: guiPar.lineType.choices.centroids.init,
            ci: guiPar.lineType.choices.circles.init,
            cl: guiPar.lineType.choices.clusters.init,
            gr: guiPar.lineType.choices.graph.init,
            bt: guiPar.lineType.choices.better.init,
            eb: guiPar.lineType.choices.evenBetter.init,

            ltListener: function() {},

            get points() {return this.pt},
            set points(val) {
                this.pt = val;
                this.ltListener('points');
            },
            get lines() {return this.ln},
            set lines(val) {
                this.ln = val;
                this.ltListener('lines');
            },
            get centroids() {return this.ct},
            set centroids(val) {
                this.ct = val;
                this.ltListener('centroids');
            },
            get circles() {return this.ci},
            set circles(val) {
                this.ci = val;
                this.ltListener('circles');
            },
            get clusters() {return this.cl},
            set clusters (val) {
                this.cl = val;
                this.ltListener('clusters');
            },
            get graph() {return this.gr},
            set graph (val) {
                this.gr = val;
                this.ltListener('graph');
            },
            get better() {return this.bt},
            set better (val) {
                this.bt = val;
                this.ltListener('better');
            },
            get evenBetter() {return this.eb},
            set evenBetter (val) {
                this.eb = val;
                this.ltListener('evenBetter');
            },
        }, //trajectory linetype
        get lineType() {
            return this.lt;
        },
        registerLtListener: function(listener) {
            this.lt.ltListener = listener;
        },


        mR: guiPar.cMaxRad.init, //cluster maxRadius
        mRListener: function() {},
        get maxRadius() {
            return this.mR;
        },
        set maxRadius(val) {
            if (val !== this.mR) {
                this.mR = val;
                this.mRListener(val);
            }
        },
        registerMRListener: function(listener) {
            this.mRListener = listener;
        },

        redi: guiPar.redist.init,
        rediListener: function() {},
        get redist() {
            return this.redi;
        },
        set redist(val) {
            if(val !== this.redi) {
                this.redi = val;
                this.rediListener(val);
            }
        },
        registerRediListener: function(listener) {
            this.rediListener = listener;
        },
    };
    bd.registerWListener(function() {
        updateCamera();
        updateRenderer();
    });
    bd.registerHListener(function() {
        updateCamera();
        updateRenderer();
    });
    bd.registerFListener(function() {
        changeFloors();
    });
    bd.registerSListener(function() {
        changeScale();
    });
    bd.registerLtListener(function(lineType) {
        changeLineType(lineType);
    });
    bd.registerMRListener(function() {
        changeClusterRadius();
    });
    bd.registerRediListener(function() {
        changeMaxRedist();
    });

    const data = {
        grds: {},
        trjs: {
            valid: false,
            val: [],
        },
        clts: {
            valid: false,
            val: [],
        },
        errors: {
            valid: false,
            val: [],
        }, //temp
        grph: {
            edges: {
                valid: false,
                val: [],
            },
        },
    };
    const draw = {
        bgMs: [],
        grds: [],
        errors: null,
        grph: {
            edges: []
        }
    };

    class Cluster {
        constructor() {
            this.data = {
                centroid: {},
                members: [],
                trajs: [],
                anchors: [],
            };
            this.drawing = {
                centroid: null,
                circle: null,
                members: null,
            }
        }
        get centroid() {return this.data.centroid}
        set centroid(cent) {
            this.data.centroid = cent;
            this.data.centroid.cluster = this;
            this.data.members.forEach(function(pt) {
                pt.centroid = cent;
            });
        }
        updateCentroid() {

            let sumX = 0;
            let sumY = 0;
            const points = this.members;
            const numPoints = this.members.length;

            for (let p in points) {
                if(points.hasOwnProperty(p)){
                    sumX += points[p].x;
                    sumY += points[p].y;
                }
            }

            if (numPoints > 0) {
                const tempCent = this.centroid;
                tempCent.x = sumX / numPoints;
                tempCent.y = sumY / numPoints;
                this.centroid = tempCent;
            } else {
                //ToDo: implement: delete cluster --------------------------------------
                this.centroid = null;
            }
        }
        get members() {return this.data.members}
        set members(memb) {
            this.data.members = memb;
            if(this.data.centroid) {
                this.data.members.forEach(function(pt) {
                    pt.centroid = this.c;
                });
            }
        }
        addMember(pt) {
            pt.cluster = this;
            this.data.members.push(pt);
        }
        get trajectories() {
            return this.data.trajs;
        }
        addTrajectory(traj) {
            this.data.trajs.push(traj);
        }
        get anchors() {return this.data.anchors}
        addAnchor(anch) {
            this.data.anchors.push(anch);
        }

        get centDot() {return this.drawing.centroid}
        set centDot(cent) {this.drawing.centroid = cent}
        get circMesh() {return this.drawing.circle}
        set circMesh(circle) {this.drawing.circle = circle}
        get membDots() {return this.drawing.members}
        set membDots(point) {this.drawing.members = point}

        emptyClusterDrawing() {
            this.centDot = null;
            this.circMesh = null;
            this.membDots = null;
        }
    }

    class Point {
        constructor(p) {
            this.col = par.pt.color;
            this.did = p.did;
            this.x = p.x;
            this.y = p.y;
            this.f = p.f;
            this.t = p.t;
            this.c = null;
            this.cl = null;
            this.prev = null;
            this.next = null;
        }
        get color() {return this.col}
        set color(val) {this.col = val}
        get centroid() { return this.c; }
        set centroid(cent) {
            this.c = cent;
//            if(this.g && (cent !== this.g.c)) {
//                this.g = null;
//            }
        }
        get cluster() {return this.cl}
        set cluster(clus) {
            this.cl = clus;
            this.c = clus.c;
        }
        get prevPoint() {return this.prev}
        set prevPoint(pt) {
            this.prev = pt;
            if(pt) pt.next = this;
        }
        get nextPoint() {return this.next}
        set nextPoint(pt) {
            this.next = pt;
            if(pt) pt.prev = this;
        }
    }
    class Centroid extends Point {
        constructor(p) {
            super(p);
            this.prev = new Set(); // ev. Map mit Cent als key und anzahl als val?
            this.next = new Set();
            this.cl = p.cl;
            this.col = Math.random() * 0xffffff;
        }
        get prevCentroids() {return this.prev}
        set prevCentroids(set) {this.prev = set}
        addPrevCentroid(cent) {
            this.prev.add(cent);
            if(cent) cent.next.add(this);
        }
        get nextCentroids() {return this.next}
        set nextCentroids(set) {this.next = set}
        addNextCentroid(cent) {
            this.next.add(cent);
            if(cent) cent.prev.add(this);
        }
    }
    class Anchor extends Point {
        constructor(p) {
            super(p);
        }
        get prevAnchor() {return this.prev}
        set prevAnchor(anch) {
            this.prev = anch;
            if(anch) anch.next = this;
        }
        get nextAnchor() {return this.next}
        set nextAnchor(anch) {
            this.next = anch;
            if(anch) anch.prev = this;
        }
    }

    class Trajectory {
        constructor() {
            this.f = null;
            this.color = Math.random() * 0xffffff; //par.tj.color;
            this.deviation = rand_BoxMuller();
            this.data = {
                raw: [],
                subsa: [],
                centroids: [],
                anchors: [],
            };
            this.drawing = {
                dots: null,
                line: null,
                centLine: null,
                anchLine: null,
            };
        }
        get rawPoints() {return this.data.raw}
        set rawPoints(points) {this.data.raw = points}
        emptyRawPoints() {this.data.raw = []}
        get subsaPoints() {return this.data.subsa}
        set subsaPoints(points) {this.data.subsa = points}
        emptySubsaPoints() {this.data.subsa = []}
        get centroids() {return this.data.centroids}
        set centroids(points) {this.data.centroids = points}
        addCentroid(cent) {
            this.data.centroids.push(cent);
            cent.cluster.addTrajectory(this);
        }
        findCentroids() {
            this.emptyCentroids();
            this.addCentroid(this.subsaPoints[0].centroid);

            let i = 1;
            while(i < this.subsaPoints.length) {
                if(this.subsaPoints[i-1].centroid !== this.subsaPoints[i].centroid) {
                    this.addCentroid(this.subsaPoints[i].centroid);
                }
                i++;
            }
        }
        emptyCentroids() {
            this.data.centroids = [];
        }
        get anchors() {return this.data.anchors}
        set anchors(anchs) {this.data.anchors = anchs}
        addAnchor(anch) {
            this.data.anchors.push(anch);
            //anch. implement if Anchor becomes a class
        }
        findAnchors() {
            this.emptyAnchors();
            this.addAnchor(new Anchor(this.centroids[0]));

            let i = 1;
            if(this.centroids.length > 2) {
                while (i < this.centroids.length - 1) {

                    const p0 = this.centroids[i - 1];
                    const p1 = this.centroids[i];
                    const p2 = this.centroids[i + 1];

                    let p1p0 = {x: p0.x - p1.x, y: p0.y - p1.y};
                    let p1p2 = {x: p2.x - p1.x, y: p2.y - p1.y};

                    let abs_p1p0 = Math.sqrt(p1p0.x * p1p0.x + p1p0.y * p1p0.y);
                    let abs_p1p2 = Math.sqrt(p1p2.x * p1p2.x + p1p2.y * p1p2.y);

                    let cos_p0p2 = ((p1p0.x * p1p2.x + p1p0.y * p1p2.y) / (abs_p1p0 * abs_p1p2));

                    //let alpha = ((cos_p0p2 + 1.0) / 2.0 + params.alpha) / (1.0 + params.alpha);
                    let alpha = (cos_p0p2 + 1.0) / 2.0;

                    //boundaries
                    let beta = Math.max(alpha, 0.6); //changed to 0.6 to prevent hard edges
                    //beta = Math.min(beta, 0.95);

                    //beta = alpha;

                    const p01 = new Anchor({
                        x: (1 - beta) * p0.x + beta * p1.x,
                        y: (1 - beta) * p0.y + beta * p1.y,
                        f: p1.f,
                    });
                    const p12 = new Anchor({
                        x: beta * p1.x + (1 - beta) * p2.x,
                        y: beta * p1.y + (1 - beta) * p2.y,
                        f: p1.f
                    });

                    this.addAnchor(p01);
                    this.addAnchor(p12);

                    i++;
                }
            }

            if(this.centroids.length > 1){
                this.addAnchor(new Anchor(this.centroids[i]));
            }
        }
        findBezAnchors() {
            this.emptyAnchors();

            let i = 0;
            while( i < this.centroids.length - 1) {

                const cA = this.centroids[i];
                const cB = this.centroids[i+1];

                const alpha = 0.5;

                const p = new Anchor({
                    x: alpha * cA.x + (1 - alpha) * cB.x,
                    y: alpha * cA.y + (1 - alpha) * cB.y,
                    f: cA.f,
                });

                this.addAnchor(new Anchor(cA));
                this.addAnchor(p);

                i++;
            }
            this.addAnchor(new Anchor(this.centroids[i]));
        }
        emptyAnchors() {
            this.data.anchors = [];
        }

        emptyClusterData() {
            this.emptyClusterDrawing();
            this.emptySubsaPoints();
            this.emptyCentroids();
            this.emptyAnchors();
        }

        get dots() {return this.drawing.dots}
        set dots(dots) {this.drawing.dots = dots}
        get line() {return this.drawing.line}
        set line(line) {this.drawing.line = line}
        get centLine() {return this.drawing.centLine}
        set centLine(centLine) {this.drawing.centLine = centLine}
        get anchLine() {return this.drawing.anchLine}
        set anchLine(anchLine) {this.drawing.anchLine = anchLine}

        emptyClusterDrawing() {
            this.centLine = null;
            this.anchLine = null;
        }
        emptyDrawing() {
            this.emptyClusterDrawing();
            this.dots = null;
            this.line = null;
        }
    }

//--START---------------------------------------------------------------------------------------------------------------

    init();
    initRaycaster(); //broken for now
    update();

//--INITALIZATION-------------------------------------------------------------------------------------------------------
//  ToDo: Review init function (camera?)

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(0, 0, 0, 0, 0, 0, 0);
        initRenderer();
        initCamera();
        initBackgroundFileInput();
        initDataFileInput();
        initDatGUI();
        initWindowResizeListeners();
    }

    function initRenderer() {
        renderer = new THREE.WebGLRenderer({antialias: threePar.rend.aa, alpha: threePar.rend.alpha});
        renderer.setClearColor(threePar.rend.color, threePar.rend.alphaVal);//        renderer.setPixelRatio( window.devicePixelRatio ) ;
        document.body.appendChild(renderer.domElement);
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function initCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera = new THREE.OrthographicCamera(0, bd.width,
                0, -bd.width / windowRatio, 0, 200);
        } else {
            camera = new THREE.OrthographicCamera(0, bd.height * windowRatio,
                0, -bd.height, 0, 200);
        } //Temp code inside

        camera.position.z = 100;
        camera.lookAt(new THREE.Vector3(0,0,0));
        camera.updateProjectionMatrix();
    } //three.js
    function initRaycaster() {
        raycaster = new THREE.Raycaster();
        raycaster.near = 0; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
        raycaster.far = 200; //Math.round((bd.floor + par.bg.corrZ + threePar.cam.corrFar) * 100) / 100;
        raycaster.linePrecision = threePar.rayc.linePrec;
        mouse = new THREE.Vector2();
        window.addEventListener('click', onMouseClick, false);

        // when the mouse moves, call the given function
        //window.addEventListener( 'mousemove', onMouseClick, false );
    } //three.js

    function updateRenderer() {
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function updateCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera.right = bd.width;
            camera.bottom = -bd.width / windowRatio;
            camera.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
            camera.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.bg.corrZ + threePar.cam.corrFar) * 100) / 100;
        } else {
            camera.right = bd.height * windowRatio;
            camera.bottom = -bd.height;
            camera.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
            camera.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100;
        }
        camera.updateProjectionMatrix();
//        if( camerahelper ) {
//            camerahelper.update();
//        }
    } //three.js
    function updateRaycaster() {
        //if(bd.scaleFraction) raycaster.linePrecision = threePar.rayc.linePrec * bd.scale;
        //raycaster.linePrecision = 0;
        raycaster.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100;
        raycaster.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100;
    }

    function update() {
        //hoverDetector();
        requestAnimationFrame(update);
        renderer.render(scene, camera);
    } //three.js

    function hoverDetector() {

        raycaster.setFromCamera(mouse, camera);

        // create an array containing all objects in the scene with which the ray intersects
        let intersects = raycaster.intersectObjects(scene.children) ;

        // INTERSECTED = the object in the scene currently closest to the camera
        //		and intersected by the Ray projected from the mouse position

        // if there is one (or more) intersections
        if (intersects.length > 0) {

            const obj = intersects[0].object;
            // if the closest object intersected is not the currently stored intersection object
            if ((obj !== INTERSECTED) && (obj.type === 'Line')) {
                // restore previous intersection object (if it exists) to its original color
                if (INTERSECTED) {
                    INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    INTERSECTED.material.needsUpdate = true;
                }
                // store reference to closest object as current intersection object
                INTERSECTED = intersects[0].object;
                // store color of closest object (for later restoration)
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                // set a new color for closest object
                INTERSECTED.material.color.setHex( 0x00ff00 );
                INTERSECTED.material.needsUpdate = true;
            }
        } else {// there are no intersections
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED) {
                INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED.material.needsUpdate = true;
            }

            // remove previous intersection object reference
            // by setting current intersection object to "nothing"
            INTERSECTED = null;
        }
    }


    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // create an array containing all objects in the scene with which the ray intersects
        let intersects = raycaster.intersectObjects(scene.children) ;

        // INTERSECTED = the object in the scene currently closest to the camera
        // and intersected by the Ray projected from the mouse position

        // if there is one (or more) intersections
        if (intersects.length > 0) {

            let obj;
            let tempGeom = null;

            for(let o = 0; o < intersects.length; o++) {

                const tempObj = intersects[o].object;

                if((!(intersects[o].distance.isNaN)) && (tempObj.geometry !== tempGeom) &&
                    ((Math.trunc(intersects[o].point.z * 100) / 100) === bd.floor))
                    outer_if:{

                    tempGeom = tempObj.geometry;

                    if(tempObj.userData instanceof Trajectory) {
                        obj = {
                            type: 'trajectory',
                            userData: tempObj.userData,
                        };
                        break outer_if;
                    } else if(tempObj.userData instanceof Centroid) {
                        obj = {
                            type: 'centroid',
                            userData: tempObj.userData,
                        };
                        break outer_if;
                    } else if(tempObj.userData instanceof Array) {
                        if(tempObj.userData[0].centroid !== null) {
                            obj = {
                                type: 'member',
                                userData: tempObj.userData,
                            };
                        } else {
                            obj = {
                                type: 'error',
                                userData: tempObj.userData,
                            };
                        }

                        break outer_if;
                    }
                }
            }

        // if the closest object intersected is not the currently stored intersection object
            if(obj) {
                if (obj !== INTERSECTED) {
                    // restore previous intersection object (if it exists) to its original color
                    if (INTERSECTED) {
                        switch(INTERSECTED.type) {
                            case 'trajectory': {
                                unClickTrajectory(INTERSECTED.userData);
                                break;
                            }
                            case 'centroid': {
                                unClickCluster(INTERSECTED.userData.cluster);
                                break;
                            }
                            case 'member': {
                                unClickCluster(INTERSECTED.userData[0].cluster);
                                break;
                            }
                            case 'error':
                                break;
                        }
                    }
                    // store reference to closest object as current intersection object
                    INTERSECTED = obj;

                    switch(INTERSECTED.type) {
                        case 'trajectory': {
                            clickTrajectory(INTERSECTED.userData);
                            break;
                        }
                        case 'centroid': {
                            clickCluster(INTERSECTED.userData.cluster);
                            break;
                        }
                        case 'member': {
                            clickCluster(INTERSECTED.userData[0].cluster);
                            break;
                        }
                        case 'error':
                            break;
                    }
                }
            } else { // there are no useful intersections
                // restore previous intersection object (if it exists) to its original color
                if (INTERSECTED) {
                    switch(INTERSECTED.type) {
                        case 'trajectory': {
                            unClickTrajectory(INTERSECTED.userData);
                            break;
                        }
                        case 'centroid': {
                            unClickCluster(INTERSECTED.userData.cluster);
                            break;
                        }
                        case 'member': {
                            unClickCluster(INTERSECTED.userData[0].cluster);
                            break;
                        }
                        case 'error':
                            break;
                    }
                    // remove previous intersection object reference
                    // by setting current intersection object to "nothing"
                    INTERSECTED = null;
                }
            }
        }
    }

    function clickTrajectory(traj) {
        if(traj.dots) {
            traj.dots.material.color.set(threePar.rayc.clickColor);
            traj.dots.material.needsUpdate = true;
        }
        if(traj.line) {
            traj.line.material.color.set(threePar.rayc.clickColor);
            traj.line.material.needsUpdate = true;
        }
        if(traj.centLine) {
            traj.centLine.material.vertexColors = THREE.NoColors;
            traj.centLine.material.color.set(threePar.rayc.clickColor);
            traj.centLine.material.needsUpdate = true;
        }
        if(traj.anchLine) {
            //traj.drawing.anchLine.material.vertexColors = THREE.NoColors;
            traj.anchLine.material.color.set(threePar.rayc.clickColor);
            traj.anchLine.material.needsUpdate = true;
        }
        if(traj.centroids.length !== 0) {
            traj.centroids.forEach(function(cent) {
                cent.cluster.centDot.material.color.set(threePar.rayc.clickColor);
                cent.cluster.centDot.material.needsUpdate = true;
            });
        }
    }
    function unClickTrajectory(traj) {
        if (traj.dots) {
            traj.dots.material.color.set(traj.color);
            traj.dots.material.needsUpdate = true;
        }
        if (traj.line) {
            traj.line.material.color.set(traj.color);
            traj.line.material.needsUpdate = true;
        }
        if (traj.centLine) {
            traj.centLine.material.vertexColors = THREE.VertexColors;
            traj.centLine.material.color.set(0xffffff);
            traj.centLine.material.needsUpdate = true;
        }
        if (traj.anchLine) {
            //traj.anchLine.material.vertexColors = THREE.VertexColors;
            traj.anchLine.material.color.set(par.ln.color);
            traj.anchLine.material.needsUpdate = true;
        }
        if(traj.centroids.length !== 0) {
            traj.centroids.forEach(function(cent) {
                cent.cluster.centDot.material.color.set(cent.color);
                cent.cluster.centDot.material.needsUpdate = true;
            });
        }
    }
    function clickCluster(clus) {
        if (clus.centDot) {
            clus.centDot.material.color.set(threePar.rayc.clickColor);
            clus.centDot.material.needsUpdate = true;
        }
        if (clus.circMesh) {
            clus.circMesh.material.color.set(threePar.rayc.clickColor);
            clus.circMesh.material.needsUpdate = true;
        }
        if (clus.membDots) {
            clus.membDots.material.color.set(threePar.rayc.clickColor);
            clus.membDots.material.needsUpdate = true;
        }
        if (clus.trajectories) {
            clus.trajectories.forEach(function (traj) {
                clickTrajectory(traj);
            });
        }
    }
    function unClickCluster(clus) {
        if (clus.centDot) {
            clus.centDot.material.color.set(clus.centroid.color);
            clus.centDot.material.needsUpdate = true;
        }
        if (clus.circMesh) {
            clus.circMesh.material.color.set(clus.centroid.color);
            clus.circMesh.material.needsUpdate = true;
        }
        if (clus.membDots) {
            clus.membDots.material.color.set(clus.centroid.color);
            clus.membDots.material.needsUpdate = true;
        }
        if (clus.trajectories) {
            clus.trajectories.forEach(function (traj) {
                unClickTrajectory(traj)
            });
        }
    }

    //temp code inside
    function onDocumentMouseMove(event){
        // the following line would stop any other event handler from firing
        // (such as the mouse's TrackballControls)
        // event.preventDefault();

        // update the mouse variable
//        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
//        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    function initWindowResizeListeners() {
        window.addEventListener('resize', onWindowResize, false);
    }
    function onWindowResize() {
        updateRenderer();
        updateCamera();
    }

    function initBackgroundFileInput() {
        const buildingFileInput = document.createElement('input');
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.accept = "image/*";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        document.body.appendChild(buildingFileInput);

        buildingFileInput.addEventListener('change', function () {
            const file = buildingFileInput.files[0];
            const fileName = buildingFileInput.files[0].name;
            const fileType = /image.*/;

            if(file.type.match(fileType)) {
                bd.filePath = fileName.slice(0, -5);
                bd.fileExt = fileName.slice(-4, fileName.length);
                deleteEverything();
                changeFloors();
            } else {
                alert("File not supported");
            }
        });
        buildingFileClicker = {
            loadBuildingFile: function () {
                document.getElementById("buildingFileInput").click();
            }
        };
    }
    function initDataFileInput() {
        const dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild(dataFileInput);

        dataFileInput.addEventListener('change', function () {
            const fileCount = dataFileInput.files.length;
            const result = [];
            for(let file = 0; file < fileCount; file++) {
                const reader = new FileReader();
                reader.onload = function () {
                    result.push(this.result);
                    if (result.length === fileCount) {
                        loadNewTrajectories(result);
                        deleteClusterTrajectories();
                        showCheckedDrawings();
                    }
                };
                reader.readAsText(dataFileInput.files[file]);
            }
            this.value = null; //remove filename from input
        });
        trajectoryFileClicker = {
            loadDataFile: function () {
                document.getElementById("dataFileInput").click();
            }
        };
    }

    function initDatGUI() {
        gui = new dat.GUI();
        const fLoad = gui.addFolder('Load things');
        fLoad.add(buildingFileClicker, 'loadBuildingFile').name(guiPar.bgLoader.name);
        fLoad.add(trajectoryFileClicker, 'loadDataFile').name(guiPar.dataLoader.name);
        fLoad.open();
        const fDelete = gui.addFolder('Delete things');
        fDelete.add(this, 'deleteEverything').name('Delete everything');
        fDelete.add(this, 'deleteTrajectoryData').name('Delete trajectories');
        const fBdSettings = gui.addFolder('Building settings');
        fBdSettings.add(bd, 'scale', guiPar.scale.min, guiPar.scale.max).step(guiPar.scale.step).name(guiPar.scale.name);
        const fDataSettings = gui.addFolder('Data settings');
        fDataSettings.add(bd, 'maxRadius', guiPar.cMaxRad.min, guiPar.cMaxRad.max).step(guiPar.cMaxRad.step).name(guiPar.cMaxRad.name);
        fDataSettings.add(bd, 'redist', guiPar.redist.min, guiPar.redist.max).step(guiPar.redist.step).name(guiPar.redist.name);
        const fViewSettings = gui.addFolder('View settings');
        fViewSettings.add(this, 'hideAllGrids').name('Hide grid');
        fViewSettings.add(bd, 'floor', guiPar.floor.min, guiPar.floor.max).step(guiPar.floor.step).name(guiPar.floor.name);
        fViewSettings.open();
        const fLineTypes = fViewSettings.addFolder('Line types');
        //fLineTypes.add(bd, 'lineType', guiPar.lineType.choices).name(guiPar.lineType.name);
        for(let ch in guiPar.lineType.choices) {
            if(guiPar.lineType.choices.hasOwnProperty(ch)) {
                fLineTypes.add(bd.lt, ch).name(guiPar.lineType.choices[ch].name);
            }
        }
        fLineTypes.open();

    } //dat.gui

//--LOAD-BASICS---------------------------------------------------------------------------------------------------------

    function loadNewBgMesh(buildingName, floor) {
        const buildingPath = par.bg.dir + buildingName;
        let backgroundMesh;
        let bgMaterial = new THREE.MeshBasicMaterial();

        const bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            function (texture) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //translate pixels into meters -- ATTENTION! BG-imgs have to have same size!
                bd.width = texture.image.naturalWidth * bd.scaleFraction;
                bd.height = texture.image.naturalHeight * bd.scaleFraction;

                //create bgPlane
                const backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push(new THREE.Vector3(0, 0, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(0, -bd.height, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, -bd.height, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, 0, floor + par.bg.corrZ));

                backgroundPlane.faces.push(new THREE.Face3(0, 1, 3));
                backgroundPlane.faces.push(new THREE.Face3(1, 2, 3));//backgroundPlane.computeFaceNormals();
                backgroundPlane.faceVertexUvs[0] = [];
                backgroundPlane.faceVertexUvs[0].push([new THREE.Vector2(0, 1),
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );

                draw.bgMs[floor] = backgroundMesh;
                scene.add(draw.bgMs[floor]);

                genGrid(floor);
                drawGrid(floor);
            },
            function () {
            },
            function () {
                console.log('BG-loading failed');
            }
        );
    } //three.js
    function genGrid(floor) {

        let coordLines = [];

        for (let i = 0; i < ( bd.height ); i += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: 0,
                    y: i,
                    f: floor,
                },
                p1: {
                    x: bd.width,
                    y: i,
                    f: floor,
                }
            });
        }
        for (let j = 0; j < ( bd.width ); j += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: j,
                    y: 0,
                    f: floor,
                },
                p1: {
                    x: j,
                    y: bd.height,
                    f: floor,
                }
            });
        }
        data.grds[floor] = {};
        data.grds[floor].val = coordLines;
        data.grds[floor].valid = true;
    }
    function drawGrid(floor) {

        const coordGeometry = new THREE.Geometry();
        data.grds[floor].val.forEach(function(line) {
            coordGeometry.vertices.push(new THREE.Vector3(line.p0.x, -line.p0.y, line.p0.f + par.gd.corrZ));
            coordGeometry.vertices.push(new THREE.Vector3(line.p1.x, -line.p1.y, line.p1.f + par.gd.corrZ));
        });

        const coordMaterial = new THREE.LineBasicMaterial({
            color: par.gd.line.color,
            opacity: par.gd.line.color,
        });

        data.grds[floor].drawing = new THREE.LineSegments(coordGeometry, coordMaterial);
        scene.add(data.grds[floor].drawing); //ToDo: reenable grids
    } //three.js -- disabled

//--LOAD-TRAJECTORIES---------------------------------------------------------------------------------------------------
//  ToDo: Implement function for removing first and last locations of recording

    function loadNewTrajectories(readerResult) {

        data.trjs.valid = false;
        data.clts.valid = false;
        data.errors.valid = false;

        let pointList = [];

    //--create-Point-Objects--------------------------------------------------------------------------------------------
        readerResult.forEach(function(file){
            const tempList = parseCSV(file);

            tempList.splice(0, par.csv.removeCount);
            tempList.splice(-par.csv.removeCount);

            tempList.forEach(function (point) {
                const p = new Point(point);
                pointList.push(p);
            });
        });

    //--sort-Points-----------------------------------------------------------------------------------------------------
        pointList = sortPoints(pointList);

        const pointListByDID = groupPointListByDid(pointList);
        const pointListByDIDByTime = [];
        const pointListByDIDByTimeByFloor = [];

        for(let did in pointListByDID) {
            if(pointListByDID.hasOwnProperty(did)){
                pointListByDIDByTime[did] = groupPointListByTime(pointListByDID[did]);
            }
        }

        for(let did in pointListByDIDByTime) {
            if(pointListByDIDByTime.hasOwnProperty(did)) {
                pointListByDIDByTimeByFloor[did] = [];
                for(let t in pointListByDIDByTime[did]) {
                    if(pointListByDIDByTime[did].hasOwnProperty(t)) {
                        pointListByDIDByTimeByFloor[did][t] = groupPointListByFloor(pointListByDIDByTime[did][t]);
                    }
                }
            }
        }

    //--create-Trajectories---------------------------------------------------------------------------------------------
        for(let did in pointListByDIDByTimeByFloor) {
            for(let t in pointListByDIDByTimeByFloor[did]) {
                if(pointListByDIDByTimeByFloor[did].hasOwnProperty(t)) {
                    for (let f in pointListByDIDByTimeByFloor[did][t]) {
                        if (pointListByDIDByTimeByFloor[did][t].hasOwnProperty(f)) {
                            const tempTrajectory = new Trajectory();
                            tempTrajectory.rawPoints = pointListByDIDByTimeByFloor[did][t][f];
                            tempTrajectory.f = f;
                            if (tempTrajectory.rawPoints.length > 1) {

                                let tempPrevPoint = tempTrajectory.rawPoints[0];
                                tempPrevPoint.prevPoint = null;

                                for (let p = 0; p < tempTrajectory.rawPoints.length; p++) {
                                    tempPrevPoint.nextPoint = tempTrajectory.rawPoints[p];
                                    tempTrajectory.rawPoints[p].prevPoint = tempPrevPoint;
                                    tempPrevPoint = tempTrajectory.rawPoints[p];
                                }
                                data.trjs.val.push(tempTrajectory);
                            }
                        }
                    }
                }
            }
        }
        data.trjs.valid = true;
    }

    function parseCSV(csvString) {
        const parseResult = Papa.parse(csvString, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            comments: '#',
            //step: true,
            beforeFirstChunk: function (chunk) {
                const rows = chunk.split(/\r\n|\r|\n/);
                rows[0] = par.csv.header;
                return rows.join("\r\n");
            }
        });
        return parseResult.data;
    }
    function sortPoints(pointList) {
    pointList.sort(
        firstBy("did")
            .thenBy("t")
    );
    return pointList;
}
    function groupPointListByDid(pointList) {
        return groupBy(pointList, function (item) {
                return [item.did]; //, item.t
            }
        );
    }
    function groupPointListByTime(pointList) {

        const pointListByTime = [];

        let tempTime = pointList[0].t;
        let tempTimeArray = [];

        pointList.forEach(function(point) {
            if (tempTime + par.tj.cutTime < point.t) {
                pointListByTime.push(tempTimeArray);
                tempTimeArray = [];
                tempTimeArray.push(point);
                tempTime = point.t;
            } else {
                tempTimeArray.push(point);
                tempTime = point.t;
            }
        });
        pointListByTime.push(tempTimeArray);
        return pointListByTime;
    }
    function groupPointListByFloor(pointList) {
        return groupBy(pointList, function( item )  {
                return [item.f]; //, item.t
            }
        );
    }
    function groupBy(array, f) {

        const groups = {};
        array.forEach(
            function (object) {
                const group = JSON.stringify(f(object));
                groups[group] = groups[group] || []; //if groups[group] doesn't exist, [] is assigned
                groups[group].push(object);
            }
        );
        return groups;
    }

//--CLUSTERING----------------------------------------------------------------------------------------------------------
//  ToDo: data.clts.points.push(cluster.members) --> change .points. to .members

    function cluster(trajs) {
        const vertices = [];

        trajs.forEach(function(traj) {
            traj.subsaPoints = subsamplePoints(traj.rawPoints);
            vertices.push(traj.subsaPoints);
        });

        //centroid seed
        const P = vertices; //Points
        const G = generateGrid(P); //Grid
        const R = seedCentroids(P, G); //Results

        guiPar.redist.change = true;
        let i = 0;
        while((i < bd.redist) && guiPar.redist.change) {
            redistributePoints(P, R, G);
            recalculateCentroids(R, G);
            //console.log(i);
            i++;
        }
        let ml = 0;
        R.forEach(function(cluster) {
            if(ml < cluster.members.length) ml = cluster.members.length;
        });

        R.forEach(function(cluster) {
            //cluster.centroid.color = Math.random() * par.ct.color + par.ct.corrColor;
            const scale = chroma.scale(par.cl.colorScaleType).domain([0,ml]);
            cluster.centroid.color = scale(cluster.members.length).darken(par.cl.colorDarkenFactor).hex();
            data.clts.val.push(cluster); //ToDo
        });
        data.clts.valid = true;
    }

    function subsamplePoints(points) {
        const vertices = [];//R = Radius for subsampling, r = radius remaining for next segment, i = iterator, p0 = first point of traj, //pA and pB are start and end of segment to be subsampled, D = dist between pA and pB, d = remaining distance
        //p = subsampled point, vh = ratio of _________ (?),

        const R = par.subsaRadius;
        let r = R;

        const p0 = new Point({
            did: points[0].did,
            x: points[0].x,
            y: points[0].y,
            f: points[0].f,
            t: points[0].t
        });
        //data.subsaPnts.push(p0); //testing

        p0.prevPoint = null;
        vertices.push(p0);

        let tempPrevPoint = p0;

        for (let i = 0; i < points.length - 2; i++) {
            if (points.hasOwnProperty(i)) {

                const pA = points[i];
                const pB = points[i + 1];

                const D = getSpatialDistance(pA, pB);
                let d = D;
                while (d > r) {
                    const vh = ( r + ( D - d ) ) / D;// t not interpolated!! f not interpolated
                    const p = new Point({
                        did: pA.did,
                        x: (1 - vh) * pA.x + vh * pB.x,
                        y: (1 - vh) * pA.y + vh * pB.y,
                        f: pA.f,
                        t: pA.t
                    });
                    //data.subsaPnts.push(p); //testing

                    p.prevPoint = tempPrevPoint;
                    tempPrevPoint = p;

                    vertices.push(p);

                    d -= r;
                    r = R;
                }
                r -= d;
            }
        }
        return vertices;
    }
    function generateGrid(points) {

        const P = points;
        const G = {
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0,
            grid: []
        };
        for (let i in P) {
            if(P.hasOwnProperty(i)){
                for (let j in P[i]) {
                    if(P[i].hasOwnProperty(j)){
                        const p = P[i][j];
                        if (G.xMin > p.x) G.xMin = p.x;
                        if (G.xMax < p.x) G.xMax = p.x;
                        if (G.yMin > p.y) G.yMin = p.y;
                        if (G.yMax < p.y) G.yMax = p.y;
                    }
                }
            }
        }
        for (let x = G.xMin; x <= G.xMax; x += bd.maxRadius) {
            const gX = [];
            for (let y = G.yMin; y <= G.yMax; y += bd.maxRadius) {
                const gY = [];
                gX.push(gY);
            }
            G.grid.push(gX);
        }
        return G;
    }
    function seedCentroids(points, G) {
        const P = points;
        const R = []; //results

        P.forEach(function(t) {
            t.forEach(function(p) {
                putInProperGroup(p, R, G);
            });
        });
        return R;
    }
    function redistributePoints(P, R, G) {
        const originList = {};
        guiPar.redist.change = false;

        //--Remember number of members of each group, them remove members from group
        let r = 0;
        while(r < R.length) {
            if(R.hasOwnProperty(r)){
                originList[r] = R[r].members.length;
                R[r].members = [];
            }
            r++;
        }

        let cnt = 0;

        //--Assign every Point to a group
        P.forEach(function(t) {
            t.forEach(function(p) {

                let cent = getClosestCentroid(p, G);
                if (cent !== null) {// FEHLER! WARUM KANN c NULL SEIN? -> Kein centroid in reichweite

                    cent.cluster.addMember(p);

                } else {

                    data.errors.val.push(p); //ToDo
                    cnt++;
                }
            });
        });

        if(cnt !== 0) console.log('redistPoints: No Centroid found in ' + cnt + ' cases!');

        //test for changes
        r = 0;
        while(r < R.length) {
            if(R.hasOwnProperty(r)){
                if(originList[r] !== R[r].members.length) {
                    guiPar.redist.change = true;
                }
            }
            r++;
        }
    }

    function recalculateCentroids(R, G) {

        //console.log('start' + R.length);

        const tempR = R;
        R = [];

        let cnt = 0;

        for(let r = 0; r < tempR.length; r++) {
            if(tempR.hasOwnProperty(r)){
                let clus = tempR[r];
                const cent = clus.centroid;
                let gc = getGridPosition(cent, G);

                const index = G.grid[gc.i][gc.j].indexOf(cent);
                G.grid[gc.i][gc.j].splice(index, 1);

                if(clus.members.length !== 0) {

                    clus.updateCentroid();

                    gc = getGridPosition(clus.centroid, G);
                    G.grid[gc.i][gc.j].push(clus.centroid);

                    R.push(clus);

                }
                //trying to remove/merge clusters with only 1 point
                /*else if(gr.members.length === 1) {

                    const p = gr.members[0];
                    let c = getClosestCentroid(p, G);
                    if(c !== null) {// FEHLER! WARUM KANN c NULL SEIN? -> Kein centroid in reichweite

                        const gr2 = c.g;//---------------------------------------------------
                        gr2.members.push(p);
                        gr2.members.forEach(function(point) {
                            point.c = c;
                            point.g = gr2;
                        });

                    } else {
                        data.clts.errors.push(p);
                        cnt++;
                    }

                }*/ else {
                    let k = 0;
                }
            }
        }
        //console.log('end ' + R.length + ', Number of merged centroids: ' + cnt);
    }

    function putInProperGroup(p, R, G) {
        const cent = getClosestCentroid(p, G);
        let clus = new Cluster();
        let gc;

        if (cent === null) {
            clus.addMember(p);
            clus.centroid = new Centroid(p);

            R.push(clus);
        } else {
            clus = cent.cluster; // g is group with centroid cent // indices? centroid array? -------------------------------

            gc = getGridPosition(cent, G);

            const index = G.grid[gc.i][gc.j].indexOf(cent);
            G.grid[gc.i][gc.j].splice(index, 1);

            clus.updateCentroid();
            clus.addMember(p);
        }
        gc = getGridPosition(clus.centroid, G);
        G.grid[gc.i][gc.j].push(clus.centroid);
    }
    function getClosestCentroid(p, G) {

        const gc = getGridPosition(p, G);
        const C = [];
        const range = 1;


        for(let k = Math.max(gc.i - range, 1);
            k < Math.min(gc.i + range, G.grid.length);
            k++) {

            for(let m = Math.max(gc.j - range, 1);
                m < Math.min(gc.j + range, G.grid[gc.i].length);
                m++) {

                for(let c in G.grid[k][m]) {
                    if(G.grid[k][m].hasOwnProperty(c)) {
                        if(((getSpatialDistance(p, G.grid[k][m][c])) <= bd.maxRadius) && (p.f === G.grid[k][m][c].f)) {
                            C.push(G.grid[k][m][c]);
                        }
                    }
                }
            }
        }

        if(C.length === 0) {
            return null;
        } else if(C.length === 1) {
            return C[0];
        } else {
            let ck = C[0];
            C.forEach(function(c) {
                if (getSpatialDistance(c, p) <= getSpatialDistance(ck, p)) {
                    ck = c;
                }
            });
            return ck;
        }
    }
    function getGridPosition(p, G) {
        return {
            i: Math.floor(( p.x - G.xMin ) / bd.maxRadius),
            j: Math.floor(( p.y - G.yMin ) / bd.maxRadius)
        };
    }
    function getSpatialDistance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
    }

    function connectTheDots(clusters) {
        clusters.forEach(function(cluster) {
            const centroid = cluster.centroid;
            //centroid.color = Math.random() * par.ct.color + par.ct.corrColor;
//            centroid.prev = new Set();
//            centroid.next = new Set();

            cluster.members.forEach(function (point) {
                if ((point.prevPoint !== null) && (point.prevPoint.centroid !== null)){
                    if((point.prevPoint.centroid !== point.centroid) && (point.prevPoint.centroid.f === point.centroid.f)) {
                        centroid.addPrevCentroid(point.prevPoint.centroid);
                    }
                }
                if ((point.nextPoint !== null) && (point.nextPoint.centroid !== null)){
                    if((point.nextPoint.centroid !== point.centroid) && (point.nextPoint.centroid.f === point.centroid.f)) {
                        centroid.addNextCentroid(point.nextPoint.centroid);
                    }
                }
            });
        });
        clusters.forEach(function (cluster) {
            const centroid = cluster.centroid;
            centroid.nextCentroids.forEach(function(nextCentroid) {
                data.grph.edges.val.push({
                    start: centroid,
                    end: nextCentroid
                });
            });
        });
    }

    function rand_BoxMuller() {
        const u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1].
        const v = 1 - Math.random();
        return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    }

//--MAKE-(THREE.JS)-----------------------------------------------------------------------------------------------------

    function makePoints(traj) {
        const trajGeom = makePointGeometry(traj.rawPoints);
        traj.dots = createDots(trajGeom, traj.color, par.pt.opacity, par.pt.size, traj);
    }
    function makeLine(traj) {
        const trajGeom = makePointGeometry(traj.rawPoints);
        traj.line = createLine(trajGeom, traj.color, par.tj.opacity, false, THREE.NoColors, THREE.FlatShading, traj);
    }
    function makeCentroid(clus) {
        const centGeom = makePointGeometry([clus.centroid]);
        clus.centDot = createDots(centGeom, clus.centroid.color, par.ct.opacity, par.ct.size, clus.centroid);
    }
    function makeCircle(clus) {
        const circleGeom = makeCircleGeometry(clus);
        clus.circMesh = createCircle(circleGeom, clus.centroid.color, par.ct.circles.opacity, true, null);//clus.centroid);
    }
    function makeCluster(clus) {
        const pointsGeom = makePointGeometry(clus.members);
        clus.membDots = createDots(pointsGeom, clus.centroid.color, par.pt.opacity, par.pt.size, clus.members);
    }
    function makeErrors() {
        const errorGeom = makePointGeometry(data.errors.val);
        draw.errors = createDots(errorGeom, par.cl.errors.color, par.pt.opacity, par.pt.size, data.errors.val); //temp
    }
    function makeGraph() {
        connectTheDots(data.clts.val);
        data.grph.edges.val.forEach(function(edge) {
            const edgeGeom = makeLineSegGeom(edge);
            const edgeLine = createLineSegment(edgeGeom, 0xffffff, 1.0, false,
                                                THREE.VertexColors, THREE.FlatShading, data.grph.edges);
            draw.grph.edges.push(edgeLine);
            //
        });
    }
    function makeBetter(traj) {
        traj.findCentroids();
        const trajGeom = makeTrajLineGeom(traj);
        traj.centLine = createLine(trajGeom, 0xffffff, par.ln.opacity, par.ln.transparency,
                                    THREE.VertexColors, THREE.FlatShading, traj);
    }
    function makeEvenBetter(traj) {
        traj.findCentroids();
        //traj.findAnchors();
        traj.findBezAnchors();
        //const trajGeom = makeTrajCurveGeom(traj);
        const trajGeom = makeTrajBezCurveGeom(traj);
        if(trajGeom && (traj.anchors.length !== 0)) {
            traj.anchLine = createLine(trajGeom, par.ln.color, par.ln.opacity, par.ln.transparency,
                                        THREE.NoColors, THREE.FlatShading, traj);
        }
    }

    function makePointGeometry(points) {
        const pointsGeom = new THREE.Geometry();
        points.forEach(function(point) {
            pointsGeom.vertices.push(new THREE.Vector3(point.x, -point.y, point.f));
        });
        return pointsGeom;
    } //three.js
    function makeCircleGeometry(clus) {
        const circleGeom = new THREE.CircleGeometry(bd.maxRadius / 2, par.ct.circles.segNum);
        circleGeom.translate(clus.centroid.x, -clus.centroid.y, clus.centroid.f + par.ct.circles.corrZ);
        return circleGeom;
    } //three.js
    function makeLineSegGeom(lineSeg) {
        const lineSegGeom = new THREE.Geometry();
        lineSegGeom.vertices.push(new THREE.Vector3(lineSeg.start.x, -lineSeg.start.y, lineSeg.start.f));
        lineSegGeom.vertices.push(new THREE.Vector3(lineSeg.end.x, -lineSeg.end.y, lineSeg.end.f));
        lineSegGeom.colors.push(new THREE.Color(lineSeg.start.color));
        lineSegGeom.colors.push(new THREE.Color(lineSeg.end.color));
        return lineSegGeom;
    } //three.js
    function makeTrajLineGeom(traj) {
        const trajGeom = new THREE.Geometry();
        traj.centroids.forEach(function(cent) {
            trajGeom.vertices.push(
                new THREE.Vector3(
                    cent.x + traj.deviation * par.tj.deviationFactor,
                    -cent.y + traj.deviation * par.tj.deviationFactor,
                    cent.f));
            trajGeom.colors.push(new THREE.Color(cent.color));
        });
        return trajGeom;
    } //three.js
    function makeTrajCurveGeom(traj) {
        if(traj.anchors.length > 1) {
            const anchorGeom = new THREE.Geometry();
            traj.anchors.forEach(function (anch) {
                anchorGeom.vertices.push(
                    new THREE.Vector3(
                        anch.x + traj.deviation * par.tj.deviationFactor,
                        -anch.y + traj.deviation * par.tj.deviationFactor,
                        anch.f));
            });
            const curve = new THREE.CatmullRomCurve3(anchorGeom.vertices);
            let curveGeom = new THREE.Geometry();
            curveGeom.vertices = curve.getPoints(50);

            return curveGeom;
        } else {
            return false;
        }
        //started to implement splines --> continue
        /*trajs.forEach(function (traj) {
         const anchorVertices = [];
         traj.anchors.forEach(function (point) {
         anchorVertices.push(
         new THREE.Vector3(
         point.x + traj.deviation * 0.25,
         point.y * -1 + traj.deviation * 0.25,
         point.f));
         });
         const anchorSpline = new THREE.SplineCurve3(anchorVertices);
         const path = new THREE.Path(anchorSpline.getPoints( 50 ));
         const anchorGeom = path.createPointsGeometry( 50 );
         anchorGeoms.push(anchorGeom);
         });*/
    } //three.js
    function makeTrajBezCurveGeom(traj) {
        if(traj.anchors.length > 2) {
            const a = traj.anchors;

            const geom = new THREE.CurvePath();

            let i = 0;
            const curveS = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(a[i].x, -a[i].y, a[i].f),
                new THREE.Vector3(a[i].x, -a[i].y, a[i].f),
                new THREE.Vector3(a[i + 1].x, -a[i + 1].y, a[i + 1].f)
            );
            geom.add(curveS);

            i++;
            while (i < traj.anchors.length - 2) {

                const curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(a[i].x, -a[i].y, a[i].f),
                    new THREE.Vector3(a[i + 1].x, -a[i + 1].y, a[i + 1].f),
                    new THREE.Vector3(a[i + 2].x, -a[i + 2].y, a[i + 2].f)
                );
                geom.add(curve);

                i += 2;
            }

            const curveE = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(a[i].x, -a[i].y, a[i].f),
                new THREE.Vector3(a[i + 1].x, -a[i + 1].y, a[i + 1].f),
                new THREE.Vector3(a[i + 1].x, -a[i + 1].y, a[i + 1].f)
            );
            geom.add(curveE);

            return geom.createPointsGeometry(50);
        } else {
            return false;
        }
    }

    function createDots(geom, color, opa, pointSize, userData = {}) {
        const mat = new THREE.PointsMaterial({color: color, opacity: opa, size: pointSize, sizeAttenuation: false});
        const dots = new THREE.Points(geom, mat);
        dots.userData = userData;
        return dots;
    } //three.js
    function createLine(geom, color, opa, trans, vColors, shad, userData = {}) {
        const mat = new THREE.LineBasicMaterial({color: color, opacity: opa, transparent: trans, vertexColors: vColors, shading: shad});
        const line = new THREE.Line(geom, mat);
        line.userData = userData;
        return line;
    } //three.js
    function createCircle(geom, color, opa, trans, userData = {}) {
        const mat = new THREE.MeshBasicMaterial({color: color, opacity: opa, transparent: trans});
        const circle = new THREE.Mesh(geom, mat);
        circle.userData = userData;
        return circle;
    }
    function createLineSegment(geom, color, opa, trans, vColors, shad, userData = {}) {
        const mat = new THREE.LineBasicMaterial({color: color, opacity: opa, transparent: trans, vertexColors: vColors, shading: shad});
        const lineSeg = new THREE.LineSegments(geom, mat);
        lineSeg.userData = userData;
        return lineSeg;
    }

//--ADD-&-REMOVE--------------------------------------------------------------------------------------------------------
//  ToDo: review lineTypes

    //--All-Trajectories------------------------------------------------------------------------------------------------
    /*function addAllTrajectories() { //abgesehen von clusters
        if (bd.lineType.points) {
            data.trjs.val.forEach(function(traj) {
                scene.add(traj.dots);
            });
        } else if (bd.lineType.lines) {
            data.trjs.val.forEach(function(traj) {
                scene.add(traj.line);
            });
        } else if(bd.lineType.centroids) {
            data.clts.forEach(function(clus) {
                scene.add(clus.centDot);
            });
        } else if(bd.lineType.circles) {
            data.clts.forEach(function(clus) {
                scene.add(clus.circMesh);
            });
        } else if(bd.lineType.clusters) {
            data.clts.forEach(function(clus) {
                scene.add(clus.membDots);
            });
            draw.errors.forEach(function(error) {
                scene.add(error);
            }); //temp
        } else if(bd.lineType.graph) {
            draw.grph.edges.forEach(function(edge) {
                scene.add(edge);
            });
        } else if(bd.lineType.better) {
            data.trjs.val.forEach(function(traj) {
                scene.add(traj.centLine);
            });
        } else if(bd.lineType.evenBetter) {
            data.trjs.val.forEach(function(traj) {
                scene.add(traj.anchLine);
            });
        }
    } //three.js
*/
    function showCheckedDrawings() {
        for(let ch in guiPar.lineType.choices) {
            if(guiPar.lineType.choices.hasOwnProperty(ch)) {
                if(bd.lineType[ch]) show(ch);
            }
        }
    }

    function show(choice) {
        switch(choice) {
            case 'points': {
                if(!data.trjs.valid) break;
                data.trjs.val.forEach(function(traj) {
                    if(!traj.dots) makePoints(traj);
                    scene.add(traj.dots);
                });
                break;
            }
            case 'lines': {
                if(!data.trjs.valid) break;
                data.trjs.val.forEach(function(traj) {
                    if(!traj.line) makeLine(traj);
                    scene.add(traj.line);
                });
                break;
            }
            case 'centroids': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.clts.val.forEach(function(clus) {
                    if(!clus.centDot) makeCentroid(clus);
                    scene.add(clus.centDot);
                });
                break;
            }
            case 'circles': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.clts.val.forEach(function(clus) {
                    if(!clus.circMesh) makeCircle(clus);
                    scene.add(clus.circMesh);
                });
                break;
            }
            case 'clusters': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.clts.val.forEach(function(clus) {
                    if(!clus.membDots) makeCluster(clus);
                    scene.add(clus.membDots);
                });
                if(data.errors.val.length !== 0) {
                    if(!draw.errors) makeErrors();
                    scene.add(draw.errors);
                }
                break;
            }
            case 'graph': {
                if(!data.clts.valid) cluster(data.trjs.val);
                if(draw.grph.edges.length === 0) makeGraph();
                draw.grph.edges.forEach(function(edge) {
                    scene.add(edge);
                });
                break;
            }
            case 'better': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.trjs.val.forEach(function(traj) {
                    if(!traj.centLine) makeBetter(traj);
                    scene.add(traj.centLine);
                });
                break;
            }
            case 'evenBetter': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.trjs.val.forEach(function(traj) {
                    if(!traj.anchLine) makeEvenBetter(traj);
                    if(traj.anchLine instanceof THREE.Line) {
                        scene.add(traj.anchLine);
                    }
                });
                break;
            }
        }
    }

    function hideDrawing(choices) {
        choices.forEach(function(choice) {
            switch(choice) {
                case 'bgMs': {
                    for (let bgMesh in draw.bgMs) {
                        if (draw.bgMs.hasOwnProperty(bgMesh)) {
                            scene.remove(draw.bgMs[bgMesh]);
                        }
                    }
                    break;
                }
                case 'grds': {
                    for (let floor in data.grds) {
                        if (data.grds.hasOwnProperty(floor)) {
                            scene.remove(data.grds[floor].drawing);
                        }
                    }
                    break;
                }
                case 'points': {
                    data.trjs.val.forEach(function(traj) {
                        scene.remove(traj.dots);
                    });
                    break;
                }
                case 'lines': {
                    data.trjs.val.forEach(function(traj) {
                        scene.remove(traj.line);
                    });
                    break;
                }
                case 'centroids': {
                    data.clts.val.forEach(function(clus) {
                        scene.remove(clus.centDot);
                    });
                    break;
                }
                case 'circles': {
                    data.clts.val.forEach(function(clus) {
                        scene.remove(clus.circMesh);
                    });
                    break;
                }
                case 'clusters': {
                    data.clts.val.forEach(function(clus) {
                        scene.remove(clus.membDots);
                    });
                    scene.remove(draw.errors);
                    break;
                }
                case 'graph': {
                    draw.grph.edges.forEach(function(edge) {
                        scene.remove(edge);
                    });
                    break;
                }
                case 'better': {
                    data.trjs.val.forEach(function(traj) {
                        scene.remove(traj.centLine);
                    });
                    break;
                }
                case 'evenBetter': {
                    data.trjs.val.forEach(function(traj) {
                        scene.remove(traj.anchLine);
                    });
                    break;
                }
            }
        });
    }
    function removeDrawing(choices) {
        choices.forEach(function(choice) {
            switch(choice) {
                case 'bgMs': {
                    draw.bgMs = {};
                    break;
                }
                case 'grds': {
                    for (let floor in data.grds) {
                        if (data.grds.hasOwnProperty(floor)) {
                            delete data.grds[floor].drawing;
                        }
                    }
                    break;
                }
                case 'trjs': {
                    data.trjs.val.forEach(function(traj) {
                        traj.emptyDrawing();
                    });
                    break;
                }
                case 'clts': {
                    data.clts.val.forEach(function(clus) {
                        clus.emptyClusterDrawing();
                    });
                    break;
                }
                case 'errors': {
                    draw.errors = null;
                    break;
                }
                case 'grph': {
                    draw.grph = {
                        edges: []
                    };
                    break;
                }
            }
        });
    }
    function deleteData(choices) {
        choices.forEach(function(choice) {
            switch(choice) {
                case 'trjs': {
                    data.trjs = {
                        valid: false,
                        val: [],
                    };
                    break;
                }
                case 'clts': {
                    data.clts = {
                        valid: false,
                        val: [],
                    };
                    break;
                }
                case 'errors': {
                    data.errors = {
                        valid: false,
                        val: [],
                    };
                    break;
                }
                case 'grph': {
                    data.grph = {
                        edges: {
                            valid: false,
                            val: [],
                        },
                    };
                    break;
                }
            }
        });
    }

    //--All-Trajectories------------------------------------------------------------------------------------------------
    function hideTrajectoryDrawings() {
        hideDrawing(['points', 'lines', 'centroids', 'circles', 'clusters', 'graph', 'better', 'evenBetter']);
    } //three.js
    function deleteTrajectoryData() {
        hideTrajectoryDrawings();
        deleteData(['trjs', 'clts', 'errors', 'grph']);
    }

    //--Special-Trajectories--------------------------------------------------------------------------------------------
    function hideClusterTrajectories() {
        hideDrawing(['centroids', 'circles', 'clusters', 'graph', 'better', 'evenBetter']);
    }
    function deleteClusterTrajectories() {
        hideClusterTrajectories();
        data.trjs.val.forEach(function(traj) {
            traj.emptyClusterData();
        });
        data.clts.valid = false;
        deleteData(['clts', 'errors', 'grph']);
    }

    //--Everything------------------------------------------------------------------------------------------------------
    function hideEverything() {
         hideDrawing(['bgMs', 'grds']);
         hideTrajectoryDrawings();
    }
    function deleteEverything() {
        deleteAllBgMeshes();
        deleteAllGrids();
        deleteTrajectoryData();
    }

    //--Meshes----------------------------------------------------------------------------------------------------------
    function deleteAllBgMeshes() {
        hideDrawing(['bgMs']);
        removeDrawing(['bgMs']);
    }

    //--Grids-----------------------------------------------------------------------------------------------------------
    function hideAllGrids() {
        hideDrawing(['grds']);
    }
    function deleteAllGrids() {
        hideDrawing(['grds']);
        removeDrawing(['grds']);
        deleteData(['grds']);
    }

//--CHANGE--------------------------------------------------------------------------------------------------------------
//  ToDo: review changeClusterRadius

    function changeScale() {
        deleteAllBgMeshes();
        deleteAllGrids();
        loadNewBgMesh(bd.path, bd.floor); //also invokes loadNewGrid();
        showCheckedDrawings();
    }
    function changeFloors() {
        if (!(draw.bgMs[bd.floor] instanceof THREE.Mesh)) {
            loadNewBgMesh(bd.path, bd.floor); //also invokes loadGrid()
        }
        updateCamera();
        updateRaycaster();
    }
    function changeLineType() {
        hideTrajectoryDrawings();
        showCheckedDrawings();
    }
    function changeClusterRadius() {
        hideTrajectoryDrawings();
        deleteClusterTrajectories();
        showCheckedDrawings();
    }
    function changeMaxRedist() {
        hideTrajectoryDrawings();
        deleteClusterTrajectories();
        showCheckedDrawings();
    }

</script>
</body>
</html>