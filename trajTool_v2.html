<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TrajTool</title>
    <style>
        body { margin: 0; overflow: hidden }
        canvas { width: 100%!important; height: auto!important; }

        .noselect {
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none; /* Safari */
            -khtml-user-select: none; /* Konqueror HTML */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently supported by Chrome and Opera */
        }
    </style>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/chroma.js"></script>
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script src="js/thenBy.js"></script>

<!--Trajectory viewer-->
<script>

    //'use strict';

//--CONSTANTS-&-VARIABLES-----------------------------------------------------------------------------------------------

    let camera, scene, renderer;
    let mouse, raycaster, INTERSECTED = new Set();
    let gui, infoDiv;
    let buildingFileClicker, trajectoryFileClicker, groundtruthFileClicker;
    let pointList, groundtruthList;


    const threePar = {
        cam: {
            corrNear: -0.1,
            corrFar: 0.1,
            corrZ: 100,
            positionZ: 100,
        },
        rend: {
            aa: true,
            alpha: true,
            color: 0xffffff,
            alphaVal: 0,
        },
        rayc: {
            clickColor: 0x00ff00,
            linePrec: 1,
        },
    };
    const guiPar = {
        folders: {
            load: {
                name: "Load things",
            },
            del: {
                name: "Delete things",
            },
            bdSettings: {
                name: "Building settings",
            },
            viewSettings: {
                name: "View settings",
            },
            lineTypes: {
                name: "Visible data",
            },
            dataSettings: {
                name: "Data settings",
            },
            infoSettings: {
                name: "Infobox settings"
            }
        },
        buttons: {
            bgLoader: {
                func: 'loadBuildingFile',
                name: 'Load building',
                initPath: 'white-',
                initExt: '.png',
            },
            dataLoader: {
                func: 'loadDataFile',
                name: 'Load trajectories',
            },
            gtLoader: {
                func: 'loadGroundtruthFile',
                name: 'Load groundtruths',
            },
            delAll: {
                func: 'deleteEverything',
                name: 'Delete everything',
            },
            delTrajectories: {
                func: 'deleteTrajectoryData',
                name: 'Delete trajectories',
            },
            hideGrid: {
                func: 'hideAllGrids',
                name: 'Hide grid',
            }

        },
        sliders: {
            scale: {
                func: 'scale',
                name: 'Scale (1:X)',
                min: 45,
                max: 100,
                step: 1,
                init: 49,
            },
            cutTime: {
                func: 'cutTime',
                name: 'Cut time',
                min: 1000,
                max: 1000000,
                step: 1000,
                init: 20000,
            },
            maxClusterRad: {
                func: 'maxRadius',
                name: 'Cluster radius',
                min: 5,
                max: 50,
                step: 5,
                init: 20,
            },
            redist: {
                func: 'redist',
                name: 'Redist count',
                min: 0,
                max: 50,
                step: 1,
                init: 50,
            },
            zoom: {
                func: 'zoom',
                name: 'Zoom',
                min: 1,
                max: 2,
                step: 0.1,
                init: 1.2,
            },
            floor: {
                func: 'floor',
                name: 'Floor',
                min: -2,
                max: 2,
                step: 1,
                init: 1,
            },
        },
        checkboxes: {
            lineTypes: {
                choices: {
                    points: {name: 'Dots', init: true},
                    lines: {name: 'Lines', init: false},
                    centroids: {name: 'Centroids', init: false},
                    circles: {name: 'Circles', init: false},
                    clusters: {name: 'Clusters', init: false},
                    graph: {name: 'Graph', init: false},
                    curves: {name: 'Curves', init: false},
                    groundtruth: {name: 'GT', init: true},
                },
            },
            infoTypes: {
                choices: {
                    basic: {name: 'Basic', init: true},
                    analysis: {name: 'Analysis', init: false},
                    extensive: {name: 'Extensive', init: false},
                }
            }
        }

    }; //ToDo: building path changed-----------------------------------------------------------------
    const par = {
        bg: {
            dir: 'img/',
            corrZ: -0.1,
        },
        gd: {
            delta: 5,
            corrZ: 0.1,
            line: {
                color: 0x555555,
                opacity: 1,
            }
        },
        tj: {
            color: 0xff0000,
            opacity: 1,
            clickColor: 0x000000,
            cutTime: 20000,
            dot: {
                opacity: 1,
                size: .4,
            },
            deviationFactor: 0.25, //should be changed depending on number of trajectories on connection
        },
        ln: {
            color: 0x000000,
            opacity: 0.4,
            transparency: true,
        },
        ct: {
            size: 1,
            opacity: 1,
            corrZ: 0.1,
            circles: {
                opacity: 0.2,
                segNum: 20,
                corrZ: -0.0,
            },
        },
        cl: {
            color: 0xffffff,
            corrColor: 0x555555,
            colorScaleType: ['darkgreen', 'forestgreen', 'yellowgreen', 'gold', 'orangered', 'crimson', 'darkred'], //'RdYlBu',
            colorDarkenFactor: 0,
            errors: {
                color: 0x0000ff,
            }
        },
        gt: {
            cutTime: 20000000,
        },
        csv: {
            header: 't,x,y,acc,f,did',
            removeCount: 5,
        },
        subsaRadius: 3,

        //tj = trajectory; pt = point; ct = centroid; bg = background; gd = grid
    };

    const flags = {
        dom: {
            infoDivCount: 0,
        },
        clustering: {
            redistChange: true,
            centID: 0,
            subsaPoints: 0,
        },
        raycaster: {
            shiftDown: false,
        },
    };

    class infoCont {
        constructor(heading, cont) {
            this.div = null;
            this.id = "infoCont_" + flags.dom.infoDivCount;
            flags.dom.infoDivCount++;
            this.style = {
                contDiv: {
                    position: "relative",
                    width: "auto",
                    height: "auto",
                    backgroundColor: "rgba(30, 30, 30, 1)",
                    margin: "0px",
                    paddingLeft: "4px",
                    paddingRight: "4px",
                    paddingTop: "1px",
                    paddingBottom: "2px",
                    borderBottom: "1px solid rgba(255,255,255,0.1)"
                },
                table: {},
                heading: {
                    fontWeight: "bold",
                    height: "1.8em",
                },
                columns: {
                    1: "35%",
                }
            };

            this.heading = heading || ["Description", "Value"];
            this.contBlocks = cont || [["Trajectory", ""]];
        }

        createDiv() {
            const contDiv = document.createElement('div');
            contDiv.id = this.id;
            for(let key in this.style.contDiv) {
                if(this.style.contDiv.hasOwnProperty(key)) {
                    contDiv.style[key] = this.style.contDiv[key];
                }
            }
            const table = document.createElement('table');
            table.style.borderSpacing = "5px";

            const heading = document.createElement('tr');
            for(let key in this.style.heading) {
                if(this.style.heading.hasOwnProperty(key)) {
                    heading.style[key] = this.style.heading[key];
                }
            }
            let first;
            if(this.heading.length < 3) first = true;
            this.heading.forEach(function(col) {
                const tempCol = document.createElement('td');
                tempCol.style.borderBottom = "1px dotted rgba(255,255,255,0.1)";

                if(first) {
                    tempCol.style.width = "35%";
                }
                first = false;

                tempCol.appendChild(document.createTextNode(col));
                heading.appendChild(tempCol);
            });
            table.appendChild(heading);

            this.contBlocks.forEach(function(content) {
                const tr = document.createElement('tr');
                content.forEach(function(col) {
                    const tempCol =  document.createElement('td');
                    tempCol.style.verticalAlign = "top";
                    tempCol.appendChild(document.createTextNode(col));
                    tr.appendChild(tempCol);
                });
                table.appendChild(tr);
            });

            contDiv.appendChild(table);
            this.div = contDiv;
        }

        removeDiv() {
            document.body.removeChild(this.div);
        }
    }

    const bd = {
        w: window.innerWidth, //building width
        wListener: function() {},
        get width() {
            return this.w;
        },
        set width(val) {
            this.w = val;
            this.wListener(val)
        },
        registerWListener: function(listener) {
            this.hListener = listener;
        },

        h: window.innerHeight, //building height
        hListener: function() {},
        get height() {
            return this.h;
        },
        set height(val) {
            this.h = val;
            this.hListener(val);
        },
        registerHListener: function(listener) {
            this.wListener = listener;
        },

        get ratio() {
            return this.w / this.h;
        },

        z: guiPar.sliders.zoom.init,
        zListener: function() {},
        get zoom() {
            return this.z;
        },
        set zoom(val) {
            if (val !== this.z) {
                this.z = val;
                this.zListener(val);
            }
        },
        registerZListener: function(listener) {
            this.zListener = listener;
        },

        f: guiPar.sliders.floor.init, //building floor
        fListener: function() {},
        get floor() {
            return this.f;
        },
        set floor(val) {
            if (val !== this.f) {
                this.f = val;
                this.fListener();
            }
        },
        registerFListener: function(listener) {
            this.fListener = listener;
        },

        s: guiPar.sliders.scale.init, //building scale
        sListener: function() {},
        get scale() {
            return this.s;
        },
        get scaleFraction() {
            return ( 1 / this.s );
        },
        set scale(val) {
            if (val !== this.s) {
                this.s = val;
                this.sListener(val);
            }
        },
        registerSListener: function(listener) {
            this.sListener = listener;
        },

        filePath: guiPar.buttons.bgLoader.initPath,
        fileExt: guiPar.buttons.bgLoader.initExt,
        get path() {
            return this.filePath + this.f + this.fileExt;
        },

        lt: {
            pt: guiPar.checkboxes.lineTypes.choices.points.init,
            ln: guiPar.checkboxes.lineTypes.choices.lines.init,
            ct: guiPar.checkboxes.lineTypes.choices.centroids.init,
            ci: guiPar.checkboxes.lineTypes.choices.circles.init,
            cl: guiPar.checkboxes.lineTypes.choices.clusters.init,
            bt: guiPar.checkboxes.lineTypes.choices.graph.init,
            eb: guiPar.checkboxes.lineTypes.choices.curves.init,
            gt: guiPar.checkboxes.lineTypes.choices.groundtruth.init,

            ltListener: function() {},

            get points() {return this.pt},
            set points(val) {
                this.pt = val;
                this.ltListener('points');
            },
            get lines() {return this.ln},
            set lines(val) {
                this.ln = val;
                this.ltListener('lines');
            },
            get centroids() {return this.ct},
            set centroids(val) {
                this.ct = val;
                this.ltListener('centroids');
            },
            get circles() {return this.ci},
            set circles(val) {
                this.ci = val;
                this.ltListener('circles');
            },
            get clusters() {return this.cl},
            set clusters (val) {
                this.cl = val;
                this.ltListener('clusters');
            },
            get graph() {return this.bt},
            set graph (val) {
                this.bt = val;
                this.ltListener('graph');
            },
            get curves() {return this.eb},
            set curves (val) {
                this.eb = val;
                this.ltListener('curves');
            },
            get groundtruth() {return this.gt},
            set groundtruth(val) {
                this.gt = val;
                this.ltListener('groundtruth');
            },
        }, //trajectory linetype
        get lineType() {
            return this.lt;
        },
        registerLtListener: function(listener) {
            this.lt.ltListener = listener;
        },

        iT: {
            ba: guiPar.checkboxes.infoTypes.choices.basic.init,
            an: guiPar.checkboxes.infoTypes.choices.analysis.init,
            ex: guiPar.checkboxes.infoTypes.choices.extensive.init,

            itListener: function(){},

            get basic() {return this.ba},
            set basic(val) {
                this.ba = val;
                this.itListener();
            },
            get analysis() {return this.an},
            set analysis(val) {
                this.an = val;
                this.itListener();
            },
            get extensive() {return this.ex},
            set extensive(val) {
                this.ex = val;
                this.itListener();
            },
        },
        get infoType() {
            return this.lt;
        },
        registerItListener: function(listener) {
            this.iT.itListener = listener;
        },

        cT: guiPar.sliders.cutTime.init,
        cTListener: function() {},
        get cutTime() {return this.cT},
        set cutTime(val) {
            this.cT = val;
            this.cTListener();
        },
        registerCtListener: function(listener) {
            this.cTListener = listener;
        },

        mR: guiPar.sliders.maxClusterRad.init, //cluster maxRadius
        mRListener: function() {},
        get maxRadius() {
            return this.mR;
        },
        set maxRadius(val) {
            if (val !== this.mR) {
                this.mR = val;
                this.mRListener(val);
            }
        },
        registerMRListener: function(listener) {
            this.mRListener = listener;
        },

        redi: guiPar.sliders.redist.init,
        rediListener: function() {},
        get redist() {
            return this.redi;
        },
        set redist(val) {
            if(val !== this.redi) {
                this.redi = val;
                this.rediListener(val);
            }
        },
        registerRediListener: function(listener) {
            this.rediListener = listener;
        },
    };
    bd.registerWListener(function() {
        updateCamera();
        updateRenderer();
    });
    bd.registerHListener(function() {
        updateCamera();
        updateRenderer();
    });
    bd.registerFListener(function() {
        changeFloors();
    });
    bd.registerZListener(function() {
        updateCamera();
    });
    bd.registerSListener(function() {
        changeScale();
    });
    bd.registerLtListener(function() {
        changeLineType();
    });
    bd.registerItListener(function() {
        changeInfoType();
    });
    bd.registerCtListener(function() {

    });
    bd.registerMRListener(function() {
        changeClusterRadius();
    });
    bd.registerRediListener(function() {
        changeMaxRedist();
    });

    const data = {
        grds: {},
        trjs: {
            valid: false,
            val: [],
        },
        grts: {
            valid: false,
            val: [],
        },
        clts: {
            valid: false,
            val: [],
        },
        edgs: {
            valid: false,
            val: [],
        },
        errors: {
            valid: false,
            val: [],
        }, //temp
    };
    const draw = {
        bgMs: [],
        grds: [],
        errors: null,
    };

    class Point {
        constructor(p) {
            this.col = par.tj.color;
            this.did = p.did;
            this.x = p.x;
            this.y = p.y;
            this.f = p.f;
            this.t = p.t;
            this.c = null;
            this.cl = null;
            this.prev = null;
            this.next = null;
            this.traj = p.traj;
            this.ID = p.ID;
        }
        get color() {return this.col}
        set color(val) {this.col = val}
        get centroid() { return this.c; }
        set centroid(cent) {
            this.c = cent;
        }
        get cluster() {return this.cl}
        set cluster(clus) {
            this.cl = clus;
            this.c = clus.c;
        }
        clearCluster() {
            this.cl = null;
            this.c = null;
        }
        get prevPoint() {return this.prev}
        set prevPoint(pt) {
            this.prev = pt;
            if(pt) pt.next = this;
        }
        get nextPoint() {return this.next}
        set nextPoint(pt) {
            this.next = pt;
            if(pt) pt.prev = this;
        }
        get trajectory() {return this.traj}
        set trajectory(tj) {this.traj = tj}
    }
    class Centroid extends Point {
        constructor(p) {
            super(p);
            this.prev = new Set(); // ev. Map mit Cent als key und anzahl als val?
            this.next = new Set();
            this.c = p.c;
            this.cl = p.cl;
            this.col = Math.random() * 0xffffff;
            this.ID = flags.clustering.centID;
            flags.clustering.centID++;
        }
        /*get prevCentroids() {return this.prev}
        set prevCentroids(set) {this.prev = set}
        addPrevCentroid(cent) {
            this.prev.add(cent);
            if(cent) cent.next.add(this);
        }
        get nextCentroids() {return this.next}
        set nextCentroids(set) {this.next = set}
        addNextCentroid(cent) {
            this.next.add(cent);
            if(cent) cent.prev.add(this);
        }*/
    }
    class Anchor extends Point {
        constructor(p) {
            super(p);
            this.col = p.col;
        }
        get prevAnchor() {return this.prev}
        set prevAnchor(anch) {
            this.prev = anch;
            if(anch) anch.next = this;
        }
        get nextAnchor() {return this.next}
        set nextAnchor(anch) {
            this.next = anch;
            if(anch) anch.prev = this;
        }
    }

    class Trajectory {
        constructor(rawData, floor) {
            this.f = floor;
            this.color = Math.random() * 0xffffff; //par.tj.color;
            this.deviation = rand_BoxMuller();
            this.data = {
                raw: rawData,
                subsa: [],
                clusters: [],
                anchors: [],
            };
            this.drawing = {
                dots: null,
                line: null,
                clusLine: null,
                anchLine: null,
            };
        }
        get rawPoints() {return this.data.raw}
        set rawPoints(points) {this.data.raw = points}
        emptyRawPoints() {this.data.raw = []}
        get subsaPoints() {return this.data.subsa}
        set subsaPoints(points) {this.data.subsa = points}
        emptySubsaPoints() {this.data.subsa = []}
        get clusters() {return this.data.clusters}
        set clusters(clusters) {this.data.clusters = clusters}
        addCluster(clus) {
            this.data.clusters.push(clus);
            clus.addTrajectory(this);
        }
        findCentroids() {
            this.emptyCentroids();

            let tc;

            if(this.subsaPoints[0].cluster){
                tc = this.subsaPoints[0].cluster;
                this.addCluster(this.subsaPoints[0].cluster);
            } else {
                const k = 0;
            }//ToDo: find cause of missing centroids

            let i = 1;
            while(i < this.subsaPoints.length) {
                if(this.subsaPoints[i].cluster){
                    if(this.subsaPoints[i-1].cluster !== this.subsaPoints[i].cluster) {
                        if(!this.subsaPoints[i].cluster) {
                            const k = 0;
                        }

                        let c = this.subsaPoints[i].cluster;
                        tc.addNextClusters(c);
                        this.addCluster(c);
                        tc = c;
                    }
                } else {
                    console.log("no Centroid found");
                }

                i++;
            }
        }
        emptyCentroids() {
            this.data.centroids = [];
        }
        get anchors() {return this.data.anchors}
        set anchors(anchs) {this.data.anchors = anchs}
        addAnchor(anch) {
            this.data.anchors.push(anch);
            //anch. implement if Anchor becomes a class
        }
        findAnchors() {
            this.emptyAnchors();
            this.addAnchor(new Anchor(this.clusters[0].centroid));

            let i = 1;
            if(this.clusters.length > 2) {
                while (i < this.clusters.length - 1) {

                    const p0 = this.clusters[i - 1].centroid;
                    const p1 = this.clusters[i].centroid;
                    const p2 = this.clusters[i + 1].centroid;

                    let p1p0 = {x: p0.x - p1.x, y: p0.y - p1.y};
                    let p1p2 = {x: p2.x - p1.x, y: p2.y - p1.y};

                    let abs_p1p0 = Math.sqrt(p1p0.x * p1p0.x + p1p0.y * p1p0.y);
                    let abs_p1p2 = Math.sqrt(p1p2.x * p1p2.x + p1p2.y * p1p2.y);

                    let cos_p0p2 = ((p1p0.x * p1p2.x + p1p0.y * p1p2.y) / (abs_p1p0 * abs_p1p2));

                    //let alpha = ((cos_p0p2 + 1.0) / 2.0 + params.alpha) / (1.0 + params.alpha);
                    let alpha = (cos_p0p2 + 1.0) / 2.0;

                    //boundaries
                    let beta = Math.max(alpha, 0.6); //changed to 0.6 to prevent hard edges
                    //beta = Math.min(beta, 0.95);

                    //beta = alpha;

                    const p01 = new Anchor({
                        x: (1 - beta) * p0.x + beta * p1.x,
                        y: (1 - beta) * p0.y + beta * p1.y,
                        f: p1.f,
                    });
                    const p12 = new Anchor({
                        x: beta * p1.x + (1 - beta) * p2.x,
                        y: beta * p1.y + (1 - beta) * p2.y,
                        f: p1.f
                    });

                    this.addAnchor(p01);
                    this.addAnchor(p12);

                    i++;
                }
            }

            if(this.clusters.length > 1){
                this.addAnchor(new Anchor(this.clusters[i].centroid));
            }
        }
        findBezAnchors() {
            this.emptyAnchors();

            let i = 0;
            while( i < this.clusters.length - 1) {

                const cA = this.clusters[i].centroid;
                const cB = this.clusters[i+1].centroid;

                const alpha = 0.5;

                const tempScale = chroma.scale([cA.color, cB.color]);

                const p = new Anchor({
                    x: alpha * cA.x + (1 - alpha) * cB.x,
                    y: alpha * cA.y + (1 - alpha) * cB.y,
                    f: cA.f,
                    col: tempScale(alpha),
            });
                /*const tempColor = (((cA.color * 0x0000FF + cB.color * 0x0000FF) / 2) +
                                    ((cA.color * 0x00FF00 + cB.color * 0x00FF00) / 2) +
                                    ((cA.color * 0xFF0000 + cB.color * 0xFF0000) / 2));*/

                this.addAnchor(new Anchor(cA));
                this.addAnchor(p);

                i++;
            }
            this.addAnchor(new Anchor(this.clusters[i].centroid));
        }
        emptyAnchors() {
            this.data.anchors = [];
        }

        emptyClusterData() {
            this.emptyClusterDrawing();
            this.emptySubsaPoints();
            this.emptyCentroids();
            this.emptyAnchors();
        }

        get dots() {return this.drawing.dots}
        set dots(dots) {this.drawing.dots = dots}
        get line() {return this.drawing.line}
        set line(line) {this.drawing.line = line}
        get centLine() {return this.drawing.centLine}
        set centLine(centLine) {this.drawing.centLine = centLine}
        get anchLine() {return this.drawing.anchLine}
        set anchLine(anchLine) {this.drawing.anchLine = anchLine}

        emptyClusterDrawing() {
            this.centLine = null;
            this.anchLine = null;
        }
        emptyDrawing() {
            this.emptyClusterDrawing();
            this.dots = null;
            this.line = null;
        }

        getBasicInfo() {
            const lM = Math.round(this.getLengthInMeters() * 100) / 100;
            const lP = this.rawPoints.length;
            const dur = this.getDurationInS();
            const speed = Math.round((lM / dur) * 360) / 100;
            return [
                ["Length", lM + " m"],
                ["Length", lP + " pts"],
                ["Duration", dur + " s"],
                ["Speed", speed + " km/h"],
                ["Connections", ]
            ];
        }
        getLengthInMeters() {
            const rp = this.rawPoints;
            let l = 0;
            for(let i = 0; i < rp.length - 1; i++) {
                l += Math.sqrt((rp[i].x - rp[i+1].x) * (rp[i].x - rp[i+1].x) +
                                (rp[i].y - rp[i+1].y) * (rp[i].y - rp[i+1].y));
            }
            return l;
        }
        getDurationInS() {
            return Math.trunc((this.rawPoints[this.rawPoints.length - 1].t - this.rawPoints[0].t) / 1000);
        }

        getAnalysisInfo() {return [['Hi', 'dude!']]}
        getExtensiveInfo() {return [['Hey', 'guy!']]}
    }
    class Cluster {
        constructor() {
            this.data = {
                centroid: {},
                edges: [],
                members: [],
                trajs: new Set(),
                anchors: [],
            };
            this.drawing = {
                centroid: null,
                circle: null,
                members: null,
            };
            this.prev = new Set();
            this.next = new Set();
        }
        get centroid() {return this.data.centroid}
        set centroid(cent) {
            this.data.centroid = cent;
            this.data.centroid.cluster = this;
            this.data.members.forEach(function(pt) {
                pt.centroid = cent;
            });
        }
        updateCentroid() {

            let sumX = 0;
            let sumY = 0;
            const points = this.members;
            const numPoints = this.members.length;

            for (let p in points) {
                if(points.hasOwnProperty(p)){
                    sumX += points[p].x;
                    sumY += points[p].y;
                }
            }

            if (numPoints > 0) {
                const tempCent = this.centroid;
                tempCent.x = sumX / numPoints;
                tempCent.y = sumY / numPoints;
                this.centroid = tempCent;
            } else {
                //ToDo: implement: delete cluster --------------------------------------
                this.centroid = null;
                console.error("updateCentroid: cluster has no members");
            }
        }

        get edges() {return this.data.edges}
        set edges(val) {this.data.edges = val}
        addEdge(edge) {
            this.data.edges.push(edge);


        }
        get members() {return this.data.members}
        set members(memb) {
            this.data.members = memb;
            if(this.data.centroid) {
                this.data.members.forEach(function(pt) {
                    pt.centroid = this.c;
                });
            }
        }
        addMember(pt) {
            pt.cluster = this;
            pt.centroid = this.centroid;
            this.data.members.push(pt);
            this.addTrajectory(pt.trajectory);
        }
        clearMembers() {
            this.data.members.forEach(function(pt) {
                pt.clearCluster();
            });
            this.data.members = [];
            this.clearTrajectories();
        }
        get trajectories() {
            return this.data.trajs;
        }
        addTrajectory(traj) {
            this.data.trajs.add(traj);
        }
        clearTrajectories() {
            this.data.trajs.clear();
        }
        get anchors() {return this.data.anchors}
        addAnchor(anch) {
            this.data.anchors.push(anch);
        }

        get centDot() {return this.drawing.centroid}
        set centDot(cent) {this.drawing.centroid = cent}
        get circMesh() {return this.drawing.circle}
        set circMesh(circle) {this.drawing.circle = circle}
        get membDots() {return this.drawing.members}
        set membDots(point) {this.drawing.members = point}

        get prevClusters() {return this.prev}
        set prevClusters(set) {this.prev = set}
        addPrevCluster(clus) {
            this.prev.add(clus);
            if(clus) clus.next.add(this);
        }
        get nextClusters() {return this.next}
        set nextClusters(set) {this.next = set}
        addNextClusters(clus) {
            this.next.add(clus);
            if(clus) clus.prev.add(this);
        }

        emptyClusterDrawing() {
            this.centDot = null;
            this.circMesh = null;
            this.membDots = null;
        }

        getBasicInfo() {
            const mem = this.members.length;
            const trajs = this.trajectories.size;
            const conns = this.prevClusters;
            conns.add(...this.nextClusters);

            return [
                ["Members", mem],
                ["Connections", conns.size],
                ["Ts Passing", trajs],
            ];
        }

    }
    class Edge {
        constructor() {
            this.data = {
                prevCluster: {},
                nextCluster: {},
            };
            this.drawing = {
                line: null,
            }
        }
        get prevCluster() {return this.data.prevCluster}
        set prevCluster(cent) {
            this.data.prevCluster = cent;
        }
        get nextCluster() {return this.data.nextCluster}
        set nextCluster(cent) {
            this.data.nextCluster = cent;
        }
    }

//--START---------------------------------------------------------------------------------------------------------------

    init();
    initRaycaster(); //broken for now
    update();

//--INITALIZATION-------------------------------------------------------------------------------------------------------
//  ToDo: Review init function (camera?)

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(0, 0, 0, 0, 0, 0, 0);
        initDOM();
        initRenderer();
        initCamera();
        initBackgroundFileInput();
        initPositionFileInput();
        initGroundtruthFileInput();
        initDatGUI();
        initWindowResizeListeners();
        initKeypressListener();
    }

    function initDOM() {
        const guiDiv = document.createElement('div');
        guiDiv.id = "guiDiv";
        guiDiv.className = "noselect";
        guiDiv.style.position = "absolute";
        guiDiv.style.right = "0px";
        guiDiv.style.height = "auto";
        document.body.appendChild(guiDiv);

        infoDiv = document.createElement('div');
        infoDiv.id = "infoDiv";
        infoDiv.className = "noselect";
        infoDiv.style.position = "absolute";
        infoDiv.style.right = "0px";
        infoDiv.style.bottom = "0px";
        infoDiv.style.width = "245px";
        infoDiv.style.height = "auto";
        infoDiv.style.maxHeight = "330px";
        infoDiv.style.backgroundColor = "rgba(20, 20, 20, 1)";
        infoDiv.style.overflowY = "auto";
        infoDiv.style.overflowX = "hidden";
        infoDiv.style.padding = "0px";
        infoDiv.style.color = "white";
        infoDiv.style.font = "11px 'Lucida Grande', sans-serif";

        const style = {
            position: "relative",
            width: "100%",
            height: "auto",
            margin: "0px",
            padding: "3px",
            borderBottom: "1px solid rgba(255,255,255,0.1)"
        };
        const tempDiv = document.createElement('div');
        tempDiv.id = "infoCont_heading";
        for(let key in style) {
            tempDiv.style[key] = style[key];
        }

        const table = document.createElement('table');
        table.style.width = "100%";
        table.style.borderSpacing = "2px";
        const heading = document.createElement('tr');
        const desCol = document.createElement('td');
        desCol.style.textAlign = "center";
        desCol.appendChild(document.createTextNode('Info'));
        heading.appendChild(desCol);
        table.appendChild(heading);
        tempDiv.appendChild(table);
        infoDiv.appendChild(tempDiv);
        document.body.appendChild(infoDiv);

        createTestInfo(0);
    }
    function createTestInfo(num) {
        for(let i = 1; i <= num; i++) {
            let test = new infoCont(
                ["Col 1", "Col 2"],
                [
                    ["Trajectory " + i,"wtf"],
                    ["Cluster " + i, "lorem ipsum, braindead ofofofofofofofoofofofo"]
                ]
            );
            test.createDiv();
        }
    }

    function initRenderer() {
        renderer = new THREE.WebGLRenderer({antialias: threePar.rend.aa, alpha: threePar.rend.alpha});
        renderer.setClearColor(threePar.rend.color, threePar.rend.alphaVal);//        renderer.setPixelRatio( window.devicePixelRatio ) ;
        document.body.appendChild(renderer.domElement);
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function initCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera = new THREE.OrthographicCamera(0, bd.width,
                0, -bd.width / windowRatio, 0, 200);
        } else {
            camera = new THREE.OrthographicCamera(0, bd.height * windowRatio,
                0, -bd.height, 0, 200);
        } //Temp code inside

        camera.position.z = 100;
        camera.lookAt(new THREE.Vector3(0,0,0));
        camera.updateProjectionMatrix();
    } //three.js
    function initRaycaster() {
        raycaster = new THREE.Raycaster();
        raycaster.near = 0; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
        raycaster.far = 200; //Math.round((bd.floor + par.bg.corrZ + threePar.cam.corrFar) * 100) / 100;
        raycaster.linePrecision = threePar.rayc.linePrec;
        mouse = new THREE.Vector2();
        window.addEventListener('click', onMouseClick, false);

        // when the mouse moves, call the given function
        //window.addEventListener( 'mousemove', onMouseClick, false );
    } //three.js

    function updateRenderer() {
        renderer.setSize(window.innerWidth, window.innerHeight);
    } //three.js
    function updateCamera() {
        const windowRatio = window.innerWidth / window.innerHeight;
        if( windowRatio < bd.ratio) {
            camera.right = bd.width;
            camera.bottom = -bd.width / windowRatio;
            camera.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
            camera.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.bg.corrZ + threePar.cam.corrFar) * 100) / 100;
        } else {
            camera.right = bd.height * windowRatio;
            camera.bottom = -bd.height;
            camera.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100; //Math.round((bd.floor + par.gd.corrZ + threePar.cam.corrNear) * 100) / 100;
            camera.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100;
        }
        camera.zoom = bd.zoom;
        camera.updateProjectionMatrix();
//        if( camerahelper ) {
//            camerahelper.update();
//        }
    } //three.js
    function updateRaycaster() {
        //if(bd.scaleFraction) raycaster.linePrecision = threePar.rayc.linePrec * bd.scale;
        //raycaster.linePrecision = 0;
        raycaster.near = Math.trunc((-bd.floor - par.gd.corrZ + threePar.cam.corrNear + threePar.cam.corrZ) * 100) / 100;
        raycaster.far = Math.trunc((-bd.floor - par.bg.corrZ + threePar.cam.corrFar + threePar.cam.corrZ) * 100) / 100;
    }

    function update() {
        //hoverDetector();
        requestAnimationFrame(update);
        renderer.render(scene, camera);
    } //three.js

//--RAYCASTER-----------------------------------------------------------------------------------------------------------

    function hoverDetector() {

        raycaster.setFromCamera(mouse, camera);

        // create an array containing all objects in the scene with which the ray intersects
        let intersects = raycaster.intersectObjects(scene.children) ;

        // INTERSECTED = the object in the scene currently closest to the camera
        //		and intersected by the Ray projected from the mouse position

        // if there is one (or more) intersections
        if (intersects.length > 0) {

            const obj = intersects[0].object;
            // if the closest object intersected is not the currently stored intersection object
            if ((obj !== INTERSECTED) && (obj.type === 'Line')) {
                // restore previous intersection object (if it exists) to its original color
                if (INTERSECTED) {
                    INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    INTERSECTED.material.needsUpdate = true;
                }
                // store reference to closest object as current intersection object
                INTERSECTED = intersects[0].object;
                // store color of closest object (for later restoration)
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                // set a new color for closest object
                INTERSECTED.material.color.setHex( 0x00ff00 );
                INTERSECTED.material.needsUpdate = true;
            }
        } else {// there are no intersections
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED) {
                INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED.material.needsUpdate = true;
            }

            // remove previous intersection object reference
            // by setting current intersection object to "nothing"
            INTERSECTED = null;
        }
    }

    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // create an array containing all objects in the scene with which the ray intersects
        let intersects = raycaster.intersectObjects(scene.children, true) ;

        // INTERSECTED = the object in the scene currently closest to the camera
        // and intersected by the Ray projected from the mouse position

        // if there is one (or more) intersections
        if (intersects.length > 0) {

            let obj;
            let tempGeom = null;

            for(let o = 0; o < intersects.length; o++) {

                const tempObj = intersects[o].object;

                if((!(intersects[o].distance.isNaN)) && (tempObj.geometry !== tempGeom) &&
                    ((Math.trunc(intersects[o].point.z * 100) / 100) === bd.floor))
                    outer_if:{

                    tempGeom = tempObj.geometry;

                    if(tempObj.userData instanceof Trajectory) {
                        obj = {
                            type: 'trajectory',
                            userData: tempObj.userData,
                        };
                        break outer_if;
                    } else if(tempObj.userData instanceof Centroid) {
                        obj = {
                            type: 'centroid',
                            userData: tempObj.userData,
                        };
                        break outer_if;
                    } else if(tempObj.userData instanceof Array) {
                        if(tempObj.userData[0].centroid) {
                            obj = {
                                type: 'member',
                                userData: tempObj.userData,
                            };
                        } else {
                            obj = {
                                type: 'error',
                                userData: tempObj.userData,
                            };
                        }
                        break outer_if;
                    }
                }
            }

            if(obj) {
                if((!flags.raycaster.shiftDown) && (INTERSECTED.size !== 0)) {
                    INTERSECTED.forEach(function(o) {
                        unClick(o);
                    });
                    INTERSECTED.clear();
                    INTERSECTED.add(obj);
                    click(obj);
                } else {
                    let has = false;
                    INTERSECTED.forEach(function(o) {
                        if(obj.userData === o.userData) {
                            obj = o;
                            has = true;
                        }
                    });
                    if (has) {
                        unClick(obj);
                        INTERSECTED.delete(obj);
                    } else {
                        INTERSECTED.add(obj);
                        click(obj);
                    }
                }
            } else {
                INTERSECTED.forEach(function(o) {
                    unClick(o);
                });
                INTERSECTED.clear();
            }
        }
    }

    function click(o){
        switch(o.type) {
            case 'trajectory': {
                clickTrajectory(o.userData);
                showInfo(o);
                break;
            }
            case 'centroid': {
                clickCluster(o.userData.cluster);
                showInfo(o);
                break;
            }
            case 'member': {
                clickCluster(o.userData[0].cluster);
                showInfo(o);
                break;
            }
            case 'error':
                clickErrors();
                showInfo(o);
                break;
        }
    }
    function unClick(o) {
        switch(o.type) {
            case 'trajectory': {
                unClickTrajectory(o.userData);
                unShowInfo(o);
                break;
            }
            case 'centroid': {
                unClickCluster(o.userData.cluster);
                unShowInfo(o);
                break;
            }
            case 'member': {
                unClickCluster(o.userData[0].cluster);
                unShowInfo(o);
                break;
            }
            case 'error':
                unClickErrors();
                unShowInfo(o);
                break;
        }
    }

    function clickTrajectory(traj) {
        if(traj.dots) {
            traj.dots.children.forEach(function(dot) {
                dot.material.color.set(threePar.rayc.clickColor);
                dot.material.needsUpdate = true;
            });
        }
        if(traj.line) {
            traj.line.material.color.set(threePar.rayc.clickColor);
            traj.line.material.needsUpdate = true;
        }
        if(traj.centLine) {
            traj.centLine.material.vertexColors = THREE.NoColors;
            traj.centLine.material.color.set(threePar.rayc.clickColor);
            traj.centLine.material.needsUpdate = true;
        }
        if(traj.anchLine) {
            //traj.drawing.anchLine.material.vertexColors = THREE.NoColors;
            traj.anchLine.material.color.set(threePar.rayc.clickColor);
            traj.anchLine.material.needsUpdate = true;
        }
        if(traj.clusters.length !== 0) {
            traj.clusters.forEach(function(clus) {
                if(clus.centDot) {
                    clus.centDot.material.color.set(threePar.rayc.clickColor);
                    clus.centDot.material.needsUpdate = true;
                }
            });
        }
    }
    function unClickTrajectory(traj) {
        if (traj.dots) {
            traj.dots.children.forEach(function(dot) {
                dot.material.color.set(traj.color);
                dot.material.needsUpdate = true;
            });
        }
        if (traj.line) {
            traj.line.material.color.set(traj.color);
            traj.line.material.needsUpdate = true;
        }
        if (traj.centLine) {
            traj.centLine.material.vertexColors = THREE.VertexColors;
            traj.centLine.material.color.set(0xffffff);
            traj.centLine.material.needsUpdate = true;
        }
        if (traj.anchLine) {
            //traj.anchLine.material.vertexColors = THREE.VertexColors;
            traj.anchLine.material.color.set(par.ln.color);
            traj.anchLine.material.needsUpdate = true;
        }
        if(traj.clusters.length !== 0) {
            traj.clusters.forEach(function(clus) {
                if(clus.centDot) {
                    clus.centDot.material.color.set(cent.color);
                    clus.centDot.material.needsUpdate = true;
                }
            });
        }
    }
    function clickCluster(clus) {
        if (clus.centDot) {
            clus.centDot.material.color.set(threePar.rayc.clickColor);
            clus.centDot.material.needsUpdate = true;
        }
        if (clus.circMesh) {
            clus.circMesh.material.color.set(threePar.rayc.clickColor);
            clus.circMesh.material.needsUpdate = true;
        }
        if (clus.membDots) {
            clus.membDots.children.forEach(function(dot) {
                dot.material.color.set(threePar.rayc.clickColor);
                dot.material.needsUpdate = true;
            });
        }
        if (clus.trajectories.size !== 0) {
            clus.trajectories.forEach(function (traj) {
                clickTrajectory(traj); //ToDo
            });
        }
    }
    function unClickCluster(clus) {
        if (clus.centDot) {
            clus.centDot.material.color.set(clus.centroid.color);
            clus.centDot.material.needsUpdate = true;
        }
        if (clus.circMesh) {
            clus.circMesh.material.color.set(clus.centroid.color);
            clus.circMesh.material.needsUpdate = true;
        }
        if (clus.membDots) {
            clus.membDots.children.forEach(function(dot) {
                dot.material.color.set(clus.centroid.color);
                dot.material.needsUpdate = true;
            });
        }
        if (clus.trajectories.size !== 0) {
            clus.trajectories.forEach(function (traj) {
                unClickTrajectory(traj)
            });
        }
    }
    function clickErrors() {
        if (draw.errors) {
            draw.errors.children.forEach(function(dot) {
                dot.material.color.set(threePar.rayc.clickColor);
                dot.material.needsUpdate = true;
            });
        }
    }
    function unClickErrors() {
        if (draw.errors) {
            draw.errors.children.forEach(function(dot) {
                dot.material.color.set(par.cl.errors.color);
                dot.material.needsUpdate = true;
            });
        }
    }

    function showInfo(o) {
        switch(o.type) {
            case 'trajectory': {
                if(!o.hasOwnProperty('info')) {

                    const tempInfo = [];
                    if(bd.iT.basic) tempInfo.push(...o.userData.getBasicInfo());
                    if(bd.iT.analysis) tempInfo.push(...o.userData.getAnalysisInfo());
                    if(bd.iT.extensive) tempInfo.push(...o.userData.getExtensiveInfo());

                    o.info = new infoCont(
                        ["Description", "Content"],
                        tempInfo
                    );
                    o.info.createDiv();
                }
                infoDiv.appendChild(o.info.div);
                break;
            }
            case 'centroid': {
                if(!o.hasOwnProperty('info')) {
                    o.info = new infoCont(
                        ["Description", "Content"],
                        o.userData.cluster.getBasicInfo()
                    );
                    o.info.createDiv();
                }
                infoDiv.appendChild(o.info.div);
                break;
            }
            case 'member': {
                if(!o.hasOwnProperty('info')) {
                    o.info = new infoCont(
                        ["Description", "Content"],
                        o.userData[0].cluster.getBasicInfo()
                    );
                    o.info.createDiv();
                }
                infoDiv.appendChild(o.info.div);
                break;
            }
            case 'error':
                if(!o.hasOwnProperty('info')) {
                    o.info = new infoCont(
                        ["Description", "Content"],
                        [["Number of Errors: ", o.userData.length]]
                    );
                    o.info.createDiv();
                }
                infoDiv.appendChild(o.info.div);
                break;
        }
    }
    function unShowInfo(o) {
        document.getElementById('infoDiv').removeChild(o.info.div);
        delete o.info;
    }


    //temp code inside
    function onDocumentMouseMove(event){
        // the following line would stop any other event handler from firing
        // (such as the mouse's TrackballControls)
        // event.preventDefault();

        // update the mouse variable
//        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
//        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    function initWindowResizeListeners() {
        window.addEventListener(
            'resize',
            function() {
                updateRenderer();
                updateCamera();
            },
            false);
    }
    function initKeypressListener() {
        document.addEventListener("keydown", function(event) {
            if (event.keyCode === 16) {
                flags.raycaster.shiftDown = true;
            }
        });
        document.addEventListener("keyup", function(event) {
            if (event.keyCode === 16) {
                flags.raycaster.shiftDown = false;
            }
        });
    }

    function initBackgroundFileInput() {
        const buildingFileInput = document.createElement('input');
        buildingFileInput.id = "buildingFileInput";
        buildingFileInput.type = "file";
        buildingFileInput.accept = "image/*";
        buildingFileInput.style.position = "absolute";
        buildingFileInput.style.visibility = "hidden";
        document.body.appendChild(buildingFileInput);

        buildingFileInput.addEventListener('change', function () {
            const file = buildingFileInput.files[0];
            const fileName = buildingFileInput.files[0].name;
            const fileType = /image.*/;

            if(file.type.match(fileType)) {
                bd.filePath = fileName.slice(0, -5);
                bd.fileExt = fileName.slice(-4, fileName.length);
                deleteEverything();
                changeFloors();
            } else {
                alert("File not supported");
            }
        });
        buildingFileClicker = {
            loadBuildingFile: function () {
                document.getElementById("buildingFileInput").click();
            }
        };
    }
    function initPositionFileInput() {
        const dataFileInput = document.createElement('input');
        dataFileInput.id = "dataFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild(dataFileInput);

        dataFileInput.addEventListener('change', function () {
            const fileCount = dataFileInput.files.length;
            const result = [];
            for(let file = 0; file < fileCount; file++) {
                const reader = new FileReader();
                reader.onload = function () {
                    result.push(this.result);
                    if (result.length === fileCount) {
                        pointList = loadPointList(result);
                        newTrajectoriesByFloor(sortAndGroupList(pointList, true, par.tj.cutTime));
                        //newTrajectories(sortAndGroupList(pointList, false));
                        deleteClusterTrajectories();
                        showCheckedDrawings();
                    }
                };
                reader.readAsText(dataFileInput.files[file]);
            }
            this.value = null; //remove filename from input
        });
        trajectoryFileClicker = {
            loadDataFile: function () {
                document.getElementById("dataFileInput").click();
            }
        };
    }
    function initGroundtruthFileInput() {
        const dataFileInput = document.createElement('input');
        dataFileInput.id = "groundtruthFileInput";
        dataFileInput.type = "file";
        dataFileInput.accept = ".csv";
        dataFileInput.multiple = true;
        dataFileInput.style.position = "absolute";
        dataFileInput.style.visibility = "hidden";
        document.body.appendChild(dataFileInput);

        dataFileInput.addEventListener('change', function () {
            const fileCount = dataFileInput.files.length;
            const result = [];
            for(let file = 0; file < fileCount; file++) {
                const reader = new FileReader();
                reader.onload = function () {
                    result.push(this.result);
                    if (result.length === fileCount) {
                        groundtruthList = loadGroundtruthList(result);
                        const sortedGts = [];
                        groundtruthList.forEach(function(gt) {
                            sortedGts.push(sortAndGroupList(gt, true, par.gt.cutTime));
                        });
                        sortedGts.forEach(function(gt) {
                            newGroundtruth(gt);
                        });
                        data.grts.valid = true;

                        //newTrajectories(sortAndGroupList(pointList, false));
                        hideGroundtruthTrajectories();
                        showCheckedDrawings();
                    }
                };
                reader.readAsText(dataFileInput.files[file]);
            }
            this.value = null; //remove filename from input
        });
        groundtruthFileClicker = {
            loadGroundtruthFile: function () {
                document.getElementById("groundtruthFileInput").click();
            }
        };
    }
    function initDatGUI() {
        //gui = new dat.GUI({autoPlace: false});
        gui = new dat.GUI({autoPlace: false, right: 0});

        const fLoad = gui.addFolder(guiPar.folders.load.name);
        fLoad.add(buildingFileClicker, guiPar.buttons.bgLoader.func).name(guiPar.buttons.bgLoader.name);
        fLoad.add(trajectoryFileClicker, guiPar.buttons.dataLoader.func).name(guiPar.buttons.dataLoader.name);
        fLoad.add(groundtruthFileClicker, guiPar.buttons.gtLoader.func).name(guiPar.buttons.gtLoader.name);
        fLoad.open();

        const fDelete = gui.addFolder(guiPar.folders.del.name);
        fDelete.add(this, guiPar.buttons.delAll.func).name(guiPar.buttons.delAll.name);
        fDelete.add(this, guiPar.buttons.delTrajectories.func).name(guiPar.buttons.delTrajectories.name);

        const fBdSettings = gui.addFolder(guiPar.folders.bdSettings.name);
        fBdSettings.add(bd, guiPar.sliders.scale.func, guiPar.sliders.scale.min, guiPar.sliders.scale.max)
                        .step(guiPar.sliders.scale.step).name(guiPar.sliders.scale.name);

        const fViewSettings = gui.addFolder(guiPar.folders.viewSettings.name);
        fViewSettings.add(this, guiPar.buttons.hideGrid.func).name(guiPar.buttons.hideGrid.name);
        fViewSettings.add(bd, guiPar.sliders.zoom.func, guiPar.sliders.zoom.min, guiPar.sliders.zoom.max)
                            .step(guiPar.sliders.zoom.step).name(guiPar.sliders.zoom.name);

        const fLineTypes = gui.addFolder(guiPar.folders.lineTypes.name);
        fLineTypes.add(bd, guiPar.sliders.floor.func, guiPar.sliders.floor.min, guiPar.sliders.floor.max)
                        .step(guiPar.sliders.floor.step).name(guiPar.sliders.floor.name);
        for(let ch in guiPar.checkboxes.lineTypes.choices) {
            if(guiPar.checkboxes.lineTypes.choices.hasOwnProperty(ch)) {
                fLineTypes.add(bd.lt, ch).name(guiPar.checkboxes.lineTypes.choices[ch].name);
            }
        }
        fLineTypes.open();

        const fDataSettings = gui.addFolder(guiPar.folders.dataSettings.name);
        fDataSettings.add(bd, guiPar.sliders.cutTime.func, guiPar.sliders.cutTime.min, guiPar.sliders.cutTime.max)
                            .step(guiPar.sliders.cutTime.step).name(guiPar.sliders.cutTime.name);
        fDataSettings.add(bd, guiPar.sliders.maxClusterRad.func, guiPar.sliders.maxClusterRad.min, guiPar.sliders.maxClusterRad.max)
                            .step(guiPar.sliders.maxClusterRad.step).name(guiPar.sliders.maxClusterRad.name);
        fDataSettings.add(bd, guiPar.sliders.redist.func, guiPar.sliders.redist.min, guiPar.sliders.redist.max)
                            .step(guiPar.sliders.redist.step).name(guiPar.sliders.redist.name);

        const fInfoSettings = gui.addFolder(guiPar.folders.infoSettings.name);
        for(let ch in guiPar.checkboxes.infoTypes.choices) {
            if(guiPar.checkboxes.infoTypes.choices.hasOwnProperty(ch)) {
                fInfoSettings.add(bd.iT, ch).name(guiPar.checkboxes.infoTypes.choices[ch].name);
            }
        }
        fInfoSettings.open();

        const guiDiv = document.getElementById('guiDiv');
        guiDiv.appendChild(gui.domElement);

    } //dat.gui

//--LOAD-BASICS---------------------------------------------------------------------------------------------------------

    function loadNewBgMesh(buildingName, floor) {
        const buildingPath = par.bg.dir + buildingName;
        let backgroundMesh;
        let bgMaterial = new THREE.MeshBasicMaterial();

        const bgLoader = new THREE.TextureLoader();
        bgLoader.load(
            buildingPath,
            function (texture) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                //translate pixels into meters -- ATTENTION! BG-imgs have to have same size!
                bd.width = texture.image.naturalWidth * bd.scaleFraction;
                bd.height = texture.image.naturalHeight * bd.scaleFraction;

                //create bgPlane
                const backgroundPlane = new THREE.Geometry();

                backgroundPlane.vertices.push(new THREE.Vector3(0, 0, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(0, -bd.height, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, -bd.height, floor + par.bg.corrZ));
                backgroundPlane.vertices.push(new THREE.Vector3(bd.width, 0, floor + par.bg.corrZ));

                backgroundPlane.faces.push(new THREE.Face3(0, 1, 3));
                backgroundPlane.faces.push(new THREE.Face3(1, 2, 3));//backgroundPlane.computeFaceNormals();
                backgroundPlane.faceVertexUvs[0] = [];
                backgroundPlane.faceVertexUvs[0].push([new THREE.Vector2(0, 1),
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.faceVertexUvs[0].push([
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 0),
                    new THREE.Vector2(1, 1)
                ]);
                backgroundPlane.uvsNeedUpdate = true;

                backgroundMesh = new THREE.Mesh(
                    backgroundPlane,
                    bgMaterial
                );

                draw.bgMs[floor] = backgroundMesh;
                scene.add(draw.bgMs[floor]);

                genGrid(floor);
                drawGrid(floor);
            },
            function () {
            },
            function () {
                console.log('BG-loading failed');
            }
        );
    } //three.js
    function genGrid(floor) {

        let coordLines = [];

        for (let i = 0; i < ( bd.height ); i += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: 0,
                    y: i,
                    f: floor,
                },
                p1: {
                    x: bd.width,
                    y: i,
                    f: floor,
                }
            });
        }
        for (let j = 0; j < ( bd.width ); j += par.gd.delta) {
            coordLines.push({
                p0: {
                    x: j,
                    y: 0,
                    f: floor,
                },
                p1: {
                    x: j,
                    y: bd.height,
                    f: floor,
                }
            });
        }
        data.grds[floor] = {};
        data.grds[floor].val = coordLines;
        data.grds[floor].valid = true;
    }
    function drawGrid(floor) {

        const coordGeometry = new THREE.Geometry();
        data.grds[floor].val.forEach(function(line) {
            coordGeometry.vertices.push(new THREE.Vector3(line.p0.x, -line.p0.y, line.p0.f + par.gd.corrZ));
            coordGeometry.vertices.push(new THREE.Vector3(line.p1.x, -line.p1.y, line.p1.f + par.gd.corrZ));
        });

        const coordMaterial = new THREE.LineBasicMaterial({
            color: par.gd.line.color,
            opacity: par.gd.line.color,
        });

        data.grds[floor].drawing = new THREE.LineSegments(coordGeometry, coordMaterial);
        scene.add(data.grds[floor].drawing); //ToDo: reenable grids
    } //three.js -- disabled

//--LOAD-TRAJECTORIES---------------------------------------------------------------------------------------------------
//  ToDo: Implement function for removing first and last locations of recording

    function loadPointList(readerResult) {

        data.trjs.valid = false;
        data.clts.valid = false;
        data.errors.valid = false;

        let pointList = [];

        //--create-Point-Objects--------------------------------------------------------------------------------------------
        readerResult.forEach(function (file) {
            const tempList = parseCSV(file);

            tempList.splice(0, par.csv.removeCount);
            tempList.splice(-par.csv.removeCount);

            tempList.forEach(function (point) {
                const p = new Point(point);
                pointList.push(p);
            });
        });

        return pointList;
    }
    function loadGroundtruthList(readerResult) {

        data.grts.valid = false;

        const list = [];

        //--create-Point-Objects--------------------------------------------------------------------------------------------
        readerResult.forEach(function(file) {

            let pointList = [];

            const tempList = parseCSV(file);

            //tempList.splice(0, par.csv.removeCount);
            //tempList.splice(-par.csv.removeCount);

            tempList.forEach(function (point) {
                const p = new Point(point);
                pointList.push(p);
            });

            list.push(pointList);
        });

        return list;
    }
    function parseCSV(csvString) {
        const parseResult = Papa.parse(csvString, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            comments: '#',
            //step: true,
            beforeFirstChunk: function (chunk) {
                const rows = chunk.split(/\r\n|\r|\n/);
                rows[0] = par.csv.header;
                return rows.join("\r\n");
            }
        });
        return parseResult.data;
    }

    function sortAndGroupList(pL, floor, cutTime) {
        //--sort-Points-----------------------------------------------------------------------------------------------------
        let pointList = sortPointList(pL);

        const pointListByDID = groupPointListByDid(pointList);
        const pointListByDIDByTime = [];
        const pointListByDIDByTimeByFloor = [];

        for (let did in pointListByDID) {
            if (pointListByDID.hasOwnProperty(did)) {
                pointListByDIDByTime[did] = groupPointListByTime(pointListByDID[did], cutTime);
            }
        }

        if(!floor) {
            return pointListByDIDByTime;
        } else {
            for (let did in pointListByDIDByTime) {
                if (pointListByDIDByTime.hasOwnProperty(did)) {
                    pointListByDIDByTimeByFloor[did] = [];
                    for (let t in pointListByDIDByTime[did]) {
                        if (pointListByDIDByTime[did].hasOwnProperty(t)) {
                            pointListByDIDByTimeByFloor[did][t] = groupPointListByFloor(pointListByDIDByTime[did][t]);
                        }
                    }
                }
            }
            return pointListByDIDByTimeByFloor;
        }

        /*const pointListByDID = groupPointListByDid(pointList);

        const pointListByDIDByFloor = [];
        pointListByDID.forEach(function(didList) {
            pointListByDIDByFloor.push(groupPointListByFloor(didList));
        });

        const pointListByDIDByFloorByTime = [];
        pointListByDIDByFloor.forEach(function(didList) {
           didList.forEach(function(timeList) {
               pointListByDIDByFloorByTime.push(groupPointListByFloor(timeList));
           });
        });
        return pointListByDIDByTimeByFloor;*/
    }

    function sortPointList(pointList) {
        pointList.sort(
            firstBy("did")
                .thenBy("f")
                .thenBy("t")
        );
        return pointList;
    }
    function groupPointListByDid(pointList) {
        return groupBy(pointList, function(item) {
                return [item.did]; //, item.t
            }
        );
    }
    function groupPointListByTime(pointList, cutTime) {

        const pointListByTime = [];

        let tempTime = pointList[0].t;
        let tempTimeArray = [];

        pointList.forEach(function(point) {
            if (tempTime + cutTime < point.t) {
                pointListByTime.push(tempTimeArray);
                tempTimeArray = [];
                tempTimeArray.push(point);
                tempTime = point.t;
            } else {
                tempTimeArray.push(point);
                tempTime = point.t;
            }
        });
        pointListByTime.push(tempTimeArray);
        return pointListByTime;
    }
    function groupPointListByFloor(pointList) {
        return groupBy(pointList, function(item) {
                return [item.f]; //, item.t
            }
        );
    }
    function groupBy(array, f) {

        const groups = {};
        array.forEach(
            function(object) {
                const group = JSON.stringify(f(object));
                groups[group] = groups[group] || []; //if groups[group] doesn't exist, [] is assigned
                groups[group].push(object);
            }
        );
        return groups;
    }

    function newTrajectories(pL) {
        const pointListByDIDByTime = pL;

        for(let did in pointListByDIDByTime) {
            if(pointListByDIDByTime.hasOwnProperty(did)) {
                for(let t in pointListByDIDByTime[did]) {
                    if(pointListByDIDByTime[did].hasOwnProperty(t)) {

                        const tempTrajectory = new Trajectory(pointListByDIDByTime[did][t], null);
                        tempTrajectory.rawPoints.forEach(function (pt) {
                            pt.trajectory = tempTrajectory;
                        });

                        if (tempTrajectory.rawPoints.length > 1) {

                            let tempPrevPoint = tempTrajectory.rawPoints[0];
                            tempPrevPoint.prevPoint = null;

                            for (let p = 0; p < tempTrajectory.rawPoints.length; p++) {
                                tempPrevPoint.nextPoint = tempTrajectory.rawPoints[p];
                                tempTrajectory.rawPoints[p].prevPoint = tempPrevPoint;
                                tempPrevPoint = tempTrajectory.rawPoints[p];
                            }
                        data.trjs.val.push(tempTrajectory);
                        }
                    }
                }
            }
        }
        data.trjs.valid = true;
    }
    function newTrajectoriesByFloor(pL) {
        //--create-Trajectories---------------------------------------------------------------------------------------------
        const pointListByDIDByTimeByFloor = pL;

        for(let did in pointListByDIDByTimeByFloor) {
            if(pointListByDIDByTimeByFloor.hasOwnProperty(did)) {
                for(let t in pointListByDIDByTimeByFloor[did]) {
                    if(pointListByDIDByTimeByFloor[did].hasOwnProperty(t)) {
                        for (let f in pointListByDIDByTimeByFloor[did][t]) {
                            if (pointListByDIDByTimeByFloor[did][t].hasOwnProperty(f)) {

                                const tempTrajectory = new Trajectory(pointListByDIDByTimeByFloor[did][t][f], f);
                                tempTrajectory.rawPoints.forEach(function(pt) {
                                    pt.trajectory = tempTrajectory;
                                });

                                if (tempTrajectory.rawPoints.length > 1) {

                                    let tempPrevPoint = tempTrajectory.rawPoints[0];
                                    tempPrevPoint.prevPoint = null;

                                    for (let p = 0; p < tempTrajectory.rawPoints.length; p++) {
                                        tempPrevPoint.nextPoint = tempTrajectory.rawPoints[p];
                                        tempTrajectory.rawPoints[p].prevPoint = tempPrevPoint;
                                        tempPrevPoint = tempTrajectory.rawPoints[p];
                                    }
                                    data.trjs.val.push(tempTrajectory);
                                }
                            }
                        }
                    }
                }
            }
        }
        data.trjs.valid = true;
    }
    function newGroundtruth(pL) {
        const pointListByDIDByTimeByFloor = pL;

        for(let did in pointListByDIDByTimeByFloor) {
            if(pointListByDIDByTimeByFloor.hasOwnProperty(did)) {
                for(let t in pointListByDIDByTimeByFloor[did]) {
                    if(pointListByDIDByTimeByFloor[did].hasOwnProperty(t)) {
                        for (let f in pointListByDIDByTimeByFloor[did][t]) {
                            if (pointListByDIDByTimeByFloor[did][t].hasOwnProperty(f)) {

                                const tempTrajectory = new Trajectory(pointListByDIDByTimeByFloor[did][t][f], f);
                                tempTrajectory.rawPoints.forEach(function(pt) {
                                    pt.trajectory = tempTrajectory;
                                });

                                if (tempTrajectory.rawPoints.length > 1) {

                                    let tempPrevPoint = tempTrajectory.rawPoints[0];
                                    tempPrevPoint.prevPoint = null;

                                    for (let p = 0; p < tempTrajectory.rawPoints.length; p++) {
                                        tempPrevPoint.nextPoint = tempTrajectory.rawPoints[p];
                                        tempTrajectory.rawPoints[p].prevPoint = tempPrevPoint;
                                        tempPrevPoint = tempTrajectory.rawPoints[p];
                                    }
                                    data.grts.val.push(tempTrajectory);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

//--CLUSTERING----------------------------------------------------------------------------------------------------------
//  ToDo: data.clts.points.push(cluster.members) --> change .points. to .members

    function cluster(trajs) {
        const vertices = [];

        flags.clustering.subsaPoints = 0;

        trajs.forEach(function(traj) {
            traj.subsaPoints = subsamplePoints(traj);
            vertices.push(traj.subsaPoints);
        });

        console.log("subsaP: " + flags.clustering.subsaPoints);

        //centroid seed
        const P = vertices; //Points
        const G = generateGrid(P); //Grid
        const R = seedCentroids(P, G); //Results

        flags.clustering.redistChange = true;
        let i = 0;
        while((i < bd.redist) && flags.clustering.redistChange) {
            redistributePoints(P, R, G);
            recalculateCentroids(R, G);
            //console.log(i);
            i++;
        }
        let ml = 0;
        R.forEach(function(cluster) {
            if(ml < cluster.members.length) ml = cluster.members.length;
        });

        R.forEach(function(cluster) {
            //cluster.centroid.color = Math.random() * par.ct.color + par.ct.corrColor;
            const scale = chroma.scale(par.cl.colorScaleType).domain([0,ml]);
            cluster.centroid.color = scale(cluster.members.length).darken(par.cl.colorDarkenFactor).hex();
            data.clts.val.push(cluster); //ToDo
        });
        data.clts.valid = true;
    }

    function subsamplePoints(traj) {
        const vertices = [];//R = Radius for subsampling, r = radius remaining for next segment, i = iterator, p0 = first point of traj, //pA and pB are start and end of segment to be subsampled, D = dist between pA and pB, d = remaining distance
        //p = subsampled point, vh = ratio of _________ (?),
        const points = traj.rawPoints;

        const R = par.subsaRadius;
        let r = R;

        const p0 = new Point({
            did: points[0].did,
            x: points[0].x,
            y: points[0].y,
            f: points[0].f,
            t: points[0].t,
            traj: traj,
            ID: flags.clustering.subsaPoints,
        });
        flags.clustering.subsaPoints++;

        //data.subsaPnts.push(p0); //testing

        p0.prevPoint = null;
        vertices.push(p0);

        let tempPrevPoint = p0;

        for (let i = 0; i < points.length - 2; i++) {
            if (points.hasOwnProperty(i)) {

                const pA = points[i];
                const pB = points[i + 1];

                const D = getSpatialDistance(pA, pB);
                let d = D;
                while (d > r) {
                    const vh = ( r + ( D - d ) ) / D;// t not interpolated!! f not interpolated
                    const p = new Point({
                        did: pA.did,
                        x: (1 - vh) * pA.x + vh * pB.x,
                        y: (1 - vh) * pA.y + vh * pB.y,
                        f: pA.f,
                        t: pA.t,
                        traj: traj,
                        ID: flags.clustering.subsaPoints,
                    });
                    flags.clustering.subsaPoints++;


                    //data.subsaPnts.push(p); //testing

                    p.prevPoint = tempPrevPoint;
                    tempPrevPoint = p;

                    vertices.push(p);

                    d -= r;
                    r = R;
                }
                r -= d;
            }
        }
        return vertices;
    }
    function generateGrid(points) {

        const P = points;
        const G = {
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0,
            grid: []
        };
        for (let i in P) {
            if(P.hasOwnProperty(i)){
                for (let j in P[i]) {
                    if(P[i].hasOwnProperty(j)){
                        const p = P[i][j];
                        if (G.xMin > p.x) G.xMin = p.x;
                        if (G.xMax < p.x) G.xMax = p.x;
                        if (G.yMin > p.y) G.yMin = p.y;
                        if (G.yMax < p.y) G.yMax = p.y;
                    }
                }
            }
        }
        for (let x = G.xMin; x <= G.xMax; x += bd.maxRadius) {
            const gX = [];
            for (let y = G.yMin; y <= G.yMax; y += bd.maxRadius) {
                const gY = [];
                gX.push(gY);
            }
            G.grid.push(gX);
        }
        return G;
    }
    function seedCentroids(points, G) {
        const P = points;
        const R = []; //results

        P.forEach(function(t) {
            t.forEach(function(p) {
                putInProperGroup(p, R, G);
            });
        });
        return R;
    }
    function redistributePoints(P, R, G) {
        const originList = {};
        flags.clustering.redistChange = false;

        //--Remember number of members of each group, them remove members from group
        let r = 0;
        while(r < R.length) {
            if(R.hasOwnProperty(r)){
                originList[r] = R[r].members.length;
                //R[r].members = [];
                R[r].clearMembers();
            }
            r++;
        }
        data.errors.val = [];
        data.errors.valid = false;

        let cnt = 0;

        //--Assign every Point to a group
        P.forEach(function(t) {
            t.forEach(function(p) {

                let cent = getClosestCentroid(p, G);
                if (cent !== null) {// FEHLER! WARUM KANN c NULL SEIN? -> Kein centroid in reichweite

                    cent.cluster.addMember(p);

                } else {

                    data.errors.val.push(p); //ToDo
                    cnt++;
                }
            });
        });

        console.log('redistPoints: No Centroid found in ' + cnt + ' cases!');

        //test for changes
        r = 0;
        while(r < R.length) {
            if(R.hasOwnProperty(r)){
                if(originList[r] !== R[r].members.length) {
                    flags.clustering.redistChange = true;
                }
            }
            r++;
        }

        data.errors.valid = true;
    }

    function recalculateCentroids(R, G) {

        //console.log('start' + R.length);

        const tempR = R;
        R = [];

        let cnt = 0;

        for(let r = 0; r < tempR.length; r++) {
            if(tempR.hasOwnProperty(r)){
                let clus = tempR[r];
                const cent = clus.centroid;
                let gc = getGridPosition(cent, G);

                const index = G.grid[gc.i][gc.j].indexOf(cent);
                G.grid[gc.i][gc.j].splice(index, 1);

                if(clus.members.length !== 0) {

                    clus.updateCentroid();

                    gc = getGridPosition(clus.centroid, G);
                    G.grid[gc.i][gc.j].push(clus.centroid);

                    R.push(clus);

                } else {
                    let k = 0;
                }
            }
        }
        //console.log('end ' + R.length + ', Number of merged centroids: ' + cnt);
    }

    function putInProperGroup(p, R, G) {
        const cent = getClosestCentroid(p, G);
        let clus = new Cluster();
        let gc;

        if (cent === null) {
            clus.centroid = new Centroid(p);
            clus.addMember(p);

            R.push(clus);
        } else {
            clus = cent.cluster; // g is group with centroid cent // indices? centroid array? -------------------------------

            gc = getGridPosition(cent, G);

            const index = G.grid[gc.i][gc.j].indexOf(cent);
            G.grid[gc.i][gc.j].splice(index, 1);

            clus.updateCentroid();
            clus.addMember(p);
        }
        gc = getGridPosition(clus.centroid, G);
        G.grid[gc.i][gc.j].push(clus.centroid);
    }
    function getClosestCentroid(p, G) {

        const gc = getGridPosition(p, G);
        const C = [];
        const range = 1;


        for(let k = Math.max(gc.i - range, 1);
            k < Math.min(gc.i + range, G.grid.length);
            k++) {

            for(let m = Math.max(gc.j - range, 1);
                m < Math.min(gc.j + range, G.grid[gc.i].length);
                m++) {

                for(let c in G.grid[k][m]) {
                    if(G.grid[k][m].hasOwnProperty(c)) {
                        if(((getSpatialDistance(p, G.grid[k][m][c])) <= bd.maxRadius) && (p.f === G.grid[k][m][c].f)) {
                            C.push(G.grid[k][m][c]);
                        }
                    }
                }
            }
        }

        if(C.length === 0) {
            return null;
        } else if(C.length === 1) {
            return C[0];
        } else {
            let ck = C[0];
            C.forEach(function(c) {
                if (getSpatialDistance(c, p) <= getSpatialDistance(ck, p)) {
                    ck = c;
                }
            });
            return ck;
        }
    }
    function getGridPosition(p, G) {
        return {
            i: Math.floor(( p.x - G.xMin ) / bd.maxRadius),
            j: Math.floor(( p.y - G.yMin ) / bd.maxRadius)
        };
    }
    function getSpatialDistance(p1, p2) {
        return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
    }

    function connectTheDots(clusters) {
    /*    clusters.forEach(function(cluster) {
            const centroid = cluster.centroid;
            //centroid.color = Math.random() * par.ct.color + par.ct.corrColor;
//            centroid.prev = new Set();
//            centroid.next = new Set();

            cluster.members.forEach(function (point) {
                if ((point.prevPoint !== null) && (point.prevPoint.centroid !== null)){
                    if((point.prevPoint.centroid !== point.centroid) && (point.prevPoint.centroid.f === point.centroid.f)) {
                        centroid.addPrevCentroid(point.prevPoint.centroid);
                    }
                }
                if ((point.nextPoint !== null) && (point.nextPoint.centroid !== null)){
                    if((point.nextPoint.centroid !== point.centroid) && (point.nextPoint.centroid.f === point.centroid.f)) {
                        centroid.addNextCentroid(point.nextPoint.centroid);
                    }
                }
            });
        });
        clusters.forEach(function (cluster) {
            const centroid = cluster.centroid;
            centroid.nextCentroids.forEach(function(nextCentroid) {
                data.grph.edges.val.push({
                    start: centroid,
                    end: nextCentroid
                });
            });
        }); */
    }

    function rand_BoxMuller() {
        const u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1].
        const v = 1 - Math.random();
        return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    }

//--MAKE-(THREE.JS)-----------------------------------------------------------------------------------------------------

    function makePoints(traj) {
        //const trajGeom = makePointGeometry(traj.rawPoints);
        //traj.dots = createDots(trajGeom, traj.color, par.tj.dot.opacity, par.tj.dot.size, traj);
        const dots = new THREE.Group();
        traj.rawPoints.forEach(function(point) {
            const pointGeom = makeCircleGeometry(par.tj.dot.size, point, 0);
            dots.add(createCircle(pointGeom, traj.color, par.tj.opacity, par.tj.dot.size, traj));
        });
        traj.dots = dots;
    }
    function makeLine(traj) {
        const trajGeom = makePointGeometry(traj.rawPoints);
        traj.line = createLine(trajGeom, traj.color, par.tj.opacity, false, THREE.NoColors, THREE.FlatShading, traj);
    }
    function makeCentroid(clus) {
        //const centGeom = makePointGeometry([clus.centroid]);
        //clus.centDot = createDots(centGeom, clus.centroid.color, par.ct.opacity, par.ct.size, clus.centroid);
        const centGeom = makeCircleGeometry(par.ct.size, clus.centroid, 0); // par.ct.corrZ);
        clus.centDot = createCircle(centGeom, clus.centroid.color, par.ct.opacity, false, clus.centroid);//clus.centroid);
    }
    function makeCircle(clus) {
        const circleGeom = makeCircleGeometry(bd.maxRadius / 2, clus.centroid, par.ct.circles.corrZ);
        clus.circMesh = createCircle(circleGeom, clus.centroid.color, par.ct.circles.opacity, true, null);//clus.centroid);
    }
    function makeCluster(clus) {
        //const pointsGeom = makePointGeometry(clus.members);
        //clus.membDots = createDots(pointsGeom, clus.centroid.color, par.tj.dot.opacity, par.tj.dot.size, clus.members);
        const members = new THREE.Group();
        clus.members.forEach(function(point) {
            const pointGeom = makeCircleGeometry(par.tj.dot.size, point, 0);
            members.add(createCircle(pointGeom, clus.centroid.color, par.tj.dot.opacity, par.tj.dot.size, clus.members));
        });
        clus.membDots = members;
    }
    function makeErrors() {
        //const errorGeom = makePointGeometry(data.errors.val);
        //draw.errors = createDots(errorGeom, par.cl.errors.color, par.tj.dot.opacity, par.tj.dot.size, data.errors.val); //temp
        const errors = new THREE.Group();
        data.errors.val.forEach(function(point) {
            const errorGeom = makeCircleGeometry(par.tj.dot.size, point, 0);
            errors.add(createCircle(errorGeom, par.cl.errors.color, par.tj.dot.opacity, par.tj.dot.size, data.errors.val)); //data.errors.val));
            point.isError = true;
        });
        draw.errors = errors;
    }
    function makeGraph(traj) {
        traj.findCentroids();
        const trajGeom = makeTrajLineGeom(traj);
        traj.centLine = createLine(trajGeom, 0xffffff, par.ln.opacity, par.ln.transparency,
                                    THREE.VertexColors, THREE.FlatShading, traj);
    }
    function makeAnchorCurve(traj) {
        traj.findCentroids();
        //traj.findAnchors();
        traj.findBezAnchors();
        //const trajGeom = makeTrajCurveGeom(traj);
        const trajGeom = makeTrajBezCurveGeom(traj);
        if(trajGeom && (traj.anchors.length !== 0)) {
            traj.anchLine = createLine(trajGeom, par.ln.color, par.ln.opacity, par.ln.transparency,
                                        THREE.NoColors, THREE.FlatShading, traj);
        }
    }

    function makePointGeometry(points) {
        const pointsGeom = new THREE.Geometry();
        points.forEach(function(point) {
            pointsGeom.vertices.push(new THREE.Vector3(point.x, -point.y, point.f));
        });
        return pointsGeom;
    } //three.js
    function makeCircleGeometry(radius, point, corrZ) {
        const circleGeom = new THREE.CircleGeometry(radius, par.ct.circles.segNum);
        circleGeom.translate(point.x, -point.y, point.f + corrZ);
        return circleGeom;
    } //three.js
    function makeLineSegGeom(lineSeg) {
        const lineSegGeom = new THREE.Geometry();
        lineSegGeom.vertices.push(new THREE.Vector3(lineSeg.start.x, -lineSeg.start.y, lineSeg.start.f));
        lineSegGeom.vertices.push(new THREE.Vector3(lineSeg.end.x, -lineSeg.end.y, lineSeg.end.f));
        lineSegGeom.colors.push(new THREE.Color(lineSeg.start.color));
        lineSegGeom.colors.push(new THREE.Color(lineSeg.end.color));
        return lineSegGeom;
    } //three.js
    function makeTrajLineGeom(traj) {
        const trajGeom = new THREE.Geometry();
        traj.clusters.forEach(function(clus) {
            trajGeom.vertices.push(
                new THREE.Vector3(
                    clus.centroid.x + traj.deviation * par.tj.deviationFactor,
                    -clus.centroid.y + traj.deviation * par.tj.deviationFactor,
                    clus.centroid.f));
            trajGeom.colors.push(new THREE.Color(clus.centroid.color));
        });
        return trajGeom;
    } //three.js
    function makeTrajCurveGeom(traj) {
        if(traj.anchors.length > 1) {
            const anchorGeom = new THREE.Geometry();
            traj.anchors.forEach(function (anch) {
                anchorGeom.vertices.push(
                    new THREE.Vector3(
                        anch.x + traj.deviation * par.tj.deviationFactor,
                        -anch.y + traj.deviation * par.tj.deviationFactor,
                        anch.f));
            });
            const curve = new THREE.CatmullRomCurve3(anchorGeom.vertices);
            let curveGeom = new THREE.Geometry();
            curveGeom.vertices = curve.getPoints(50);

            return curveGeom;
        } else {
            return false;
        }
        //started to implement splines --> continue
        /*trajs.forEach(function (traj) {
         const anchorVertices = [];
         traj.anchors.forEach(function (point) {
         anchorVertices.push(
         new THREE.Vector3(
         point.x + traj.deviation * 0.25,
         point.y * -1 + traj.deviation * 0.25,
         point.f));
         });
         const anchorSpline = new THREE.SplineCurve3(anchorVertices);
         const path = new THREE.Path(anchorSpline.getPoints( 50 ));
         const anchorGeom = path.createPointsGeometry( 50 );
         anchorGeoms.push(anchorGeom);
         });*/
    } //three.js
    function makeTrajBezCurveGeom(traj) {
        if(traj.anchors.length > 2) {
            const a = traj.anchors;

            const geom = new THREE.CurvePath();

            let i = 0;
            const curveS = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(
                    a[i].x + traj.deviation * par.tj.deviationFactor,
                    -a[i].y + traj.deviation * par.tj.deviationFactor,
                    a[i].f),
                new THREE.Vector3(
                    a[i].x + traj.deviation * par.tj.deviationFactor,
                    -a[i].y + traj.deviation * par.tj.deviationFactor,
                    a[i].f),
                new THREE.Vector3(
                    a[i + 1].x + traj.deviation * par.tj.deviationFactor,
                    -a[i + 1].y + traj.deviation * par.tj.deviationFactor,
                    a[i + 1].f)
            );
            geom.add(curveS);

            i++;
            while (i < traj.anchors.length - 2) {

                const curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(
                        a[i].x + traj.deviation * par.tj.deviationFactor,
                        -a[i].y + traj.deviation * par.tj.deviationFactor,
                        a[i].f),
                    new THREE.Vector3(
                        a[i + 1].x + traj.deviation * par.tj.deviationFactor,
                        -a[i + 1].y + traj.deviation * par.tj.deviationFactor,
                        a[i + 1].f),
                    new THREE.Vector3(
                        a[i + 2].x + traj.deviation * par.tj.deviationFactor,
                        -a[i + 2].y + traj.deviation * par.tj.deviationFactor,
                        a[i + 2].f)
                );
                geom.add(curve);

                i += 2;
            }

            const curveE = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(
                    a[i].x + traj.deviation * par.tj.deviationFactor,
                    -a[i].y + traj.deviation * par.tj.deviationFactor,
                    a[i].f),
                new THREE.Vector3(
                    a[i + 1].x + traj.deviation * par.tj.deviationFactor,
                    -a[i + 1].y + traj.deviation * par.tj.deviationFactor,
                    a[i + 1].f),
                new THREE.Vector3(
                    a[i + 1].x + traj.deviation * par.tj.deviationFactor,
                    -a[i + 1].y + traj.deviation * par.tj.deviationFactor,
                    a[i + 1].f)
            );
            geom.add(curveE);

            return geom.createPointsGeometry(50);
        } else {
            return false;
        }
    }

    function createDots(geom, color, opa, pointSize, userData = {}) {
        const mat = new THREE.PointsMaterial({color: color, opacity: opa, size: pointSize, sizeAttenuation: false});
        const dots = new THREE.Points(geom, mat);
        dots.userData = userData;
        return dots;
    } //three.js
    function createLine(geom, color, opa, trans, vColors, shad, userData = {}) {
        const mat = new THREE.LineBasicMaterial({color: color, opacity: opa, transparent: trans, vertexColors: vColors, shading: shad});
        const line = new THREE.Line(geom, mat);
        line.userData = userData;
        return line;
    } //three.js
    function createCircle(geom, color, opa, trans, userData = {}) {
        const mat = new THREE.MeshBasicMaterial({color: color, opacity: opa, transparent: trans});
        const circle = new THREE.Mesh(geom, mat);
        circle.userData = userData;
        return circle;
    }
    function createLineSegment(geom, color, opa, trans, vColors, shad, userData = {}) {
        const mat = new THREE.LineBasicMaterial({color: color, opacity: opa, transparent: trans, vertexColors: vColors, shading: shad});
        const lineSeg = new THREE.LineSegments(geom, mat);
        lineSeg.userData = userData;
        return lineSeg;
    }

//--ADD-&-REMOVE--------------------------------------------------------------------------------------------------------
//  ToDo: review lineTypes

    //--All-Trajectories------------------------------------------------------------------------------------------------

    function showCheckedDrawings() {
        for(let ch in guiPar.checkboxes.lineTypes.choices) {
            if(guiPar.checkboxes.lineTypes.choices.hasOwnProperty(ch)) {
                if(bd.lineType[ch]) show(ch);
            }
        }
    }

    function show(choice) {
        switch(choice) {
            case 'points': {
                if(!data.trjs.valid) break;
                data.trjs.val.forEach(function(traj) {
                    if(!traj.dots) makePoints(traj);
                    scene.add(traj.dots);
                });
                break;
            }
            case 'lines': {
                if(!data.trjs.valid) break;
                data.trjs.val.forEach(function(traj) {
                    if(!traj.line) makeLine(traj);
                    scene.add(traj.line);
                });
                break;
            }
            case 'centroids': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.clts.val.forEach(function(clus) {
                    if(!clus.centDot) makeCentroid(clus);
                    scene.add(clus.centDot);
                });
                break;
            }
            case 'circles': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.clts.val.forEach(function(clus) {
                    if(!clus.circMesh) makeCircle(clus);
                    scene.add(clus.circMesh);
                });
                break;
            }
            case 'clusters': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.clts.val.forEach(function(clus) {
                    if(!clus.membDots) makeCluster(clus);
                    scene.add(clus.membDots);
                });
                if(data.errors.val.length !== 0) {
                    if(!draw.errors) makeErrors();
                    scene.add(draw.errors);
                }
                break;
            }
            case 'graph': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.trjs.val.forEach(function(traj) {
                    if(!traj.centLine) makeGraph(traj);
                    scene.add(traj.centLine);
                });
                break;
            }
            case 'curves': {
                if(!data.clts.valid) cluster(data.trjs.val);
                data.trjs.val.forEach(function(traj) {
                    if(!traj.anchLine) makeAnchorCurve(traj);
                    if(traj.anchLine instanceof THREE.Line) {
                        scene.add(traj.anchLine);
                    }
                });
                break;
            }
            case 'groundtruth': {
                if(!data.grts.valid) break;
                data.grts.val.forEach(function(traj) {
                    if(!traj.line) makeLine(traj);
                    scene.add(traj.line);
                });
                break;
            }
        }
    }

    function hideDrawing(choices) {
        choices.forEach(function(choice) {
            switch(choice) {
                case 'bgMs': {
                    for (let bgMesh in draw.bgMs) {
                        if (draw.bgMs.hasOwnProperty(bgMesh)) {
                            scene.remove(draw.bgMs[bgMesh]);
                        }
                    }
                    break;
                }
                case 'grds': {
                    for (let floor in data.grds) {
                        if (data.grds.hasOwnProperty(floor)) {
                            scene.remove(data.grds[floor].drawing);
                        }
                    }
                    break;
                }
                case 'points': {
                    data.trjs.val.forEach(function(traj) {
                        scene.remove(traj.dots);
                    });
                    break;
                }
                case 'lines': {
                    data.trjs.val.forEach(function(traj) {
                        scene.remove(traj.line);
                    });
                    break;
                }
                case 'centroids': {
                    data.clts.val.forEach(function(clus) {
                        scene.remove(clus.centDot);
                    });
                    break;
                }
                case 'circles': {
                    data.clts.val.forEach(function(clus) {
                        scene.remove(clus.circMesh);
                    });
                    break;
                }
                case 'clusters': {
                    data.clts.val.forEach(function(clus) {
                        scene.remove(clus.membDots);
                    });
                    scene.remove(draw.errors);
                    break;
                }
                case 'graph': {
                    data.trjs.val.forEach(function(traj) {
                        scene.remove(traj.centLine);
                    });
                    break;
                }
                case 'curves': {
                    data.trjs.val.forEach(function(traj) {
                        scene.remove(traj.anchLine);
                    });
                    break;
                }
                case 'groundtruth': {
                    data.grts.val.forEach(function(traj) {
                        scene.remove(traj.line);
                    });
                    break;
                }
            }
        });
    }
    function removeDrawing(choices) {
        choices.forEach(function(choice) {
            switch(choice) {
                case 'bgMs': {
                    draw.bgMs = {};
                    break;
                }
                case 'grds': {
                    for (let floor in data.grds) {
                        if (data.grds.hasOwnProperty(floor)) {
                            delete data.grds[floor].drawing;
                        }
                    }
                    break;
                }
                case 'trjs': {
                    data.trjs.val.forEach(function(traj) {
                        traj.emptyDrawing();
                    });
                    break;
                }
                case 'clts': {
                    data.clts.val.forEach(function(clus) {
                        clus.emptyClusterDrawing();
                    });
                    break;
                }
                case 'errors': {
                    draw.errors = null;
                    break;
                }
                case 'grts': {
                    data.grts.val.forEach(function(traj) {
                        traj.emptyDrawing();
                    });
                    break;
                }
            }
        });
    }
    function deleteData(choices) {
        choices.forEach(function(choice) {
            switch(choice) {
                case 'trjs': {
                    data.trjs = {
                        valid: false,
                        val: [],
                    };
                    break;
                }
                case 'clts': {
                    data.clts = {
                        valid: false,
                        val: [],
                    };
                    break;
                }
                case 'errors': {
                    data.errors = {
                        valid: false,
                        val: [],
                    };
                    draw.errors = null;
                    break;
                }
                case 'grts': {
                    data.grts = {
                        valid: false,
                        val: [],
                    };
                    break;
                }
            }
        });
    }

    //--All-Trajectories------------------------------------------------------------------------------------------------
    function hideTrajectoryDrawings() {
        hideDrawing(['points', 'lines', 'centroids', 'circles', 'clusters', 'graph', 'curves', 'groundtruth']);
    } //three.js
    function deleteTrajectoryData() {
        hideTrajectoryDrawings();
        deleteData(['trjs', 'clts', 'errors', 'grts']);
    }

    function hideGroundtruthTrajectories() {
        hideDrawing(['groundtruth']);
    }
    function deleteGroundtruthTrajectories() {
        hideGroundtruthTrajectories();
        deleteData(['grts']);
    }

    //--Special-Trajectories--------------------------------------------------------------------------------------------
    function hideClusterTrajectories() {
        hideDrawing(['centroids', 'circles', 'clusters', 'graph', 'curves']);
    }
    function deleteClusterTrajectories() {
        hideClusterTrajectories();
        data.trjs.val.forEach(function(traj) {
            traj.emptyClusterData();
        });
        data.clts.valid = false;
        deleteData(['clts', 'errors']);
    }

    //--Everything------------------------------------------------------------------------------------------------------
    function hideEverything() {
         hideDrawing(['bgMs', 'grds']);
         hideTrajectoryDrawings();
    }
    function deleteEverything() {
        deleteAllBgMeshes();
        deleteAllGrids();
        deleteTrajectoryData();
    }

    //--Meshes----------------------------------------------------------------------------------------------------------
    function deleteAllBgMeshes() {
        hideDrawing(['bgMs']);
        removeDrawing(['bgMs']);
    }

    //--Grids-----------------------------------------------------------------------------------------------------------
    function hideAllGrids() {
        hideDrawing(['grds']);
    }
    function deleteAllGrids() {
        hideDrawing(['grds']);
        removeDrawing(['grds']);
        deleteData(['grds']);
    }

//--CHANGE--------------------------------------------------------------------------------------------------------------

    function changeScale() {
        deleteAllBgMeshes();
        deleteAllGrids();
        loadNewBgMesh(bd.path, bd.floor); //also invokes loadNewGrid();
        showCheckedDrawings();
    }
    function changeFloors() {
        if (!(draw.bgMs[bd.floor] instanceof THREE.Mesh)) {
            loadNewBgMesh(bd.path, bd.floor); //also invokes loadGrid()
        }
        updateCamera();
        updateRaycaster();
    }
    function changeLineType() {
        hideTrajectoryDrawings();
        showCheckedDrawings();
    }
    function changeInfoType() {
        INTERSECTED.forEach(function(o) {
            unShowInfo(o);
            showInfo(o);
        });
    }
    function changeClusterRadius() {
        deleteClusterTrajectories();
        hideTrajectoryDrawings();
        showCheckedDrawings();
    }
    function changeMaxRedist() {
        hideTrajectoryDrawings();
        deleteClusterTrajectories();
        showCheckedDrawings();
    }

</script>
</body>
</html>