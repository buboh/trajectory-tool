<html>
<head>
    <title>draw_lines</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<div>
    Select a text file:
    <input type="file" id="fileInput">
</div>
<!--<canvas class="canvas" style="background-size: 140%; background-image: url('img/indoors-office.png')">

</canvas>-->
<script src="js/papaparse.js"></script>
<script src="js/three.js"></script>
<script>

    var camera, scene, renderer;
    var FRAME_COORDSYS = 50;
    var V_LEFT_CORR = - ((window.innerWidth / 2) - FRAME_COORDSYS);
    var V_TOP_CORR = (window.innerHeight / 2) - FRAME_COORDSYS;
    var V_RIGHT_CORR = (window.innerWidth / 2) - FRAME_COORDSYS;
    var V_BOTTOM_CORR = - ((window.innerHeight / 2) - FRAME_COORDSYS);
    var IW = window.innerWidth;
    var IH = window.innerHeight;
    var SCALE_STROKE_L = 10; //length of scale strokes
    var SCALE_STROKE_D = 50; //space between two scale strokes

    initTextReader();
    init();
    render();

    function init() {

        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -500, 1000);

        var bgMaterial = new THREE.MeshBasicMaterial();

        var loader = new THREE.TextureLoader();
        loader.load(
            'img/indoors-office.png',
            function ( texture ) {
                bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture
                });

                var backgroundMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(window.innerWidth, window.innerHeight, 0),
                    bgMaterial
                );
                scene.add(backgroundMesh);
                render();
            },
            function () {},
            function () {
                console.log('bg-loading failed');
            }
        );

        //Coordinate system
        var coordGeometry = new THREE.Geometry();
        //x-axis
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_TOP_CORR, 1));
        coordGeometry.vertices.push( new THREE.Vector3(V_RIGHT_CORR, V_TOP_CORR, 1));

        //y-axis
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_TOP_CORR, 1));
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_BOTTOM_CORR, 1));

        var coordMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, opacity: 1 } );
        var coordLines = new THREE.Line( coordGeometry, coordMaterial );
        scene.add(coordLines);

        var scaleGeometry = new THREE.Geometry();

        // "*2" in for-Schleife, weil oben UND unten bzw. rechts UND links ein Rahmen ist
        //scale strokes for x-axis
        for ( i = 0; i < (IW - FRAME_COORDSYS * 2); i += SCALE_STROKE_D ){
            scaleGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR + i * 1, V_TOP_CORR + SCALE_STROKE_L, 1 ));
            scaleGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR + i * 1, V_TOP_CORR, 1 ));
        }
        //scale strokes for y-axis
        for ( i = 0; i < IH - FRAME_COORDSYS * 2; i += SCALE_STROKE_D ){
            scaleGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR - SCALE_STROKE_L, V_TOP_CORR + i * - 1, 1 ));
            scaleGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_TOP_CORR + i * - 1, 1 ));
        }


        var scaleLines = new THREE.LineSegments( scaleGeometry, coordMaterial );
        scene.add(scaleLines);

        renderer = new THREE.WebGLRenderer( {antialias: true, alpha: true} );
        renderer.setClearColor( 0xffffff, 0);
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
    }

    function initTextReader () {

        var fileInput = document.getElementById('fileInput');
        fileInput.addEventListener( 'change', function( e ) {

            var file = fileInput.files[0];
            var textType = /text.*/;

            if (file.type.match(textType)) {
                var reader = new FileReader();
                reader.onload = function ( e ) {
                    //alert(reader.result);
                    drawTrajectories(reader.result);
                };
                reader.readAsText(file);
            } else {
                alert("File not supported");
            }
        });
    }

    function drawTrajectories ( readerResult ){

        var trajectoryMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, opacity: 1 } );
        var trajectoryList = makeTrajectoryCurves(groupPointList(importCSV(readerResult)));
        trajectoryList.forEach(
            function ( trajectory ) {
                scene.add( new THREE.Line( trajectory, trajectoryMaterial));
            }
        );
        render();
    }

    //straight lines instead of curves -- not in use
    function makeTrajectoryLines ( sortedPointList ) {
        //var point = { x: 0, y: 0, t: 0, f: 0, id: "0" };
        var tempTrajectoryList = [];

        sortedPointList.forEach(
            function ( pointGroup ) {
                var geometry = new THREE.Geometry();
                pointGroup.forEach(
                    function ( point ){
                        geometry.vertices.push( new THREE.Vector3(point.x, point.y, 0));
                    }
                );
                tempTrajectoryList.push(geometry);
            }
        );
        return tempTrajectoryList;
    }

    //makes SplineCurve3s from pointList
    function makeTrajectoryCurves ( sortedPointList ) {
        var tempTrajectoryList = [];

        sortedPointList.forEach(
            function ( pointGroup ) {
                var points = [];
                pointGroup.forEach(
                    function ( point ){
                        points.push( new THREE.Vector3(point.x, point.y, 0));
                    }
                );
                var curve = new THREE.CatmullRomCurve3( points );
                var geometry = new THREE.Geometry();
                geometry.vertices = curve.getPoints( 50 );
                tempTrajectoryList.push( geometry );
            }
        );
        return tempTrajectoryList;
    }

    function groupBy( array , f ) {

        var groups = {};
        array.forEach(
            function( object ) {
                var group = JSON.stringify( f( object ) );
                groups[group] = groups[group] || [];
                groups[group].push( object );
            }
        );

        //erweitern um zwischen einzelnen trajectories nach der Zeit zu unterscheiden

        //filter DIDs with only one point -- not working, groups is an object, not list
        /*var filteredGroups = [];
        groups.forEach(function ( group ) {
            if (group.size > 1) {
                filteredGroups.push(group);
            }
        });*/

        return Object.keys(groups).map(
            function( group ) {
                return groups[group];
            }
        )
    }

    function groupPointList ( pointList ) {

        var pointListByID = groupBy(
            pointList,
            function(item) {
                return [item.did]; //, item.t
            }
        );
        //console.log(pointListByID);
        return pointListByID;
    }

    function importCSV ( csvString ) {

        var results = Papa.parse(csvString , {
            header: true,
            dynamicTyping: true
        });
        //console.log(results);

        /*var pointList = [];
            results.data.forEach(function ( o ){
                pointList.push( o );
            })*/

        //not implemented yet

        /*    var iW = window.innerWidth;
        var iH = window.innerHeight;*/

        /*var pointList = [
            {x: 0, y: 500, t: 0, f: 1, id: "10"},
            {x: 10, y: 490, t: 10, f: 1, id: "10"},
            {x: 20, y: 500, t: 20, f: 1, id: "10"},
            {x: 30, y: 470, t: 30, f: 1, id: "10"},
            {x: 40, y: 460, t: 40, f: 1, id: "20"},
            {x: 50, y: 450, t: 50, f: 1, id: "20"},
            {x: 60, y: 440, t: 60, f: 1, id: "30"},
            {x: 70, y: 430, t: 70, f: 1, id: "30"},
            {x: 80, y: 420, t: 80, f: 1, id: "30"},
            {x: 90, y: 410, t: 90, f: 1, id: "30"},
            {x: 100, y: 400, t: 100, f: 1, id: "40"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "40"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"}
        ];*/

        results.data.forEach(
            function ( point ) {
                point.x = point.x + V_LEFT_CORR;
                point.y = point.y * ( - 1 ) + V_TOP_CORR;
            }
        );
        return results.data;
    }

    function render() {
        renderer.render( scene, camera );
    }

</script>
</body>
</html>

<!-- todo: fix aspect ratio bg-img, scale (maÃŸstab) -->