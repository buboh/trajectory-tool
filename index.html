<html>
<head>
    <title>draw_lines</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<script src="js/papaparse.js"></script>
<script src="js/three.js"></script>
<script>

    var camera, scene, renderer;
    var FRAME_COORDSYS = 50;
    var V_LEFT_CORR = - ((window.innerWidth / 2) - FRAME_COORDSYS);
    var V_TOP_CORR = (window.innerHeight / 2) - FRAME_COORDSYS;
    var V_RIGHT_CORR = (window.innerWidth / 2) - FRAME_COORDSYS;
    var V_BOTTOM_CORR = - ((window.innerHeight / 2) - FRAME_COORDSYS);

    init();
    render();

    function init() {

        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -500, 1000);

        //Coordinate system
        var coordGeometry = new THREE.Geometry();
        //x-axis
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_TOP_CORR, 0));
        coordGeometry.vertices.push( new THREE.Vector3(V_RIGHT_CORR, V_TOP_CORR, 0));
        //y-axis
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_TOP_CORR, 0));
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_BOTTOM_CORR, 0));

        var coordMaterial = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 1 } );
        var coordLines = new THREE.Line( coordGeometry, coordMaterial );
        scene.add( coordLines );

        //Trajectories
        var trajectoryMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, opacity: 1 } );
        //var trajectoryList = makeTrajectoryLines(groupPointList(importCSV()));
        var trajectoryList = makeTrajectorySplines(groupPointList(importCSV()));
        trajectoryList.forEach(
            function ( trajectory ) {

                scene.add( new THREE.Line( trajectory, trajectoryMaterial));
            }
        );

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor( 0xffffff );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
    }

    function importCSV () {
        //not implemented yet

        var iW = window.innerWidth;
        var iH = window.innerHeight;

        var pointList = [
            {x: 0, y: 500, t: 0, f: 1, id: "10"},
            {x: 10, y: 490, t: 10, f: 1, id: "10"},
            {x: 20, y: 500, t: 20, f: 1, id: "10"},
            {x: 30, y: 470, t: 30, f: 1, id: "10"},
            {x: 40, y: 460, t: 40, f: 1, id: "20"},
            {x: 50, y: 450, t: 50, f: 1, id: "20"},
            {x: 60, y: 440, t: 60, f: 1, id: "30"},
            {x: 70, y: 430, t: 70, f: 1, id: "30"},
            {x: 80, y: 420, t: 80, f: 1, id: "30"},
            {x: 90, y: 410, t: 90, f: 1, id: "30"},
            {x: 100, y: 400, t: 100, f: 1, id: "40"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "40"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"}
        ];

        pointList.forEach(
            function ( point ) {
                point.x = point.x + V_LEFT_CORR;
                point.y = point.y * ( - 1 ) + V_TOP_CORR;
            }
        );

        return pointList;
    }

    function groupBy( array , f ) {

        var groups = {};
        array.forEach(
            function( object ) {
                var group = JSON.stringify( f( object ) );
                groups[group] = groups[group] || [];
                groups[group].push( object );
            }
        );
        return Object.keys(groups).map(
            function( group ) {
                return groups[group];
            }
        )
    }

    function groupPointList ( pointList ) {

        var pointListByID = groupBy(
            pointList,
            function(item) { //erweitern um zwischen einzelnen trajectories nach der Zeit zu unterscheiden
                return [item.id]; //, item.t
            }
        );

        console.log(pointListByID);
        return pointListByID;
    }

    //straight lines instead of curves -- deprecated
    function makeTrajectoryLines ( sortedPointList ) {
        //var point = { x: 0, y: 0, t: 0, f: 0, id: "0" };
        var tempTrajectoryList = [];

        sortedPointList.forEach(
            function ( pointGroup ) {
                var geometry = new THREE.Geometry();
                pointGroup.forEach(
                    function ( point ){
                        geometry.vertices.push( new THREE.Vector3(point.x, point.y, 0));
                    }
                );
                tempTrajectoryList.push(geometry);
            }
        );
        return tempTrajectoryList;
    }

    //makes SplineCurve3s from pointList
    function makeTrajectorySplines ( sortedPointList ) {
        var tempTrajectoryList = [];

        sortedPointList.forEach(
            function ( pointGroup ) {
                var points = [];
                pointGroup.forEach(
                    function ( point ){
                        points.push( new THREE.Vector3(point.x, point.y, 0));
                    }
                );
                var curve = new THREE.SplineCurve3( points );
                tempTrajectoryList.push( new THREE.Path(curve.getPoints( 50 )).createPointsGeometry( 50 ));
            }
        );
        return tempTrajectoryList;
    }

    function render() {
        renderer.render( scene, camera );
    }


</script>
</body>
</html>