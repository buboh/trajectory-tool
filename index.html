<html>
<head>
    <title>draw_lines</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<div>
    Select a text file:
    <input type="file" id="fileInput">

</div>
<script src="js/three.js"></script>
<!--<script src="js/stats.js"></script>-->
<script src="js/dat.gui.js"></script>
<script src="js/papaparse.js"></script>
<script>

    //Set scene size
    var WIDTH = window.innerWidth;
    var HEIGHT = window.innerHeight;

    //Set camera attributes
    var LEFT = WIDTH / -2;
    var RIGHT = WIDTH / 2;
    var TOP = HEIGHT / 2;
    var BOTTOM = HEIGHT / -2;
    var NEAR = -500;
    var FAR = 1000;

    //Background image
    var bgRatio = 0;

    //Coordinate system
    var FRAME_COORDSYS = 50;
    var V_LEFT_CORR = - ((WIDTH / 2) - FRAME_COORDSYS);
    var V_TOP_CORR = (HEIGHT / 2) - FRAME_COORDSYS;
    var V_RIGHT_CORR = (WIDTH / 2) - FRAME_COORDSYS;
    var V_BOTTOM_CORR = - ((HEIGHT / 2) - FRAME_COORDSYS);
    var SCALE_STROKE_L = 10; //length of scale strokes
    var SCALE_STROKE_D = WIDTH / 10; //space between two scale strokes

    var container, background, stats;
    var camera, scene, raycaster, renderer;

    initTextReader();
    init();

    //Schedule the first frame.
    requestAnimationFrame(update);

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        /*background = document.getElementById( 'background' );
        background.setAttribute( 'width', '100%' );
        background.setAttribute( 'height', '100%' );*/

      /*  var cont = document.createElement( 'div' );
        cont.background = 'img/indoors-office.png';
        bgRatio = cont.background.naturalWidth / cont.background.naturalHeight;
        cont.background.width = WIDTH;
        cont.background.height = WIDTH / bgRatio;
        container.appendChild( cont );*/

        var bgImg = new Image();
        bgImg.src = 'img/indoors-office.png';
        bgRatio = bgImg.naturalWidth / bgImg.naturalHeight;
        bgImg.width = WIDTH;
        bgImg.height = WIDTH / bgRatio;
        container.appendChild( bgImg );

        //background.drawImage(bgImg, 0, 0);

        /*img.onload = function () {
          //bgImg.src = this.src;
        };*/

        camera = new THREE.OrthographicCamera(LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);

        scene = new THREE.Scene();

        initRest();

        renderer = new THREE.WebGLRenderer( {antialias: true, alpha: true} );
        renderer.setClearColor( 0xffffff, 0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( WIDTH, HEIGHT );
        container.appendChild( renderer.domElement );

        window.addEventListener( 'resize', onWindowResize, false );




        var gui = new dat.GUI();

        gui.add(bgImg, 'height');
        gui.add(bgImg, 'width');

    }

    function update () {
        requestAnimationFrame(update);

        renderer.render(scene, camera);
    }

    function onWindowResize () {

        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;

        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();

        renderer.setSize( WIDTH, HEIGHT );

    }

    function initRest(){

        //Coordinate system
        var coordGeometry = new THREE.Geometry();
        //x-axis
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_TOP_CORR, 1));
        coordGeometry.vertices.push( new THREE.Vector3(V_RIGHT_CORR, V_TOP_CORR, 1));

        //y-axis
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_TOP_CORR, 1));
        coordGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_BOTTOM_CORR, 1));

        var coordMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, opacity: 1 } );
        var coordLines = new THREE.Line( coordGeometry, coordMaterial );
        scene.add(coordLines);

        var scaleGeometry = new THREE.Geometry();

        // "*2" in for-Schleife, weil oben UND unten bzw. rechts UND links ein Rahmen ist
        //scale strokes for x-axis
        for ( i = 0; i < (WIDTH - FRAME_COORDSYS * 2); i += SCALE_STROKE_D ){
            scaleGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR + i * 1, V_TOP_CORR + SCALE_STROKE_L, 1 ));
            scaleGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR + i * 1, V_TOP_CORR, 1 ));
        }
        //scale strokes for y-axis
        for ( i = 0; i < (HEIGHT - FRAME_COORDSYS * 2); i += SCALE_STROKE_D ){
            scaleGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR - SCALE_STROKE_L, V_TOP_CORR + i * - 1, 1 ));
            scaleGeometry.vertices.push( new THREE.Vector3(V_LEFT_CORR, V_TOP_CORR + i * - 1, 1 ));
        }

        var scaleLines = new THREE.LineSegments( scaleGeometry, coordMaterial );
        scene.add(scaleLines);
    }


    function initTextReader () {

        var fileInput = document.getElementById('fileInput');
        fileInput.addEventListener( 'change', function( e ) {

            var file = fileInput.files[0];
            var textType = /text.*/;

            if (file.type.match(textType)) {
                var reader = new FileReader();
                reader.onload = function ( e ) {
                    //alert(reader.result);
                    drawTrajectories(reader.result);
                };
                reader.readAsText(file);
            } else {
                alert("File not supported");
            }
        });
    }

    function drawTrajectories ( readerResult ){

        var trajectoryMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, opacity: 1 } );
        var trajectoryList = makeTrajectoryCurves(groupPointList(importCSV(readerResult)));
        trajectoryList.forEach(
            function ( trajectory ) {
                scene.add( new THREE.Line( trajectory, trajectoryMaterial));
            }
        );
    }

    //straight lines instead of curves -- not in use
    function makeTrajectoryLines ( sortedPointList ) {
        //var point = { x: 0, y: 0, t: 0, f: 0, id: "0" };
        var tempTrajectoryList = [];

        sortedPointList.forEach(
            function ( pointGroup ) {
                var geometry = new THREE.Geometry();
                pointGroup.forEach(
                    function ( point ){
                        geometry.vertices.push( new THREE.Vector3(point.x, point.y, 0));
                    }
                );
                tempTrajectoryList.push(geometry);
            }
        );
        return tempTrajectoryList;
    }

    //makes SplineCurve3s from pointList
    function makeTrajectoryCurves ( sortedPointList ) {
        var tempTrajectoryList = [];

        sortedPointList.forEach(
            function ( pointGroup ) {
                var points = [];
                pointGroup.forEach(
                    function ( point ){
                        points.push( new THREE.Vector3(point.x, point.y, 0));
                    }
                );
                var curve = new THREE.CatmullRomCurve3( points );
                var geometry = new THREE.Geometry();
                geometry.vertices = curve.getPoints( 50 );
                tempTrajectoryList.push( geometry );
            }
        );
        return tempTrajectoryList;
    }

    function groupBy( array , f ) {

        var groups = {};
        array.forEach(
            function( object ) {
                var group = JSON.stringify( f( object ) );
                groups[group] = groups[group] || [];
                groups[group].push( object );
            }
        );

        //erweitern um zwischen einzelnen trajectories nach der Zeit zu unterscheiden

        //filter DIDs with only one point -- not working, groups is an object, not list
        /*var filteredGroups = [];
        groups.forEach(function ( group ) {
            if (group.size > 1) {
                filteredGroups.push(group);
            }
        });*/

        return Object.keys(groups).map(
            function( group ) {
                return groups[group];
            }
        )
    }

    function groupPointList ( pointList ) {

        var pointListByID = groupBy(
            pointList,
            function(item) {
                return [item.did]; //, item.t
            }
        );
        //console.log(pointListByID);
        return pointListByID;
    }

    function importCSV ( csvString ) {

        var results = Papa.parse(csvString , {
            header: true,
            dynamicTyping: true
        });
        //console.log(results);

        /*var pointList = [];
            results.data.forEach(function ( o ){
                pointList.push( o );
            })*/

        //not implemented yet

        /*    var iW = window.innerWidth;
        var iH = window.innerHeight;*/

        /*var pointList = [
            {x: 0, y: 500, t: 0, f: 1, id: "10"},
            {x: 10, y: 490, t: 10, f: 1, id: "10"},
            {x: 20, y: 500, t: 20, f: 1, id: "10"},
            {x: 30, y: 470, t: 30, f: 1, id: "10"},
            {x: 40, y: 460, t: 40, f: 1, id: "20"},
            {x: 50, y: 450, t: 50, f: 1, id: "20"},
            {x: 60, y: 440, t: 60, f: 1, id: "30"},
            {x: 70, y: 430, t: 70, f: 1, id: "30"},
            {x: 80, y: 420, t: 80, f: 1, id: "30"},
            {x: 90, y: 410, t: 90, f: 1, id: "30"},
            {x: 100, y: 400, t: 100, f: 1, id: "40"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "40"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"},
            {x: Math.random() * iW, y: Math.random() * iH, t: 0, id: "50"}
        ];*/

        results.data.forEach(
            function ( point ) {
                point.x = point.x + V_LEFT_CORR;
                point.y = point.y * ( - 1 ) + V_TOP_CORR;
            }
        );
        return results.data;
    }


</script>
</body>
</html>

<!-- todo: fix aspect ratio bg-img, scale (maßstab) -->