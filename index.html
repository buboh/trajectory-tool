<html>
<head>
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<script src="js/three.js"></script>
<script>

    var camera, scene, renderer;

    init();
    render();

    function init() {

        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -500, 1000)
        camera.position.x = 200;
        camera.position.y = 100;
        camera.position.z = 200;


        //Grid

        var gridSize = 500, gridStep = 50;

        var geometry = new THREE.Geometry();

        for ( var i = - gridSize; i <= gridSize; i += gridStep ) {
            geometry.vertices.push( new THREE.Vector3( - gridSize, 0, i ) );
            geometry.vertices.push( new THREE.Vector3(   gridSize, 0, i ) );
            geometry.vertices.push( new THREE.Vector3( i, 0, - gridSize ) );
            geometry.vertices.push( new THREE.Vector3( i, 0,   gridSize ) );
        }

        var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } );
        var line = new THREE.LineSegments( geometry, material );
        scene.add( line );

        var geometry = new THREE.BoxGeometry( 50, 50, 50 );
        var material = new THREE.MeshLambertMaterial( { color: 0xffffff, overdraw: 0.5 } );
        for ( var i = 0; i < 100; i ++ ) {
            var cube = new THREE.Mesh( geometry, material );
            cube.scale.y = Math.floor( Math.random() * 2 + 1 );
            cube.position.x = Math.floor( ( Math.random() * 1000 - 500 ) / 50 ) * 50 + 25;
            cube.position.y = ( cube.scale.y * 50 ) / 2;
            cube.position.z = Math.floor( ( Math.random() * 1000 - 500 ) / 50 ) * 50 + 25;
            scene.add( cube );
        }

        renderer = new THREE.CanvasRenderer();
        renderer.setClearColor( 0xf0f0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

    }

    function render() {
        var timer = Date.now() * 0.0001;
        camera.position.x = Math.cos( timer ) * 200;
        camera.position.z = Math.sin( timer ) * 200;
        camera.lookAt( scene.position );
        renderer.render( scene, camera );
    }


        //var scene = new THREE.Scene();
        //var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
        //var camera = new THREE.OrthographicCamera( window.innerWidth, window.innerWidth, window.innerHeight, window.innerHeight, 0, 2000 );

       /* var renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        var geometry = new THREE.BoxGeometry( 1, 1, 1 );
        var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
        var cube = new THREE.Mesh( geometry, material );
        scene.add( cube );

        camera.position.z = 0;

        var render = function () {
            requestAnimationFrame( render );

            renderer.render(scene, camera);
        };

        render();*/


</script>
</body>
</html>